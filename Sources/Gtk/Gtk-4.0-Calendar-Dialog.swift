import CGLib
import CCairo
import CPango
import CGdkPixbuf
import CGdk
import CGtk
import GLib
import GLibObject
import GIO
import Pango
import Cairo
import PangoCairo
import GdkPixbuf
import Gdk

// MARK: - Calendar Class

/// The `CalendarProtocol` protocol exposes the methods and properties of an underlying `GtkCalendar` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `Calendar`.
/// Alternatively, use `CalendarRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkCalendar` is a widget that displays a Gregorian calendar, one month
/// at a time. It can be created with `gtk_calendar_new()`.
/// 
/// The date that is currently displayed can be altered with
/// `gtk_calendar_select_day()`.
/// 
/// To place a visual marker on a particular day, use `gtk_calendar_mark_day()`
/// and to remove the marker, `gtk_calendar_unmark_day()`. Alternative, all
/// marks can be cleared with `gtk_calendar_clear_marks()`.
/// 
/// The selected date can be retrieved from a `GtkCalendar` using
/// `gtk_calendar_get_date()`.
/// 
/// Users should be aware that, although the Gregorian calendar is the
/// legal calendar in most countries, it was adopted progressively
/// between 1582 and 1929. Display before these dates is likely to be
/// historically incorrect.
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// calendar.view
/// ├── header
/// │   ├── button
/// │   ├── stack.month
/// │   ├── button
/// │   ├── button
/// │   ├── label.year
/// │   ╰── button
/// ╰── grid
///     ╰── label[.day-name][.week-number][.day-number][.other-month][.today]
/// ```
/// 
/// GtkCalendar has a main node with name calendar. It contains a subnode called header
/// containing the widgets for switching between years and months.
/// 
/// The grid subnode contains all day labels, including week numbers on the left (marked
/// with the .week-number css class) and day names on top (marked with the .day-name
/// css class).
/// 
/// Day labels that belong to the previous or next month get the .other-month style class.
/// The label of the current day get the .today style class.
/// 
/// Marked day labels get the :selected state assigned.
public protocol CalendarProtocol: WidgetProtocol {
        /// Untyped pointer to the underlying `GtkCalendar` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCalendar` instance.
    var calendar_ptr: UnsafeMutablePointer<GtkCalendar>! { get }

}

/// The `CalendarRef` type acts as a lightweight Swift reference to an underlying `GtkCalendar` instance.
/// It exposes methods that can operate on this data type through `CalendarProtocol` conformance.
/// Use `CalendarRef` only as an `unowned` reference to an existing `GtkCalendar` instance.
///
/// `GtkCalendar` is a widget that displays a Gregorian calendar, one month
/// at a time. It can be created with `gtk_calendar_new()`.
/// 
/// The date that is currently displayed can be altered with
/// `gtk_calendar_select_day()`.
/// 
/// To place a visual marker on a particular day, use `gtk_calendar_mark_day()`
/// and to remove the marker, `gtk_calendar_unmark_day()`. Alternative, all
/// marks can be cleared with `gtk_calendar_clear_marks()`.
/// 
/// The selected date can be retrieved from a `GtkCalendar` using
/// `gtk_calendar_get_date()`.
/// 
/// Users should be aware that, although the Gregorian calendar is the
/// legal calendar in most countries, it was adopted progressively
/// between 1582 and 1929. Display before these dates is likely to be
/// historically incorrect.
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// calendar.view
/// ├── header
/// │   ├── button
/// │   ├── stack.month
/// │   ├── button
/// │   ├── button
/// │   ├── label.year
/// │   ╰── button
/// ╰── grid
///     ╰── label[.day-name][.week-number][.day-number][.other-month][.today]
/// ```
/// 
/// GtkCalendar has a main node with name calendar. It contains a subnode called header
/// containing the widgets for switching between years and months.
/// 
/// The grid subnode contains all day labels, including week numbers on the left (marked
/// with the .week-number css class) and day names on top (marked with the .day-name
/// css class).
/// 
/// Day labels that belong to the previous or next month get the .other-month style class.
/// The label of the current day get the .today style class.
/// 
/// Marked day labels get the :selected state assigned.
public struct CalendarRef: CalendarProtocol {
        /// Untyped pointer to the underlying `GtkCalendar` instance.
    /// For type-safe access, use the generated, typed pointer `calendar_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CalendarRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCalendar>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCalendar>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCalendar>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCalendar>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CalendarProtocol`
    @inlinable init<T: CalendarProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CalendarProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CalendarProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CalendarProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CalendarProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CalendarProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new calendar, with the current date being selected.
    @inlinable init() {
        let rv = gtk_calendar_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `Calendar` type acts as a reference-counted owner of an underlying `GtkCalendar` instance.
/// It provides the methods that can operate on this data type through `CalendarProtocol` conformance.
/// Use `Calendar` as a strong reference or owner of a `GtkCalendar` instance.
///
/// `GtkCalendar` is a widget that displays a Gregorian calendar, one month
/// at a time. It can be created with `gtk_calendar_new()`.
/// 
/// The date that is currently displayed can be altered with
/// `gtk_calendar_select_day()`.
/// 
/// To place a visual marker on a particular day, use `gtk_calendar_mark_day()`
/// and to remove the marker, `gtk_calendar_unmark_day()`. Alternative, all
/// marks can be cleared with `gtk_calendar_clear_marks()`.
/// 
/// The selected date can be retrieved from a `GtkCalendar` using
/// `gtk_calendar_get_date()`.
/// 
/// Users should be aware that, although the Gregorian calendar is the
/// legal calendar in most countries, it was adopted progressively
/// between 1582 and 1929. Display before these dates is likely to be
/// historically incorrect.
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// calendar.view
/// ├── header
/// │   ├── button
/// │   ├── stack.month
/// │   ├── button
/// │   ├── button
/// │   ├── label.year
/// │   ╰── button
/// ╰── grid
///     ╰── label[.day-name][.week-number][.day-number][.other-month][.today]
/// ```
/// 
/// GtkCalendar has a main node with name calendar. It contains a subnode called header
/// containing the widgets for switching between years and months.
/// 
/// The grid subnode contains all day labels, including week numbers on the left (marked
/// with the .week-number css class) and day names on top (marked with the .day-name
/// css class).
/// 
/// Day labels that belong to the previous or next month get the .other-month style class.
/// The label of the current day get the .today style class.
/// 
/// Marked day labels get the :selected state assigned.
open class Calendar: Widget, CalendarProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Calendar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCalendar>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Calendar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCalendar>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Calendar` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Calendar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Calendar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCalendar>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Calendar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCalendar>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCalendar`.
    /// i.e., ownership is transferred to the `Calendar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCalendar>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CalendarProtocol`
    /// Will retain `GtkCalendar`.
    /// - Parameter other: an instance of a related type that implements `CalendarProtocol`
    @inlinable public init<T: CalendarProtocol>(calendar other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CalendarProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CalendarProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CalendarProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CalendarProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CalendarProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CalendarProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CalendarProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CalendarProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new calendar, with the current date being selected.
    @inlinable public init() {
        let rv = gtk_calendar_new()
        super.init(gpointer: gpointer(rv))
    }


}

public enum CalendarPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`. See `gtk_widget_set_cursor()` for details.
    case cursor = "cursor"
    /// The selected day (as a number between 1 and 31, or 0
    /// to unselect the currently selected day).
    /// This property gets initially set to the current day.
    case day = "day"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    /// The selected month (as a number between 0 and 11).
    /// This property gets initially set to the current month.
    case month = "month"
    case name = "name"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    case parent = "parent"
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget or `nil` if
    /// the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    /// Determines whether day names are displayed.
    case showDayNames = "show-day-names"
    /// Determines whether a heading is displayed.
    case showHeading = "show-heading"
    /// Determines whether week numbers are displayed.
    case showWeekNumbers = "show-week-numbers"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
    /// The selected year.
    /// This property gets initially set to the current year.
    case year = "year"
}

public extension CalendarProtocol {
    /// Bind a `CalendarPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CalendarPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a Calendar property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CalendarPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a Calendar property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CalendarPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CalendarSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// Emitted when the user selects a day.
    case daySelected = "day-selected"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold. May result in finalization of the widget
    /// if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// The `direction`-changed signal is emitted when the text direction
    /// of a widget changes.
    case directionChanged = "direction-changed"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The `hide` signal is emitted when `widget` is hidden, for example with
    /// `gtk_widget_hide()`.
    case hide = "hide"
    /// Gets emitted if keyboard navigation fails.
    /// See `gtk_widget_keynav_failed()` for details.
    case keynavFailed = "keynav-failed"
    /// The `map` signal is emitted when `widget` is going to be mapped, that is
    /// when the widget is visible (which is controlled with
    /// `gtk_widget_set_visible()`) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of `GtkWidget::unmap`.
    case map = "map"
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// Emitted when the user switched to the next month.
    case nextMonth = "next-month"
    /// Emitted when user switched to the next year.
    case nextYear = "next-year"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted when the user switched to the previous month.
    case prevMonth = "prev-month"
    /// Emitted when user switched to the previous year.
    case prevYear = "prev-year"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// Emitted when `GtkWidget:has`-tooltip is `true` and the hover timeout
    /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
    /// focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// The `realize` signal is emitted when `widget` is associated with a
    /// `GdkSurface`, which means that `gtk_widget_realize()` has been called or the
    /// widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// The `show` signal is emitted when `widget` is shown, for example with
    /// `gtk_widget_show()`.
    case show = "show"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The `state`-flags-changed signal is emitted when the widget state
    /// changes, see `gtk_widget_get_state_flags()`.
    case stateFlagsChanged = "state-flags-changed"
    /// The `unmap` signal is emitted when `widget` is going to be unmapped, which
    /// means that either it or any of its parents up to the toplevel widget have
    /// been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer, it can be
    /// used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// The `unrealize` signal is emitted when the `GdkSurface` associated with
    /// `widget` is destroyed, which means that `gtk_widget_unrealize()` has been
    /// called or the widget has been unmapped (that is, it is going to be
    /// hidden).
    case unrealize = "unrealize"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    case notifyCanTarget = "notify::can-target"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`. See `gtk_widget_set_cursor()` for details.
    case notifyCursor = "notify::cursor"
    /// The selected day (as a number between 1 and 31, or 0
    /// to unselect the currently selected day).
    /// This property gets initially set to the current day.
    case notifyDay = "notify::day"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case notifyHalign = "notify::halign"
    case notifyHasDefault = "notify::has-default"
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginTop = "notify::margin-top"
    /// The selected month (as a number between 0 and 11).
    /// This property gets initially set to the current month.
    case notifyMonth = "notify::month"
    case notifyName = "notify::name"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    case notifyParent = "notify::parent"
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget or `nil` if
    /// the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case notifyScaleFactor = "notify::scale-factor"
    case notifySensitive = "notify::sensitive"
    /// Determines whether day names are displayed.
    case notifyShowDayNames = "notify::show-day-names"
    /// Determines whether a heading is displayed.
    case notifyShowHeading = "notify::show-heading"
    /// Determines whether week numbers are displayed.
    case notifyShowWeekNumbers = "notify::show-week-numbers"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case notifyValign = "notify::valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case notifyVexpandSet = "notify::vexpand-set"
    case notifyVisible = "notify::visible"
    case notifyWidthRequest = "notify::width-request"
    /// The selected year.
    /// This property gets initially set to the current year.
    case notifyYear = "notify::year"
}

public extension CalendarProtocol {
    /// Connect a `CalendarSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @inlinable @discardableResult func connect(signal kind: CalendarSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> Int {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> Int {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(raw: ptr).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

// MARK: Calendar Class: CalendarProtocol extension (methods and fields)
public extension CalendarProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCalendar` instance.
    @inlinable var calendar_ptr: UnsafeMutablePointer<GtkCalendar>! { return ptr?.assumingMemoryBound(to: GtkCalendar.self) }

    /// Remove all visual markers.
    @inlinable func clearMarks() {
        gtk_calendar_clear_marks(calendar_ptr)
    
    }

    /// Returns a `GDateTime` representing the shown
    /// year, month and the selected day, in the local
    /// time zone.
    @inlinable func getDate() -> GLib.DateTimeRef! {
        let rv = GLib.DateTimeRef(gtk_calendar_get_date(calendar_ptr))
        return rv
    }

    /// Returns if the `day` of the `calendar` is already marked.
    @inlinable func getDayIsMarked(day: Int) -> Bool {
        let rv = ((gtk_calendar_get_day_is_marked(calendar_ptr, guint(day))) != 0)
        return rv
    }

    /// Returns whether `self` is currently showing the names
    /// of the week days above the day numbers, i.e. the value
    /// of the `GtkCalendar:show`-day-names property.
    @inlinable func getShowDayNames() -> Bool {
        let rv = ((gtk_calendar_get_show_day_names(calendar_ptr)) != 0)
        return rv
    }

    /// Returns whether `self` is currently showing the heading,
    /// i.e. the value of the `GtkCalendar:show`-heading property.
    @inlinable func getShowHeading() -> Bool {
        let rv = ((gtk_calendar_get_show_heading(calendar_ptr)) != 0)
        return rv
    }

    /// Returns whether `self` is showing week numbers right
    /// now, i.e. the value of the `GtkCalendar:show`-week-numbers
    /// property.
    @inlinable func getShowWeekNumbers() -> Bool {
        let rv = ((gtk_calendar_get_show_week_numbers(calendar_ptr)) != 0)
        return rv
    }

    /// Places a visual marker on a particular day.
    @inlinable func mark(day: Int) {
        gtk_calendar_mark_day(calendar_ptr, guint(day))
    
    }

    /// Will switch to `date`'s year and month and select its day.
    @inlinable func selectDay<DateTimeT: GLib.DateTimeProtocol>(date: DateTimeT) {
        gtk_calendar_select_day(calendar_ptr, date.date_time_ptr)
    
    }

    /// Sets whether the calendar shows day names.
    @inlinable func setShowDayNames(value: Bool) {
        gtk_calendar_set_show_day_names(calendar_ptr, gboolean((value) ? 1 : 0))
    
    }

    /// Sets whether the calendar should show a heading
    /// containing the current year and month as well as
    /// buttons for changing both.
    @inlinable func setShowHeading(value: Bool) {
        gtk_calendar_set_show_heading(calendar_ptr, gboolean((value) ? 1 : 0))
    
    }

    /// Sets whether week numbers are shown in the calendar.
    @inlinable func setShowWeekNumbers(value: Bool) {
        gtk_calendar_set_show_week_numbers(calendar_ptr, gboolean((value) ? 1 : 0))
    
    }

    /// Removes the visual marker from a particular day.
    @inlinable func unmark(day: Int) {
        gtk_calendar_unmark_day(calendar_ptr, guint(day))
    
    }
    /// Returns a `GDateTime` representing the shown
    /// year, month and the selected day, in the local
    /// time zone.
    @inlinable var date: GLib.DateTimeRef! {
        /// Returns a `GDateTime` representing the shown
        /// year, month and the selected day, in the local
        /// time zone.
        get {
            let rv = GLib.DateTimeRef(gtk_calendar_get_date(calendar_ptr))
            return rv
        }
    }

    /// Returns whether `self` is currently showing the names
    /// of the week days above the day numbers, i.e. the value
    /// of the `GtkCalendar:show`-day-names property.
    @inlinable var showDayNames: Bool {
        /// Returns whether `self` is currently showing the names
        /// of the week days above the day numbers, i.e. the value
        /// of the `GtkCalendar:show`-day-names property.
        get {
            let rv = ((gtk_calendar_get_show_day_names(calendar_ptr)) != 0)
            return rv
        }
        /// Sets whether the calendar shows day names.
        nonmutating set {
            gtk_calendar_set_show_day_names(calendar_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns whether `self` is currently showing the heading,
    /// i.e. the value of the `GtkCalendar:show`-heading property.
    @inlinable var showHeading: Bool {
        /// Returns whether `self` is currently showing the heading,
        /// i.e. the value of the `GtkCalendar:show`-heading property.
        get {
            let rv = ((gtk_calendar_get_show_heading(calendar_ptr)) != 0)
            return rv
        }
        /// Sets whether the calendar should show a heading
        /// containing the current year and month as well as
        /// buttons for changing both.
        nonmutating set {
            gtk_calendar_set_show_heading(calendar_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns whether `self` is showing week numbers right
    /// now, i.e. the value of the `GtkCalendar:show`-week-numbers
    /// property.
    @inlinable var showWeekNumbers: Bool {
        /// Returns whether `self` is showing week numbers right
        /// now, i.e. the value of the `GtkCalendar:show`-week-numbers
        /// property.
        get {
            let rv = ((gtk_calendar_get_show_week_numbers(calendar_ptr)) != 0)
            return rv
        }
        /// Sets whether week numbers are shown in the calendar.
        nonmutating set {
            gtk_calendar_set_show_week_numbers(calendar_ptr, gboolean((newValue) ? 1 : 0))
        }
    }


}



// MARK: - CallbackAction Class

/// The `CallbackActionProtocol` protocol exposes the methods and properties of an underlying `GtkCallbackAction` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CallbackAction`.
/// Alternatively, use `CallbackActionRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A `GtkShortcutAction` that invokes a callback.
public protocol CallbackActionProtocol: ShortcutActionProtocol {
        /// Untyped pointer to the underlying `GtkCallbackAction` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCallbackAction` instance.
    var callback_action_ptr: UnsafeMutablePointer<GtkCallbackAction>! { get }

}

/// The `CallbackActionRef` type acts as a lightweight Swift reference to an underlying `GtkCallbackAction` instance.
/// It exposes methods that can operate on this data type through `CallbackActionProtocol` conformance.
/// Use `CallbackActionRef` only as an `unowned` reference to an existing `GtkCallbackAction` instance.
///
/// A `GtkShortcutAction` that invokes a callback.
public struct CallbackActionRef: CallbackActionProtocol {
        /// Untyped pointer to the underlying `GtkCallbackAction` instance.
    /// For type-safe access, use the generated, typed pointer `callback_action_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CallbackActionRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCallbackAction>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCallbackAction>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCallbackAction>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCallbackAction>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CallbackActionProtocol`
    @inlinable init<T: CallbackActionProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `CallbackAction` type acts as a reference-counted owner of an underlying `GtkCallbackAction` instance.
/// It provides the methods that can operate on this data type through `CallbackActionProtocol` conformance.
/// Use `CallbackAction` as a strong reference or owner of a `GtkCallbackAction` instance.
///
/// A `GtkShortcutAction` that invokes a callback.
open class CallbackAction: ShortcutAction, CallbackActionProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CallbackAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCallbackAction>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CallbackAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCallbackAction>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CallbackAction` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CallbackAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CallbackAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCallbackAction>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CallbackAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCallbackAction>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCallbackAction`.
    /// i.e., ownership is transferred to the `CallbackAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCallbackAction>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CallbackActionProtocol`
    /// Will retain `GtkCallbackAction`.
    /// - Parameter other: an instance of a related type that implements `CallbackActionProtocol`
    @inlinable public init<T: CallbackActionProtocol>(callbackAction other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

// MARK: no CallbackAction properties

public enum CallbackActionSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"

}

public extension CallbackActionProtocol {
    /// Connect a `CallbackActionSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @inlinable @discardableResult func connect(signal kind: CallbackActionSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> Int {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> Int {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(raw: ptr).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

// MARK: CallbackAction Class: CallbackActionProtocol extension (methods and fields)
public extension CallbackActionProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCallbackAction` instance.
    @inlinable var callback_action_ptr: UnsafeMutablePointer<GtkCallbackAction>! { return ptr?.assumingMemoryBound(to: GtkCallbackAction.self) }



}



// MARK: - CellArea Class

/// The `CellAreaProtocol` protocol exposes the methods and properties of an underlying `GtkCellArea` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellArea`.
/// Alternatively, use `CellAreaRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// The `GtkCellArea` is an abstract class for `GtkCellLayout` widgets
/// (also referred to as "layouting widgets") to interface with an
/// arbitrary number of `GtkCellRenderers` and interact with the user
/// for a given `GtkTreeModel` row.
/// 
/// The cell area handles events, focus navigation, drawing and
/// size requests and allocations for a given row of data.
/// 
/// Usually users dont have to interact with the `GtkCellArea` directly
/// unless they are implementing a cell-layouting widget themselves.
/// 
/// # Requesting area sizes
/// 
/// As outlined in
/// [GtkWidget’s geometry management section](#geometry-management),
/// GTK uses a height-for-width
/// geometry management system to compute the sizes of widgets and user
/// interfaces. `GtkCellArea` uses the same semantics to calculate the
/// size of an area for an arbitrary number of `GtkTreeModel` rows.
/// 
/// When requesting the size of a cell area one needs to calculate
/// the size for a handful of rows, and this will be done differently by
/// different layouting widgets. For instance a `GtkTreeViewColumn`
/// always lines up the areas from top to bottom while a `GtkIconView`
/// on the other hand might enforce that all areas received the same
/// width and wrap the areas around, requesting height for more cell
/// areas when allocated less width.
/// 
/// It’s also important for areas to maintain some cell
/// alignments with areas rendered for adjacent rows (cells can
/// appear “columnized” inside an area even when the size of
/// cells are different in each row). For this reason the `GtkCellArea`
/// uses a `GtkCellAreaContext` object to store the alignments
/// and sizes along the way (as well as the overall largest minimum
/// and natural size for all the rows which have been calculated
/// with the said context).
/// 
/// The `GtkCellAreaContext` is an opaque object specific to the
/// `GtkCellArea` which created it (see `gtk_cell_area_create_context()`).
/// The owning cell-layouting widget can create as many contexts as
/// it wishes to calculate sizes of rows which should receive the
/// same size in at least one orientation (horizontally or vertically),
/// However, it’s important that the same `GtkCellAreaContext` which
/// was used to request the sizes for a given `GtkTreeModel` row be
/// used when rendering or processing events for that row.
/// 
/// In order to request the width of all the rows at the root level
/// of a `GtkTreeModel` one would do the following:
/// 
/// (C Language Example):
/// ```C
/// GtkTreeIter iter;
/// int         minimum_width;
/// int         natural_width;
/// 
/// valid = gtk_tree_model_get_iter_first (model, &iter);
/// while (valid)
///   {
///     gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
///     gtk_cell_area_get_preferred_width (area, context, widget, NULL, NULL);
/// 
///     valid = gtk_tree_model_iter_next (model, &iter);
///   }
/// gtk_cell_area_context_get_preferred_width (context, &minimum_width, &natural_width);
/// ```
/// 
/// Note that in this example it’s not important to observe the
/// returned minimum and natural width of the area for each row
/// unless the cell-layouting object is actually interested in the
/// widths of individual rows. The overall width is however stored
/// in the accompanying `GtkCellAreaContext` object and can be consulted
/// at any time.
/// 
/// This can be useful since `GtkCellLayout` widgets usually have to
/// support requesting and rendering rows in treemodels with an
/// exceedingly large amount of rows. The `GtkCellLayout` widget in
/// that case would calculate the required width of the rows in an
/// idle or timeout source (see `g_timeout_add()`) and when the widget
/// is requested its actual width in `GtkWidgetClass.measure``()`
/// it can simply consult the width accumulated so far in the
/// `GtkCellAreaContext` object.
/// 
/// A simple example where rows are rendered from top to bottom and
/// take up the full width of the layouting widget would look like:
/// 
/// (C Language Example):
/// ```C
/// static void
/// foo_get_preferred_width (GtkWidget       *widget,
///                          int             *minimum_size,
///                          int             *natural_size)
/// {
///   Foo        *foo  = FOO (widget);
///   FooPrivate *priv = foo->priv;
/// 
///   foo_ensure_at_least_one_handfull_of_rows_have_been_requested (foo);
/// 
///   gtk_cell_area_context_get_preferred_width (priv->context, minimum_size, natural_size);
/// }
/// ```
/// 
/// In the above example the Foo widget has to make sure that some
/// row sizes have been calculated (the amount of rows that Foo judged
/// was appropriate to request space for in a single timeout iteration)
/// before simply returning the amount of space required by the area via
/// the `GtkCellAreaContext`.
/// 
/// Requesting the height for width (or width for height) of an area is
/// a similar task except in this case the `GtkCellAreaContext` does not
/// store the data (actually, it does not know how much space the layouting
/// widget plans to allocate it for every row. It’s up to the layouting
/// widget to render each row of data with the appropriate height and
/// width which was requested by the `GtkCellArea`).
/// 
/// In order to request the height for width of all the rows at the
/// root level of a `GtkTreeModel` one would do the following:
/// 
/// (C Language Example):
/// ```C
/// GtkTreeIter iter;
/// int         minimum_height;
/// int         natural_height;
/// int         full_minimum_height = 0;
/// int         full_natural_height = 0;
/// 
/// valid = gtk_tree_model_get_iter_first (model, &iter);
/// while (valid)
///   {
///     gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
///     gtk_cell_area_get_preferred_height_for_width (area, context, widget,
///                                                   width, &minimum_height, &natural_height);
/// 
///     if (width_is_for_allocation)
///        cache_row_height (&iter, minimum_height, natural_height);
/// 
///     full_minimum_height += minimum_height;
///     full_natural_height += natural_height;
/// 
///     valid = gtk_tree_model_iter_next (model, &iter);
///   }
/// ```
/// 
/// Note that in the above example we would need to cache the heights
/// returned for each row so that we would know what sizes to render the
/// areas for each row. However we would only want to really cache the
/// heights if the request is intended for the layouting widgets real
/// allocation.
/// 
/// In some cases the layouting widget is requested the height for an
/// arbitrary for_width, this is a special case for layouting widgets
/// who need to request size for tens of thousands  of rows. For this
/// case it’s only important that the layouting widget calculate
/// one reasonably sized chunk of rows and return that height
/// synchronously. The reasoning here is that any layouting widget is
/// at least capable of synchronously calculating enough height to fill
/// the screen height (or scrolled window height) in response to a single
/// call to `GtkWidgetClass.measure``()`. Returning
/// a perfect height for width that is larger than the screen area is
/// inconsequential since after the layouting receives an allocation
/// from a scrolled window it simply continues to drive the scrollbar
/// values while more and more height is required for the row heights
/// that are calculated in the background.
/// 
/// # Rendering Areas
/// 
/// Once area sizes have been acquired at least for the rows in the
/// visible area of the layouting widget they can be rendered at
/// `GtkWidgetClass.snapshot``()` time.
/// 
/// A crude example of how to render all the rows at the root level
/// runs as follows:
/// 
/// (C Language Example):
/// ```C
/// GtkAllocation allocation;
/// GdkRectangle  cell_area = { 0, };
/// GtkTreeIter   iter;
/// int           minimum_width;
/// int           natural_width;
/// 
/// gtk_widget_get_allocation (widget, &allocation);
/// cell_area.width = allocation.width;
/// 
/// valid = gtk_tree_model_get_iter_first (model, &iter);
/// while (valid)
///   {
///     cell_area.height = get_cached_height_for_row (&iter);
/// 
///     gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
///     gtk_cell_area_render (area, context, widget, cr,
///                           &cell_area, &cell_area, state_flags, FALSE);
/// 
///     cell_area.y += cell_area.height;
/// 
///     valid = gtk_tree_model_iter_next (model, &iter);
///   }
/// ```
/// 
/// Note that the cached height in this example really depends on how
/// the layouting widget works. The layouting widget might decide to
/// give every row its minimum or natural height or, if the model content
/// is expected to fit inside the layouting widget without scrolling, it
/// would make sense to calculate the allocation for each row at
/// the time the widget is allocated using `gtk_distribute_natural_allocation()`.
/// 
/// # Handling Events and Driving Keyboard Focus
/// 
/// Passing events to the area is as simple as handling events on any
/// normal widget and then passing them to the `gtk_cell_area_event()`
/// API as they come in. Usually `GtkCellArea` is only interested in
/// button events, however some customized derived areas can be implemented
/// who are interested in handling other events. Handling an event can
/// trigger the `GtkCellArea::focus`-changed signal to fire; as well as
/// `GtkCellArea::add`-editable in the case that an editable cell was
/// clicked and needs to start editing. You can call
/// `gtk_cell_area_stop_editing()` at any time to cancel any cell editing
/// that is currently in progress.
/// 
/// The `GtkCellArea` drives keyboard focus from cell to cell in a way
/// similar to `GtkWidget`. For layouting widgets that support giving
/// focus to cells it’s important to remember to pass `GTK_CELL_RENDERER_FOCUSED`
/// to the area functions for the row that has focus and to tell the
/// area to paint the focus at render time.
/// 
/// Layouting widgets that accept focus on cells should implement the
/// `GtkWidgetClass.focus``()` virtual method. The layouting widget is always
/// responsible for knowing where `GtkTreeModel` rows are rendered inside
/// the widget, so at `GtkWidgetClass.focus``()` time the layouting widget
/// should use the `GtkCellArea` methods to navigate focus inside the area
/// and then observe the GtkDirectionType to pass the focus to adjacent
/// rows and areas.
/// 
/// A basic example of how the `GtkWidgetClass.focus``()` virtual method
/// should be implemented:
/// 
/// (C Language Example):
/// ```C
/// static gboolean
/// foo_focus (GtkWidget       *widget,
///            GtkDirectionType direction)
/// {
///   Foo        *foo  = FOO (widget);
///   FooPrivate *priv = foo->priv;
///   int         focus_row;
///   gboolean    have_focus = FALSE;
/// 
///   focus_row = priv->focus_row;
/// 
///   if (!gtk_widget_has_focus (widget))
///     gtk_widget_grab_focus (widget);
/// 
///   valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, priv->focus_row);
///   while (valid)
///     {
///       gtk_cell_area_apply_attributes (priv->area, priv->model, &iter, FALSE, FALSE);
/// 
///       if (gtk_cell_area_focus (priv->area, direction))
///         {
///            priv->focus_row = focus_row;
///            have_focus = TRUE;
///            break;
///         }
///       else
///         {
///           if (direction == GTK_DIR_RIGHT ||
///               direction == GTK_DIR_LEFT)
///             break;
///           else if (direction == GTK_DIR_UP ||
///                    direction == GTK_DIR_TAB_BACKWARD)
///            {
///               if (focus_row == 0)
///                 break;
///               else
///                {
///                   focus_row--;
///                   valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, focus_row);
///                }
///             }
///           else
///             {
///               if (focus_row == last_row)
///                 break;
///               else
///                 {
///                   focus_row++;
///                   valid = gtk_tree_model_iter_next (priv->model, &iter);
///                 }
///             }
///         }
///     }
///     return have_focus;
/// }
/// ```
/// 
/// Note that the layouting widget is responsible for matching the
/// GtkDirectionType values to the way it lays out its cells.
/// 
/// # Cell Properties
/// 
/// The `GtkCellArea` introduces cell properties for `GtkCellRenderers`.
/// This provides some general interfaces for defining the relationship
/// cell areas have with their cells. For instance in a `GtkCellAreaBox`
/// a cell might “expand” and receive extra space when the area is allocated
/// more than its full natural request, or a cell might be configured to “align”
/// with adjacent rows which were requested and rendered with the same
/// `GtkCellAreaContext`.
/// 
/// Use `gtk_cell_area_class_install_cell_property()` to install cell
/// properties for a cell area class and `gtk_cell_area_class_find_cell_property()`
/// or `gtk_cell_area_class_list_cell_properties()` to get information about
/// existing cell properties.
/// 
/// To set the value of a cell property, use `gtk_cell_area_cell_set_property()`,
/// `gtk_cell_area_cell_set()` or `gtk_cell_area_cell_set_valist()`. To obtain
/// the value of a cell property, use `gtk_cell_area_cell_get_property()`,
/// `gtk_cell_area_cell_get()` or `gtk_cell_area_cell_get_valist()`.
public protocol CellAreaProtocol: GLibObject.InitiallyUnownedProtocol, BuildableProtocol, CellLayoutProtocol {
        /// Untyped pointer to the underlying `GtkCellArea` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellArea` instance.
    var cell_area_ptr: UnsafeMutablePointer<GtkCellArea>! { get }

}

/// The `CellAreaRef` type acts as a lightweight Swift reference to an underlying `GtkCellArea` instance.
/// It exposes methods that can operate on this data type through `CellAreaProtocol` conformance.
/// Use `CellAreaRef` only as an `unowned` reference to an existing `GtkCellArea` instance.
///
/// The `GtkCellArea` is an abstract class for `GtkCellLayout` widgets
/// (also referred to as "layouting widgets") to interface with an
/// arbitrary number of `GtkCellRenderers` and interact with the user
/// for a given `GtkTreeModel` row.
/// 
/// The cell area handles events, focus navigation, drawing and
/// size requests and allocations for a given row of data.
/// 
/// Usually users dont have to interact with the `GtkCellArea` directly
/// unless they are implementing a cell-layouting widget themselves.
/// 
/// # Requesting area sizes
/// 
/// As outlined in
/// [GtkWidget’s geometry management section](#geometry-management),
/// GTK uses a height-for-width
/// geometry management system to compute the sizes of widgets and user
/// interfaces. `GtkCellArea` uses the same semantics to calculate the
/// size of an area for an arbitrary number of `GtkTreeModel` rows.
/// 
/// When requesting the size of a cell area one needs to calculate
/// the size for a handful of rows, and this will be done differently by
/// different layouting widgets. For instance a `GtkTreeViewColumn`
/// always lines up the areas from top to bottom while a `GtkIconView`
/// on the other hand might enforce that all areas received the same
/// width and wrap the areas around, requesting height for more cell
/// areas when allocated less width.
/// 
/// It’s also important for areas to maintain some cell
/// alignments with areas rendered for adjacent rows (cells can
/// appear “columnized” inside an area even when the size of
/// cells are different in each row). For this reason the `GtkCellArea`
/// uses a `GtkCellAreaContext` object to store the alignments
/// and sizes along the way (as well as the overall largest minimum
/// and natural size for all the rows which have been calculated
/// with the said context).
/// 
/// The `GtkCellAreaContext` is an opaque object specific to the
/// `GtkCellArea` which created it (see `gtk_cell_area_create_context()`).
/// The owning cell-layouting widget can create as many contexts as
/// it wishes to calculate sizes of rows which should receive the
/// same size in at least one orientation (horizontally or vertically),
/// However, it’s important that the same `GtkCellAreaContext` which
/// was used to request the sizes for a given `GtkTreeModel` row be
/// used when rendering or processing events for that row.
/// 
/// In order to request the width of all the rows at the root level
/// of a `GtkTreeModel` one would do the following:
/// 
/// (C Language Example):
/// ```C
/// GtkTreeIter iter;
/// int         minimum_width;
/// int         natural_width;
/// 
/// valid = gtk_tree_model_get_iter_first (model, &iter);
/// while (valid)
///   {
///     gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
///     gtk_cell_area_get_preferred_width (area, context, widget, NULL, NULL);
/// 
///     valid = gtk_tree_model_iter_next (model, &iter);
///   }
/// gtk_cell_area_context_get_preferred_width (context, &minimum_width, &natural_width);
/// ```
/// 
/// Note that in this example it’s not important to observe the
/// returned minimum and natural width of the area for each row
/// unless the cell-layouting object is actually interested in the
/// widths of individual rows. The overall width is however stored
/// in the accompanying `GtkCellAreaContext` object and can be consulted
/// at any time.
/// 
/// This can be useful since `GtkCellLayout` widgets usually have to
/// support requesting and rendering rows in treemodels with an
/// exceedingly large amount of rows. The `GtkCellLayout` widget in
/// that case would calculate the required width of the rows in an
/// idle or timeout source (see `g_timeout_add()`) and when the widget
/// is requested its actual width in `GtkWidgetClass.measure``()`
/// it can simply consult the width accumulated so far in the
/// `GtkCellAreaContext` object.
/// 
/// A simple example where rows are rendered from top to bottom and
/// take up the full width of the layouting widget would look like:
/// 
/// (C Language Example):
/// ```C
/// static void
/// foo_get_preferred_width (GtkWidget       *widget,
///                          int             *minimum_size,
///                          int             *natural_size)
/// {
///   Foo        *foo  = FOO (widget);
///   FooPrivate *priv = foo->priv;
/// 
///   foo_ensure_at_least_one_handfull_of_rows_have_been_requested (foo);
/// 
///   gtk_cell_area_context_get_preferred_width (priv->context, minimum_size, natural_size);
/// }
/// ```
/// 
/// In the above example the Foo widget has to make sure that some
/// row sizes have been calculated (the amount of rows that Foo judged
/// was appropriate to request space for in a single timeout iteration)
/// before simply returning the amount of space required by the area via
/// the `GtkCellAreaContext`.
/// 
/// Requesting the height for width (or width for height) of an area is
/// a similar task except in this case the `GtkCellAreaContext` does not
/// store the data (actually, it does not know how much space the layouting
/// widget plans to allocate it for every row. It’s up to the layouting
/// widget to render each row of data with the appropriate height and
/// width which was requested by the `GtkCellArea`).
/// 
/// In order to request the height for width of all the rows at the
/// root level of a `GtkTreeModel` one would do the following:
/// 
/// (C Language Example):
/// ```C
/// GtkTreeIter iter;
/// int         minimum_height;
/// int         natural_height;
/// int         full_minimum_height = 0;
/// int         full_natural_height = 0;
/// 
/// valid = gtk_tree_model_get_iter_first (model, &iter);
/// while (valid)
///   {
///     gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
///     gtk_cell_area_get_preferred_height_for_width (area, context, widget,
///                                                   width, &minimum_height, &natural_height);
/// 
///     if (width_is_for_allocation)
///        cache_row_height (&iter, minimum_height, natural_height);
/// 
///     full_minimum_height += minimum_height;
///     full_natural_height += natural_height;
/// 
///     valid = gtk_tree_model_iter_next (model, &iter);
///   }
/// ```
/// 
/// Note that in the above example we would need to cache the heights
/// returned for each row so that we would know what sizes to render the
/// areas for each row. However we would only want to really cache the
/// heights if the request is intended for the layouting widgets real
/// allocation.
/// 
/// In some cases the layouting widget is requested the height for an
/// arbitrary for_width, this is a special case for layouting widgets
/// who need to request size for tens of thousands  of rows. For this
/// case it’s only important that the layouting widget calculate
/// one reasonably sized chunk of rows and return that height
/// synchronously. The reasoning here is that any layouting widget is
/// at least capable of synchronously calculating enough height to fill
/// the screen height (or scrolled window height) in response to a single
/// call to `GtkWidgetClass.measure``()`. Returning
/// a perfect height for width that is larger than the screen area is
/// inconsequential since after the layouting receives an allocation
/// from a scrolled window it simply continues to drive the scrollbar
/// values while more and more height is required for the row heights
/// that are calculated in the background.
/// 
/// # Rendering Areas
/// 
/// Once area sizes have been acquired at least for the rows in the
/// visible area of the layouting widget they can be rendered at
/// `GtkWidgetClass.snapshot``()` time.
/// 
/// A crude example of how to render all the rows at the root level
/// runs as follows:
/// 
/// (C Language Example):
/// ```C
/// GtkAllocation allocation;
/// GdkRectangle  cell_area = { 0, };
/// GtkTreeIter   iter;
/// int           minimum_width;
/// int           natural_width;
/// 
/// gtk_widget_get_allocation (widget, &allocation);
/// cell_area.width = allocation.width;
/// 
/// valid = gtk_tree_model_get_iter_first (model, &iter);
/// while (valid)
///   {
///     cell_area.height = get_cached_height_for_row (&iter);
/// 
///     gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
///     gtk_cell_area_render (area, context, widget, cr,
///                           &cell_area, &cell_area, state_flags, FALSE);
/// 
///     cell_area.y += cell_area.height;
/// 
///     valid = gtk_tree_model_iter_next (model, &iter);
///   }
/// ```
/// 
/// Note that the cached height in this example really depends on how
/// the layouting widget works. The layouting widget might decide to
/// give every row its minimum or natural height or, if the model content
/// is expected to fit inside the layouting widget without scrolling, it
/// would make sense to calculate the allocation for each row at
/// the time the widget is allocated using `gtk_distribute_natural_allocation()`.
/// 
/// # Handling Events and Driving Keyboard Focus
/// 
/// Passing events to the area is as simple as handling events on any
/// normal widget and then passing them to the `gtk_cell_area_event()`
/// API as they come in. Usually `GtkCellArea` is only interested in
/// button events, however some customized derived areas can be implemented
/// who are interested in handling other events. Handling an event can
/// trigger the `GtkCellArea::focus`-changed signal to fire; as well as
/// `GtkCellArea::add`-editable in the case that an editable cell was
/// clicked and needs to start editing. You can call
/// `gtk_cell_area_stop_editing()` at any time to cancel any cell editing
/// that is currently in progress.
/// 
/// The `GtkCellArea` drives keyboard focus from cell to cell in a way
/// similar to `GtkWidget`. For layouting widgets that support giving
/// focus to cells it’s important to remember to pass `GTK_CELL_RENDERER_FOCUSED`
/// to the area functions for the row that has focus and to tell the
/// area to paint the focus at render time.
/// 
/// Layouting widgets that accept focus on cells should implement the
/// `GtkWidgetClass.focus``()` virtual method. The layouting widget is always
/// responsible for knowing where `GtkTreeModel` rows are rendered inside
/// the widget, so at `GtkWidgetClass.focus``()` time the layouting widget
/// should use the `GtkCellArea` methods to navigate focus inside the area
/// and then observe the GtkDirectionType to pass the focus to adjacent
/// rows and areas.
/// 
/// A basic example of how the `GtkWidgetClass.focus``()` virtual method
/// should be implemented:
/// 
/// (C Language Example):
/// ```C
/// static gboolean
/// foo_focus (GtkWidget       *widget,
///            GtkDirectionType direction)
/// {
///   Foo        *foo  = FOO (widget);
///   FooPrivate *priv = foo->priv;
///   int         focus_row;
///   gboolean    have_focus = FALSE;
/// 
///   focus_row = priv->focus_row;
/// 
///   if (!gtk_widget_has_focus (widget))
///     gtk_widget_grab_focus (widget);
/// 
///   valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, priv->focus_row);
///   while (valid)
///     {
///       gtk_cell_area_apply_attributes (priv->area, priv->model, &iter, FALSE, FALSE);
/// 
///       if (gtk_cell_area_focus (priv->area, direction))
///         {
///            priv->focus_row = focus_row;
///            have_focus = TRUE;
///            break;
///         }
///       else
///         {
///           if (direction == GTK_DIR_RIGHT ||
///               direction == GTK_DIR_LEFT)
///             break;
///           else if (direction == GTK_DIR_UP ||
///                    direction == GTK_DIR_TAB_BACKWARD)
///            {
///               if (focus_row == 0)
///                 break;
///               else
///                {
///                   focus_row--;
///                   valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, focus_row);
///                }
///             }
///           else
///             {
///               if (focus_row == last_row)
///                 break;
///               else
///                 {
///                   focus_row++;
///                   valid = gtk_tree_model_iter_next (priv->model, &iter);
///                 }
///             }
///         }
///     }
///     return have_focus;
/// }
/// ```
/// 
/// Note that the layouting widget is responsible for matching the
/// GtkDirectionType values to the way it lays out its cells.
/// 
/// # Cell Properties
/// 
/// The `GtkCellArea` introduces cell properties for `GtkCellRenderers`.
/// This provides some general interfaces for defining the relationship
/// cell areas have with their cells. For instance in a `GtkCellAreaBox`
/// a cell might “expand” and receive extra space when the area is allocated
/// more than its full natural request, or a cell might be configured to “align”
/// with adjacent rows which were requested and rendered with the same
/// `GtkCellAreaContext`.
/// 
/// Use `gtk_cell_area_class_install_cell_property()` to install cell
/// properties for a cell area class and `gtk_cell_area_class_find_cell_property()`
/// or `gtk_cell_area_class_list_cell_properties()` to get information about
/// existing cell properties.
/// 
/// To set the value of a cell property, use `gtk_cell_area_cell_set_property()`,
/// `gtk_cell_area_cell_set()` or `gtk_cell_area_cell_set_valist()`. To obtain
/// the value of a cell property, use `gtk_cell_area_cell_get_property()`,
/// `gtk_cell_area_cell_get()` or `gtk_cell_area_cell_get_valist()`.
public struct CellAreaRef: CellAreaProtocol {
        /// Untyped pointer to the underlying `GtkCellArea` instance.
    /// For type-safe access, use the generated, typed pointer `cell_area_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellAreaRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellArea>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellArea>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellArea>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellArea>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellAreaProtocol`
    @inlinable init<T: CellAreaProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `CellArea` type acts as a reference-counted owner of an underlying `GtkCellArea` instance.
/// It provides the methods that can operate on this data type through `CellAreaProtocol` conformance.
/// Use `CellArea` as a strong reference or owner of a `GtkCellArea` instance.
///
/// The `GtkCellArea` is an abstract class for `GtkCellLayout` widgets
/// (also referred to as "layouting widgets") to interface with an
/// arbitrary number of `GtkCellRenderers` and interact with the user
/// for a given `GtkTreeModel` row.
/// 
/// The cell area handles events, focus navigation, drawing and
/// size requests and allocations for a given row of data.
/// 
/// Usually users dont have to interact with the `GtkCellArea` directly
/// unless they are implementing a cell-layouting widget themselves.
/// 
/// # Requesting area sizes
/// 
/// As outlined in
/// [GtkWidget’s geometry management section](#geometry-management),
/// GTK uses a height-for-width
/// geometry management system to compute the sizes of widgets and user
/// interfaces. `GtkCellArea` uses the same semantics to calculate the
/// size of an area for an arbitrary number of `GtkTreeModel` rows.
/// 
/// When requesting the size of a cell area one needs to calculate
/// the size for a handful of rows, and this will be done differently by
/// different layouting widgets. For instance a `GtkTreeViewColumn`
/// always lines up the areas from top to bottom while a `GtkIconView`
/// on the other hand might enforce that all areas received the same
/// width and wrap the areas around, requesting height for more cell
/// areas when allocated less width.
/// 
/// It’s also important for areas to maintain some cell
/// alignments with areas rendered for adjacent rows (cells can
/// appear “columnized” inside an area even when the size of
/// cells are different in each row). For this reason the `GtkCellArea`
/// uses a `GtkCellAreaContext` object to store the alignments
/// and sizes along the way (as well as the overall largest minimum
/// and natural size for all the rows which have been calculated
/// with the said context).
/// 
/// The `GtkCellAreaContext` is an opaque object specific to the
/// `GtkCellArea` which created it (see `gtk_cell_area_create_context()`).
/// The owning cell-layouting widget can create as many contexts as
/// it wishes to calculate sizes of rows which should receive the
/// same size in at least one orientation (horizontally or vertically),
/// However, it’s important that the same `GtkCellAreaContext` which
/// was used to request the sizes for a given `GtkTreeModel` row be
/// used when rendering or processing events for that row.
/// 
/// In order to request the width of all the rows at the root level
/// of a `GtkTreeModel` one would do the following:
/// 
/// (C Language Example):
/// ```C
/// GtkTreeIter iter;
/// int         minimum_width;
/// int         natural_width;
/// 
/// valid = gtk_tree_model_get_iter_first (model, &iter);
/// while (valid)
///   {
///     gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
///     gtk_cell_area_get_preferred_width (area, context, widget, NULL, NULL);
/// 
///     valid = gtk_tree_model_iter_next (model, &iter);
///   }
/// gtk_cell_area_context_get_preferred_width (context, &minimum_width, &natural_width);
/// ```
/// 
/// Note that in this example it’s not important to observe the
/// returned minimum and natural width of the area for each row
/// unless the cell-layouting object is actually interested in the
/// widths of individual rows. The overall width is however stored
/// in the accompanying `GtkCellAreaContext` object and can be consulted
/// at any time.
/// 
/// This can be useful since `GtkCellLayout` widgets usually have to
/// support requesting and rendering rows in treemodels with an
/// exceedingly large amount of rows. The `GtkCellLayout` widget in
/// that case would calculate the required width of the rows in an
/// idle or timeout source (see `g_timeout_add()`) and when the widget
/// is requested its actual width in `GtkWidgetClass.measure``()`
/// it can simply consult the width accumulated so far in the
/// `GtkCellAreaContext` object.
/// 
/// A simple example where rows are rendered from top to bottom and
/// take up the full width of the layouting widget would look like:
/// 
/// (C Language Example):
/// ```C
/// static void
/// foo_get_preferred_width (GtkWidget       *widget,
///                          int             *minimum_size,
///                          int             *natural_size)
/// {
///   Foo        *foo  = FOO (widget);
///   FooPrivate *priv = foo->priv;
/// 
///   foo_ensure_at_least_one_handfull_of_rows_have_been_requested (foo);
/// 
///   gtk_cell_area_context_get_preferred_width (priv->context, minimum_size, natural_size);
/// }
/// ```
/// 
/// In the above example the Foo widget has to make sure that some
/// row sizes have been calculated (the amount of rows that Foo judged
/// was appropriate to request space for in a single timeout iteration)
/// before simply returning the amount of space required by the area via
/// the `GtkCellAreaContext`.
/// 
/// Requesting the height for width (or width for height) of an area is
/// a similar task except in this case the `GtkCellAreaContext` does not
/// store the data (actually, it does not know how much space the layouting
/// widget plans to allocate it for every row. It’s up to the layouting
/// widget to render each row of data with the appropriate height and
/// width which was requested by the `GtkCellArea`).
/// 
/// In order to request the height for width of all the rows at the
/// root level of a `GtkTreeModel` one would do the following:
/// 
/// (C Language Example):
/// ```C
/// GtkTreeIter iter;
/// int         minimum_height;
/// int         natural_height;
/// int         full_minimum_height = 0;
/// int         full_natural_height = 0;
/// 
/// valid = gtk_tree_model_get_iter_first (model, &iter);
/// while (valid)
///   {
///     gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
///     gtk_cell_area_get_preferred_height_for_width (area, context, widget,
///                                                   width, &minimum_height, &natural_height);
/// 
///     if (width_is_for_allocation)
///        cache_row_height (&iter, minimum_height, natural_height);
/// 
///     full_minimum_height += minimum_height;
///     full_natural_height += natural_height;
/// 
///     valid = gtk_tree_model_iter_next (model, &iter);
///   }
/// ```
/// 
/// Note that in the above example we would need to cache the heights
/// returned for each row so that we would know what sizes to render the
/// areas for each row. However we would only want to really cache the
/// heights if the request is intended for the layouting widgets real
/// allocation.
/// 
/// In some cases the layouting widget is requested the height for an
/// arbitrary for_width, this is a special case for layouting widgets
/// who need to request size for tens of thousands  of rows. For this
/// case it’s only important that the layouting widget calculate
/// one reasonably sized chunk of rows and return that height
/// synchronously. The reasoning here is that any layouting widget is
/// at least capable of synchronously calculating enough height to fill
/// the screen height (or scrolled window height) in response to a single
/// call to `GtkWidgetClass.measure``()`. Returning
/// a perfect height for width that is larger than the screen area is
/// inconsequential since after the layouting receives an allocation
/// from a scrolled window it simply continues to drive the scrollbar
/// values while more and more height is required for the row heights
/// that are calculated in the background.
/// 
/// # Rendering Areas
/// 
/// Once area sizes have been acquired at least for the rows in the
/// visible area of the layouting widget they can be rendered at
/// `GtkWidgetClass.snapshot``()` time.
/// 
/// A crude example of how to render all the rows at the root level
/// runs as follows:
/// 
/// (C Language Example):
/// ```C
/// GtkAllocation allocation;
/// GdkRectangle  cell_area = { 0, };
/// GtkTreeIter   iter;
/// int           minimum_width;
/// int           natural_width;
/// 
/// gtk_widget_get_allocation (widget, &allocation);
/// cell_area.width = allocation.width;
/// 
/// valid = gtk_tree_model_get_iter_first (model, &iter);
/// while (valid)
///   {
///     cell_area.height = get_cached_height_for_row (&iter);
/// 
///     gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
///     gtk_cell_area_render (area, context, widget, cr,
///                           &cell_area, &cell_area, state_flags, FALSE);
/// 
///     cell_area.y += cell_area.height;
/// 
///     valid = gtk_tree_model_iter_next (model, &iter);
///   }
/// ```
/// 
/// Note that the cached height in this example really depends on how
/// the layouting widget works. The layouting widget might decide to
/// give every row its minimum or natural height or, if the model content
/// is expected to fit inside the layouting widget without scrolling, it
/// would make sense to calculate the allocation for each row at
/// the time the widget is allocated using `gtk_distribute_natural_allocation()`.
/// 
/// # Handling Events and Driving Keyboard Focus
/// 
/// Passing events to the area is as simple as handling events on any
/// normal widget and then passing them to the `gtk_cell_area_event()`
/// API as they come in. Usually `GtkCellArea` is only interested in
/// button events, however some customized derived areas can be implemented
/// who are interested in handling other events. Handling an event can
/// trigger the `GtkCellArea::focus`-changed signal to fire; as well as
/// `GtkCellArea::add`-editable in the case that an editable cell was
/// clicked and needs to start editing. You can call
/// `gtk_cell_area_stop_editing()` at any time to cancel any cell editing
/// that is currently in progress.
/// 
/// The `GtkCellArea` drives keyboard focus from cell to cell in a way
/// similar to `GtkWidget`. For layouting widgets that support giving
/// focus to cells it’s important to remember to pass `GTK_CELL_RENDERER_FOCUSED`
/// to the area functions for the row that has focus and to tell the
/// area to paint the focus at render time.
/// 
/// Layouting widgets that accept focus on cells should implement the
/// `GtkWidgetClass.focus``()` virtual method. The layouting widget is always
/// responsible for knowing where `GtkTreeModel` rows are rendered inside
/// the widget, so at `GtkWidgetClass.focus``()` time the layouting widget
/// should use the `GtkCellArea` methods to navigate focus inside the area
/// and then observe the GtkDirectionType to pass the focus to adjacent
/// rows and areas.
/// 
/// A basic example of how the `GtkWidgetClass.focus``()` virtual method
/// should be implemented:
/// 
/// (C Language Example):
/// ```C
/// static gboolean
/// foo_focus (GtkWidget       *widget,
///            GtkDirectionType direction)
/// {
///   Foo        *foo  = FOO (widget);
///   FooPrivate *priv = foo->priv;
///   int         focus_row;
///   gboolean    have_focus = FALSE;
/// 
///   focus_row = priv->focus_row;
/// 
///   if (!gtk_widget_has_focus (widget))
///     gtk_widget_grab_focus (widget);
/// 
///   valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, priv->focus_row);
///   while (valid)
///     {
///       gtk_cell_area_apply_attributes (priv->area, priv->model, &iter, FALSE, FALSE);
/// 
///       if (gtk_cell_area_focus (priv->area, direction))
///         {
///            priv->focus_row = focus_row;
///            have_focus = TRUE;
///            break;
///         }
///       else
///         {
///           if (direction == GTK_DIR_RIGHT ||
///               direction == GTK_DIR_LEFT)
///             break;
///           else if (direction == GTK_DIR_UP ||
///                    direction == GTK_DIR_TAB_BACKWARD)
///            {
///               if (focus_row == 0)
///                 break;
///               else
///                {
///                   focus_row--;
///                   valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, focus_row);
///                }
///             }
///           else
///             {
///               if (focus_row == last_row)
///                 break;
///               else
///                 {
///                   focus_row++;
///                   valid = gtk_tree_model_iter_next (priv->model, &iter);
///                 }
///             }
///         }
///     }
///     return have_focus;
/// }
/// ```
/// 
/// Note that the layouting widget is responsible for matching the
/// GtkDirectionType values to the way it lays out its cells.
/// 
/// # Cell Properties
/// 
/// The `GtkCellArea` introduces cell properties for `GtkCellRenderers`.
/// This provides some general interfaces for defining the relationship
/// cell areas have with their cells. For instance in a `GtkCellAreaBox`
/// a cell might “expand” and receive extra space when the area is allocated
/// more than its full natural request, or a cell might be configured to “align”
/// with adjacent rows which were requested and rendered with the same
/// `GtkCellAreaContext`.
/// 
/// Use `gtk_cell_area_class_install_cell_property()` to install cell
/// properties for a cell area class and `gtk_cell_area_class_find_cell_property()`
/// or `gtk_cell_area_class_list_cell_properties()` to get information about
/// existing cell properties.
/// 
/// To set the value of a cell property, use `gtk_cell_area_cell_set_property()`,
/// `gtk_cell_area_cell_set()` or `gtk_cell_area_cell_set_valist()`. To obtain
/// the value of a cell property, use `gtk_cell_area_cell_get_property()`,
/// `gtk_cell_area_cell_get()` or `gtk_cell_area_cell_get_valist()`.
open class CellArea: GLibObject.InitiallyUnowned, CellAreaProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellArea` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCellArea>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellArea` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCellArea>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellArea` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellArea` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellArea` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCellArea>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellArea` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCellArea>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCellArea`.
    /// i.e., ownership is transferred to the `CellArea` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCellArea>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CellAreaProtocol`
    /// Will retain `GtkCellArea`.
    /// - Parameter other: an instance of a related type that implements `CellAreaProtocol`
    @inlinable public init<T: CellAreaProtocol>(cellArea other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum CellAreaPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    /// The widget currently editing the edited cell
    /// 
    /// This property is read-only and only changes as
    /// a result of a call `gtk_cell_area_activate_cell()`.
    case editWidget = "edit-widget"
    /// The cell in the area that is currently edited
    /// 
    /// This property is read-only and only changes as
    /// a result of a call `gtk_cell_area_activate_cell()`.
    case editedCell = "edited-cell"
    /// The cell in the area that currently has focus
    case focusCell = "focus-cell"
}

public extension CellAreaProtocol {
    /// Bind a `CellAreaPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellAreaPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CellArea property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CellAreaPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CellArea property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CellAreaPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CellAreaSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// Indicates that editing has started on `renderer` and that `editable`
    /// should be added to the owning cell-layouting widget at `cell_area`.
    case addEditable = "add-editable"
    /// This signal is emitted whenever applying attributes to `area` from `model`
    case applyAttributes = "apply-attributes"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// Indicates that focus changed on this `area`. This signal
    /// is emitted either as a result of focus handling or event
    /// handling.
    /// 
    /// It's possible that the signal is emitted even if the
    /// currently focused renderer did not change, this is
    /// because focus may change to the same renderer in the
    /// same cell area for a different row of data.
    case focusChanged = "focus-changed"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// Indicates that editing finished on `renderer` and that `editable`
    /// should be removed from the owning cell-layouting widget.
    case removeEditable = "remove-editable"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    /// The widget currently editing the edited cell
    /// 
    /// This property is read-only and only changes as
    /// a result of a call `gtk_cell_area_activate_cell()`.
    case notifyEditWidget = "notify::edit-widget"
    /// The cell in the area that is currently edited
    /// 
    /// This property is read-only and only changes as
    /// a result of a call `gtk_cell_area_activate_cell()`.
    case notifyEditedCell = "notify::edited-cell"
    /// The cell in the area that currently has focus
    case notifyFocusCell = "notify::focus-cell"
}

public extension CellAreaProtocol {
    /// Connect a `CellAreaSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @inlinable @discardableResult func connect(signal kind: CellAreaSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> Int {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> Int {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(raw: ptr).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

// MARK: CellArea Class: CellAreaProtocol extension (methods and fields)
public extension CellAreaProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellArea` instance.
    @inlinable var cell_area_ptr: UnsafeMutablePointer<GtkCellArea>! { return ptr?.assumingMemoryBound(to: GtkCellArea.self) }

    /// Activates `area`, usually by activating the currently focused
    /// cell, however some subclasses which embed widgets in the area
    /// can also activate a widget if it currently has the focus.
    @inlinable func activate<CellAreaContextT: CellAreaContextProtocol, RectangleT: Gdk.RectangleProtocol, WidgetT: WidgetProtocol>(context: CellAreaContextT, widget: WidgetT, cellArea: RectangleT, flags: CellRendererState, editOnly: Bool) -> Bool {
        let rv = ((gtk_cell_area_activate(cell_area_ptr, context.cell_area_context_ptr, widget.widget_ptr, cellArea.rectangle_ptr, flags.value, gboolean((editOnly) ? 1 : 0))) != 0)
        return rv
    }

    /// This is used by `GtkCellArea` subclasses when handling events
    /// to activate cells, the base `GtkCellArea` class activates cells
    /// for keyboard events for free in its own `GtkCellArea->activate()`
    /// implementation.
    @inlinable func activateCell<CellRendererT: CellRendererProtocol, EventT: Gdk.EventProtocol, RectangleT: Gdk.RectangleProtocol, WidgetT: WidgetProtocol>(widget: WidgetT, renderer: CellRendererT, event: EventT, cellArea: RectangleT, flags: CellRendererState) -> Bool {
        let rv = ((gtk_cell_area_activate_cell(cell_area_ptr, widget.widget_ptr, renderer.cell_renderer_ptr, event.event_ptr, cellArea.rectangle_ptr, flags.value)) != 0)
        return rv
    }

    /// Adds `renderer` to `area` with the default child cell properties.
    @inlinable func add<CellRendererT: CellRendererProtocol>(renderer: CellRendererT) {
        gtk_cell_area_add(cell_area_ptr, renderer.cell_renderer_ptr)
    
    }

    /// Adds `sibling` to `renderer`’s focusable area, focus will be drawn
    /// around `renderer` and all of its siblings if `renderer` can
    /// focus for a given row.
    /// 
    /// Events handled by focus siblings can also activate the given
    /// focusable `renderer`.
    @inlinable func addFocusSibling<CellRendererT: CellRendererProtocol>(renderer: CellRendererT, sibling: CellRendererT) {
        gtk_cell_area_add_focus_sibling(cell_area_ptr, renderer.cell_renderer_ptr, sibling.cell_renderer_ptr)
    
    }


    // *** addWithProperties() is not available because it has a varargs (...) parameter!


    /// Applies any connected attributes to the renderers in
    /// `area` by pulling the values from `tree_model`.
    @inlinable func applyAttributes<TreeIterT: TreeIterProtocol, TreeModelT: TreeModelProtocol>(treeModel: TreeModelT, iter: TreeIterT, isExpander: Bool, isExpanded: Bool) {
        gtk_cell_area_apply_attributes(cell_area_ptr, treeModel.tree_model_ptr, iter.tree_iter_ptr, gboolean((isExpander) ? 1 : 0), gboolean((isExpanded) ? 1 : 0))
    
    }

    /// Connects an `attribute` to apply values from `column` for the
    /// `GtkTreeModel` in use.
    @inlinable func attributeConnect<CellRendererT: CellRendererProtocol>(renderer: CellRendererT, attribute: UnsafePointer<CChar>!, column: Int) {
        gtk_cell_area_attribute_connect(cell_area_ptr, renderer.cell_renderer_ptr, attribute, gint(column))
    
    }

    /// Disconnects `attribute` for the `renderer` in `area` so that
    /// attribute will no longer be updated with values from the
    /// model.
    @inlinable func attributeDisconnect<CellRendererT: CellRendererProtocol>(renderer: CellRendererT, attribute: UnsafePointer<CChar>!) {
        gtk_cell_area_attribute_disconnect(cell_area_ptr, renderer.cell_renderer_ptr, attribute)
    
    }

    /// Returns the model column that an attribute has been mapped to,
    /// or -1 if the attribute is not mapped.
    @inlinable func attributeGetColumn<CellRendererT: CellRendererProtocol>(renderer: CellRendererT, attribute: UnsafePointer<CChar>!) -> Int {
        let rv = Int(gtk_cell_area_attribute_get_column(cell_area_ptr, renderer.cell_renderer_ptr, attribute))
        return rv
    }


    // *** cellGet() is not available because it has a varargs (...) parameter!


    /// Gets the value of a cell property for `renderer` in `area`.
    @inlinable func cellGetProperty<CellRendererT: CellRendererProtocol, ValueT: GLibObject.ValueProtocol>(renderer: CellRendererT, propertyName: UnsafePointer<CChar>!, value: ValueT) {
        gtk_cell_area_cell_get_property(cell_area_ptr, renderer.cell_renderer_ptr, propertyName, value.value_ptr)
    
    }

    /// Gets the values of one or more cell properties for `renderer` in `area`.
    @inlinable func cellGetValist<CellRendererT: CellRendererProtocol>(renderer: CellRendererT, firstPropertyName: UnsafePointer<CChar>!, varArgs: CVaListPointer) {
        gtk_cell_area_cell_get_valist(cell_area_ptr, renderer.cell_renderer_ptr, firstPropertyName, varArgs)
    
    }


    // *** cellSet() is not available because it has a varargs (...) parameter!


    /// Sets a cell property for `renderer` in `area`.
    @inlinable func cellSetProperty<CellRendererT: CellRendererProtocol, ValueT: GLibObject.ValueProtocol>(renderer: CellRendererT, propertyName: UnsafePointer<CChar>!, value: ValueT) {
        gtk_cell_area_cell_set_property(cell_area_ptr, renderer.cell_renderer_ptr, propertyName, value.value_ptr)
    
    }

    /// Sets one or more cell properties for `renderer` in `area`.
    @inlinable func cellSetValist<CellRendererT: CellRendererProtocol>(renderer: CellRendererT, firstPropertyName: UnsafePointer<CChar>!, varArgs: CVaListPointer) {
        gtk_cell_area_cell_set_valist(cell_area_ptr, renderer.cell_renderer_ptr, firstPropertyName, varArgs)
    
    }

    /// This is sometimes needed for cases where rows need to share
    /// alignments in one orientation but may be separately grouped
    /// in the opposing orientation.
    /// 
    /// For instance, `GtkIconView` creates all icons (rows) to have
    /// the same width and the cells theirin to have the same
    /// horizontal alignments. However each row of icons may have
    /// a separate collective height. `GtkIconView` uses this to
    /// request the heights of each row based on a context which
    /// was already used to request all the row widths that are
    /// to be displayed.
    @inlinable func copy<CellAreaContextT: CellAreaContextProtocol>(context: CellAreaContextT) -> CellAreaContextRef! {
        let rv = CellAreaContextRef(gconstpointer: gconstpointer(gtk_cell_area_copy_context(cell_area_ptr, context.cell_area_context_ptr)))
        return rv
    }

    /// Creates a `GtkCellAreaContext` to be used with `area` for
    /// all purposes. `GtkCellAreaContext` stores geometry information
    /// for rows for which it was operated on, it is important to use
    /// the same context for the same row of data at all times (i.e.
    /// one should render and handle events with the same `GtkCellAreaContext`
    /// which was used to request the size of those rows of data).
    @inlinable func createContext() -> CellAreaContextRef! {
        let rv = CellAreaContextRef(gconstpointer: gconstpointer(gtk_cell_area_create_context(cell_area_ptr)))
        return rv
    }

    /// Delegates event handling to a `GtkCellArea`.
    @inlinable func event<CellAreaContextT: CellAreaContextProtocol, EventT: Gdk.EventProtocol, RectangleT: Gdk.RectangleProtocol, WidgetT: WidgetProtocol>(context: CellAreaContextT, widget: WidgetT, event: EventT, cellArea: RectangleT, flags: CellRendererState) -> Int {
        let rv = Int(gtk_cell_area_event(cell_area_ptr, context.cell_area_context_ptr, widget.widget_ptr, event.event_ptr, cellArea.rectangle_ptr, flags.value))
        return rv
    }

    /// This should be called by the `area`’s owning layout widget
    /// when focus is to be passed to `area`, or moved within `area`
    /// for a given `direction` and row data.
    /// 
    /// Implementing `GtkCellArea` classes should implement this
    /// method to receive and navigate focus in its own way particular
    /// to how it lays out cells.
    @inlinable func focus(direction: GtkDirectionType) -> Bool {
        let rv = ((gtk_cell_area_focus(cell_area_ptr, direction)) != 0)
        return rv
    }

    /// Calls `callback` for every `GtkCellRenderer` in `area`.
    @inlinable func foreach(callback: GtkCellCallback?, callbackData: gpointer! = nil) {
        gtk_cell_area_foreach(cell_area_ptr, callback, callbackData)
    
    }

    /// Calls `callback` for every `GtkCellRenderer` in `area` with the
    /// allocated rectangle inside `cell_area`.
    @inlinable func foreachAlloc<CellAreaContextT: CellAreaContextProtocol, RectangleT: Gdk.RectangleProtocol, WidgetT: WidgetProtocol>(context: CellAreaContextT, widget: WidgetT, cellArea: RectangleT, backgroundArea: RectangleT, callback: GtkCellAllocCallback?, callbackData: gpointer! = nil) {
        gtk_cell_area_foreach_alloc(cell_area_ptr, context.cell_area_context_ptr, widget.widget_ptr, cellArea.rectangle_ptr, backgroundArea.rectangle_ptr, callback, callbackData)
    
    }

    /// Derives the allocation of `renderer` inside `area` if `area`
    /// were to be renderered in `cell_area`.
    @inlinable func getCellAllocation<CellAreaContextT: CellAreaContextProtocol, CellRendererT: CellRendererProtocol, RectangleT: Gdk.RectangleProtocol, WidgetT: WidgetProtocol>(context: CellAreaContextT, widget: WidgetT, renderer: CellRendererT, cellArea: RectangleT, allocation: RectangleT) {
        gtk_cell_area_get_cell_allocation(cell_area_ptr, context.cell_area_context_ptr, widget.widget_ptr, renderer.cell_renderer_ptr, cellArea.rectangle_ptr, allocation.rectangle_ptr)
    
    }

    /// Gets the `GtkCellRenderer` at `x` and `y` coordinates inside `area` and optionally
    /// returns the full cell allocation for it inside `cell_area`.
    @inlinable func getCellAtPosition<CellAreaContextT: CellAreaContextProtocol, RectangleT: Gdk.RectangleProtocol, WidgetT: WidgetProtocol>(context: CellAreaContextT, widget: WidgetT, cellArea: RectangleT, x: Int, y: Int, allocArea: RectangleT?) -> CellRendererRef! {
        let rv = CellRendererRef(gconstpointer: gconstpointer(gtk_cell_area_get_cell_at_position(cell_area_ptr, context.cell_area_context_ptr, widget.widget_ptr, cellArea.rectangle_ptr, gint(x), gint(y), allocArea?.rectangle_ptr)))
        return rv
    }

    /// Gets the current `GtkTreePath` string for the currently
    /// applied `GtkTreeIter`, this is implicitly updated when
    /// `gtk_cell_area_apply_attributes()` is called and can be
    /// used to interact with renderers from `GtkCellArea`
    /// subclasses.
    @inlinable func getCurrentPathString() -> String! {
        let rv = gtk_cell_area_get_current_path_string(cell_area_ptr).map({ String(cString: $0) })
        return rv
    }

    /// Gets the `GtkCellEditable` widget currently used
    /// to edit the currently edited cell.
    @inlinable func getEditWidget() -> CellEditableRef! {
        let rv = CellEditableRef(gconstpointer: gconstpointer(gtk_cell_area_get_edit_widget(cell_area_ptr)))
        return rv
    }

    /// Gets the `GtkCellRenderer` in `area` that is currently
    /// being edited.
    @inlinable func getEditedCell() -> CellRendererRef! {
        let rv = CellRendererRef(gconstpointer: gconstpointer(gtk_cell_area_get_edited_cell(cell_area_ptr)))
        return rv
    }

    /// Retrieves the currently focused cell for `area`
    @inlinable func getFocusCell() -> CellRendererRef! {
        let rv = CellRendererRef(gconstpointer: gconstpointer(gtk_cell_area_get_focus_cell(cell_area_ptr)))
        return rv
    }

    /// Gets the `GtkCellRenderer` which is expected to be focusable
    /// for which `renderer` is, or may be a sibling.
    /// 
    /// This is handy for `GtkCellArea` subclasses when handling events,
    /// after determining the renderer at the event location it can
    /// then chose to activate the focus cell for which the event
    /// cell may have been a sibling.
    @inlinable func getFocusFromSibling<CellRendererT: CellRendererProtocol>(renderer: CellRendererT) -> CellRendererRef! {
        let rv = CellRendererRef(gconstpointer: gconstpointer(gtk_cell_area_get_focus_from_sibling(cell_area_ptr, renderer.cell_renderer_ptr)))
        return rv
    }

    /// Gets the focus sibling cell renderers for `renderer`.
    @inlinable func getFocusSiblings<CellRendererT: CellRendererProtocol>(renderer: CellRendererT) -> GLib.ListRef! {
        let rv = GLib.ListRef(gtk_cell_area_get_focus_siblings(cell_area_ptr, renderer.cell_renderer_ptr))
        return rv
    }

    /// Retrieves a cell area’s initial minimum and natural height.
    /// 
    /// `area` will store some geometrical information in `context` along the way;
    /// when requesting sizes over an arbitrary number of rows, it’s not important
    /// to check the `minimum_height` and `natural_height` of this call but rather to
    /// consult `gtk_cell_area_context_get_preferred_height()` after a series of
    /// requests.
    @inlinable func getPreferredHeight<CellAreaContextT: CellAreaContextProtocol, WidgetT: WidgetProtocol>(context: CellAreaContextT, widget: WidgetT, minimumHeight: UnsafeMutablePointer<gint>! = nil, naturalHeight: UnsafeMutablePointer<gint>! = nil) {
        gtk_cell_area_get_preferred_height(cell_area_ptr, context.cell_area_context_ptr, widget.widget_ptr, minimumHeight, naturalHeight)
    
    }

    /// Retrieves a cell area’s minimum and natural height if it would be given
    /// the specified `width`.
    /// 
    /// `area` stores some geometrical information in `context` along the way
    /// while calling `gtk_cell_area_get_preferred_width()`. It’s important to
    /// perform a series of `gtk_cell_area_get_preferred_width()` requests with
    /// `context` first and then call `gtk_cell_area_get_preferred_height_for_width()`
    /// on each cell area individually to get the height for width of each
    /// fully requested row.
    /// 
    /// If at some point, the width of a single row changes, it should be
    /// requested with `gtk_cell_area_get_preferred_width()` again and then
    /// the full width of the requested rows checked again with
    /// `gtk_cell_area_context_get_preferred_width()`.
    @inlinable func getPreferredHeightForWidth<CellAreaContextT: CellAreaContextProtocol, WidgetT: WidgetProtocol>(context: CellAreaContextT, widget: WidgetT, width: Int, minimumHeight: UnsafeMutablePointer<gint>! = nil, naturalHeight: UnsafeMutablePointer<gint>! = nil) {
        gtk_cell_area_get_preferred_height_for_width(cell_area_ptr, context.cell_area_context_ptr, widget.widget_ptr, gint(width), minimumHeight, naturalHeight)
    
    }

    /// Retrieves a cell area’s initial minimum and natural width.
    /// 
    /// `area` will store some geometrical information in `context` along the way;
    /// when requesting sizes over an arbitrary number of rows, it’s not important
    /// to check the `minimum_width` and `natural_width` of this call but rather to
    /// consult `gtk_cell_area_context_get_preferred_width()` after a series of
    /// requests.
    @inlinable func getPreferredWidth<CellAreaContextT: CellAreaContextProtocol, WidgetT: WidgetProtocol>(context: CellAreaContextT, widget: WidgetT, minimumWidth: UnsafeMutablePointer<gint>! = nil, naturalWidth: UnsafeMutablePointer<gint>! = nil) {
        gtk_cell_area_get_preferred_width(cell_area_ptr, context.cell_area_context_ptr, widget.widget_ptr, minimumWidth, naturalWidth)
    
    }

    /// Retrieves a cell area’s minimum and natural width if it would be given
    /// the specified `height`.
    /// 
    /// `area` stores some geometrical information in `context` along the way
    /// while calling `gtk_cell_area_get_preferred_height()`. It’s important to
    /// perform a series of `gtk_cell_area_get_preferred_height()` requests with
    /// `context` first and then call `gtk_cell_area_get_preferred_width_for_height()`
    /// on each cell area individually to get the height for width of each
    /// fully requested row.
    /// 
    /// If at some point, the height of a single row changes, it should be
    /// requested with `gtk_cell_area_get_preferred_height()` again and then
    /// the full height of the requested rows checked again with
    /// `gtk_cell_area_context_get_preferred_height()`.
    @inlinable func getPreferredWidthForHeight<CellAreaContextT: CellAreaContextProtocol, WidgetT: WidgetProtocol>(context: CellAreaContextT, widget: WidgetT, height: Int, minimumWidth: UnsafeMutablePointer<gint>! = nil, naturalWidth: UnsafeMutablePointer<gint>! = nil) {
        gtk_cell_area_get_preferred_width_for_height(cell_area_ptr, context.cell_area_context_ptr, widget.widget_ptr, gint(height), minimumWidth, naturalWidth)
    
    }

    /// Gets whether the area prefers a height-for-width layout
    /// or a width-for-height layout.
    @inlinable func getRequestMode() -> GtkSizeRequestMode {
        let rv = gtk_cell_area_get_request_mode(cell_area_ptr)
        return rv
    }

    /// Checks if `area` contains `renderer`.
    @inlinable func has<CellRendererT: CellRendererProtocol>(renderer: CellRendererT) -> Bool {
        let rv = ((gtk_cell_area_has_renderer(cell_area_ptr, renderer.cell_renderer_ptr)) != 0)
        return rv
    }

    /// This is a convenience function for `GtkCellArea` implementations
    /// to get the inner area where a given `GtkCellRenderer` will be
    /// rendered. It removes any padding previously added by `gtk_cell_area_request_renderer()`.
    @inlinable func innerCellArea<RectangleT: Gdk.RectangleProtocol, WidgetT: WidgetProtocol>(widget: WidgetT, cellArea: RectangleT, innerArea: RectangleT) {
        gtk_cell_area_inner_cell_area(cell_area_ptr, widget.widget_ptr, cellArea.rectangle_ptr, innerArea.rectangle_ptr)
    
    }

    /// Returns whether `sibling` is one of `renderer`’s focus siblings
    /// (see `gtk_cell_area_add_focus_sibling()`).
    @inlinable func isFocusSibling<CellRendererT: CellRendererProtocol>(renderer: CellRendererT, sibling: CellRendererT) -> Bool {
        let rv = ((gtk_cell_area_is_focus_sibling(cell_area_ptr, renderer.cell_renderer_ptr, sibling.cell_renderer_ptr)) != 0)
        return rv
    }

    /// Removes `renderer` from `area`.
    @inlinable func remove<CellRendererT: CellRendererProtocol>(renderer: CellRendererT) {
        gtk_cell_area_remove(cell_area_ptr, renderer.cell_renderer_ptr)
    
    }

    /// Removes `sibling` from `renderer`’s focus sibling list
    /// (see `gtk_cell_area_add_focus_sibling()`).
    @inlinable func removeFocusSibling<CellRendererT: CellRendererProtocol>(renderer: CellRendererT, sibling: CellRendererT) {
        gtk_cell_area_remove_focus_sibling(cell_area_ptr, renderer.cell_renderer_ptr, sibling.cell_renderer_ptr)
    
    }

    /// This is a convenience function for `GtkCellArea` implementations
    /// to request size for cell renderers. It’s important to use this
    /// function to request size and then use `gtk_cell_area_inner_cell_area()`
    /// at render and event time since this function will add padding
    /// around the cell for focus painting.
    @inlinable func request<CellRendererT: CellRendererProtocol, WidgetT: WidgetProtocol>(renderer: CellRendererT, orientation: GtkOrientation, widget: WidgetT, `for` size: Int, minimumSize: UnsafeMutablePointer<gint>! = nil, naturalSize: UnsafeMutablePointer<gint>! = nil) {
        gtk_cell_area_request_renderer(cell_area_ptr, renderer.cell_renderer_ptr, orientation, widget.widget_ptr, gint(size), minimumSize, naturalSize)
    
    }

    /// Explicitly sets the currently focused cell to `renderer`.
    /// 
    /// This is generally called by implementations of
    /// `GtkCellAreaClass.focus``()` or `GtkCellAreaClass.event``()`,
    /// however it can also be used to implement functions such
    /// as `gtk_tree_view_set_cursor_on_cell()`.
    @inlinable func setFocusCell<CellRendererT: CellRendererProtocol>(renderer: CellRendererT) {
        gtk_cell_area_set_focus_cell(cell_area_ptr, renderer.cell_renderer_ptr)
    
    }

    /// Snapshots `area`’s cells according to `area`’s layout onto at
    /// the given coordinates.
    @inlinable func snapshot<CellAreaContextT: CellAreaContextProtocol, RectangleT: Gdk.RectangleProtocol, SnapshotT: SnapshotProtocol, WidgetT: WidgetProtocol>(context: CellAreaContextT, widget: WidgetT, snapshot: SnapshotT, backgroundArea: RectangleT, cellArea: RectangleT, flags: CellRendererState, paintFocus: Bool) {
        gtk_cell_area_snapshot(cell_area_ptr, context.cell_area_context_ptr, widget.widget_ptr, snapshot.snapshot_ptr, backgroundArea.rectangle_ptr, cellArea.rectangle_ptr, flags.value, gboolean((paintFocus) ? 1 : 0))
    
    }

    /// Explicitly stops the editing of the currently edited cell.
    /// 
    /// If `canceled` is `true`, the currently edited cell renderer
    /// will emit the `editing`-canceled signal, otherwise the
    /// the `editing`-done signal will be emitted on the current
    /// edit widget.
    /// 
    /// See `gtk_cell_area_get_edited_cell()` and `gtk_cell_area_get_edit_widget()`.
    @inlinable func stopEditing(canceled: Bool) {
        gtk_cell_area_stop_editing(cell_area_ptr, gboolean((canceled) ? 1 : 0))
    
    }
    /// Gets the current `GtkTreePath` string for the currently
    /// applied `GtkTreeIter`, this is implicitly updated when
    /// `gtk_cell_area_apply_attributes()` is called and can be
    /// used to interact with renderers from `GtkCellArea`
    /// subclasses.
    @inlinable var currentPathString: String! {
        /// Gets the current `GtkTreePath` string for the currently
        /// applied `GtkTreeIter`, this is implicitly updated when
        /// `gtk_cell_area_apply_attributes()` is called and can be
        /// used to interact with renderers from `GtkCellArea`
        /// subclasses.
        get {
            let rv = gtk_cell_area_get_current_path_string(cell_area_ptr).map({ String(cString: $0) })
            return rv
        }
    }

    /// Gets the `GtkCellEditable` widget currently used
    /// to edit the currently edited cell.
    @inlinable var editWidget: CellEditableRef! {
        /// Gets the `GtkCellEditable` widget currently used
        /// to edit the currently edited cell.
        get {
            let rv = CellEditableRef(gconstpointer: gconstpointer(gtk_cell_area_get_edit_widget(cell_area_ptr)))
            return rv
        }
    }

    /// Gets the `GtkCellRenderer` in `area` that is currently
    /// being edited.
    @inlinable var editedCell: CellRendererRef! {
        /// Gets the `GtkCellRenderer` in `area` that is currently
        /// being edited.
        get {
            let rv = CellRendererRef(gconstpointer: gconstpointer(gtk_cell_area_get_edited_cell(cell_area_ptr)))
            return rv
        }
    }

    /// Retrieves the currently focused cell for `area`
    @inlinable var focusCell: CellRendererRef! {
        /// Retrieves the currently focused cell for `area`
        get {
            let rv = CellRendererRef(gconstpointer: gconstpointer(gtk_cell_area_get_focus_cell(cell_area_ptr)))
            return rv
        }
        /// Explicitly sets the currently focused cell to `renderer`.
        /// 
        /// This is generally called by implementations of
        /// `GtkCellAreaClass.focus``()` or `GtkCellAreaClass.event``()`,
        /// however it can also be used to implement functions such
        /// as `gtk_tree_view_set_cursor_on_cell()`.
        nonmutating set {
            gtk_cell_area_set_focus_cell(cell_area_ptr, UnsafeMutablePointer<GtkCellRenderer>(newValue?.cell_renderer_ptr))
        }
    }

    /// Returns whether the area can do anything when activated,
    /// after applying new attributes to `area`.
    @inlinable var isActivatable: Bool {
        /// Returns whether the area can do anything when activated,
        /// after applying new attributes to `area`.
        get {
            let rv = ((gtk_cell_area_is_activatable(cell_area_ptr)) != 0)
            return rv
        }
    }

    /// Gets whether the area prefers a height-for-width layout
    /// or a width-for-height layout.
    @inlinable var requestMode: GtkSizeRequestMode {
        /// Gets whether the area prefers a height-for-width layout
        /// or a width-for-height layout.
        get {
            let rv = gtk_cell_area_get_request_mode(cell_area_ptr)
            return rv
        }
    }

    // var parentInstance is unavailable because parent_instance is private

}



// MARK: - CellAreaBox Class

/// The `CellAreaBoxProtocol` protocol exposes the methods and properties of an underlying `GtkCellAreaBox` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellAreaBox`.
/// Alternatively, use `CellAreaBoxRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// The `GtkCellAreaBox` renders cell renderers into a row or a column
/// depending on its `GtkOrientation`.
/// 
/// GtkCellAreaBox uses a notion of packing. Packing
/// refers to adding cell renderers with reference to a particular position
/// in a `GtkCellAreaBox`. There are two reference positions: the
/// start and the end of the box.
/// When the `GtkCellAreaBox` is oriented in the `GTK_ORIENTATION_VERTICAL`
/// orientation, the start is defined as the top of the box and the end is
/// defined as the bottom. In the `GTK_ORIENTATION_HORIZONTAL` orientation
/// start is defined as the left side and the end is defined as the right
/// side.
/// 
/// Alignments of `GtkCellRenderers` rendered in adjacent rows can be
/// configured by configuring the `GtkCellAreaBox` align child cell property
/// with `gtk_cell_area_cell_set_property()` or by specifying the "align"
/// argument to `gtk_cell_area_box_pack_start()` and `gtk_cell_area_box_pack_end()`.
public protocol CellAreaBoxProtocol: CellAreaProtocol, OrientableProtocol {
        /// Untyped pointer to the underlying `GtkCellAreaBox` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellAreaBox` instance.
    var cell_area_box_ptr: UnsafeMutablePointer<GtkCellAreaBox>! { get }

}

/// The `CellAreaBoxRef` type acts as a lightweight Swift reference to an underlying `GtkCellAreaBox` instance.
/// It exposes methods that can operate on this data type through `CellAreaBoxProtocol` conformance.
/// Use `CellAreaBoxRef` only as an `unowned` reference to an existing `GtkCellAreaBox` instance.
///
/// The `GtkCellAreaBox` renders cell renderers into a row or a column
/// depending on its `GtkOrientation`.
/// 
/// GtkCellAreaBox uses a notion of packing. Packing
/// refers to adding cell renderers with reference to a particular position
/// in a `GtkCellAreaBox`. There are two reference positions: the
/// start and the end of the box.
/// When the `GtkCellAreaBox` is oriented in the `GTK_ORIENTATION_VERTICAL`
/// orientation, the start is defined as the top of the box and the end is
/// defined as the bottom. In the `GTK_ORIENTATION_HORIZONTAL` orientation
/// start is defined as the left side and the end is defined as the right
/// side.
/// 
/// Alignments of `GtkCellRenderers` rendered in adjacent rows can be
/// configured by configuring the `GtkCellAreaBox` align child cell property
/// with `gtk_cell_area_cell_set_property()` or by specifying the "align"
/// argument to `gtk_cell_area_box_pack_start()` and `gtk_cell_area_box_pack_end()`.
public struct CellAreaBoxRef: CellAreaBoxProtocol {
        /// Untyped pointer to the underlying `GtkCellAreaBox` instance.
    /// For type-safe access, use the generated, typed pointer `cell_area_box_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellAreaBoxRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellAreaBox>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellAreaBox>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellAreaBox>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellAreaBox>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellAreaBoxProtocol`
    @inlinable init<T: CellAreaBoxProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCellAreaBox`.
    @inlinable init() {
        let rv = gtk_cell_area_box_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `CellAreaBox` type acts as a reference-counted owner of an underlying `GtkCellAreaBox` instance.
/// It provides the methods that can operate on this data type through `CellAreaBoxProtocol` conformance.
/// Use `CellAreaBox` as a strong reference or owner of a `GtkCellAreaBox` instance.
///
/// The `GtkCellAreaBox` renders cell renderers into a row or a column
/// depending on its `GtkOrientation`.
/// 
/// GtkCellAreaBox uses a notion of packing. Packing
/// refers to adding cell renderers with reference to a particular position
/// in a `GtkCellAreaBox`. There are two reference positions: the
/// start and the end of the box.
/// When the `GtkCellAreaBox` is oriented in the `GTK_ORIENTATION_VERTICAL`
/// orientation, the start is defined as the top of the box and the end is
/// defined as the bottom. In the `GTK_ORIENTATION_HORIZONTAL` orientation
/// start is defined as the left side and the end is defined as the right
/// side.
/// 
/// Alignments of `GtkCellRenderers` rendered in adjacent rows can be
/// configured by configuring the `GtkCellAreaBox` align child cell property
/// with `gtk_cell_area_cell_set_property()` or by specifying the "align"
/// argument to `gtk_cell_area_box_pack_start()` and `gtk_cell_area_box_pack_end()`.
open class CellAreaBox: CellArea, CellAreaBoxProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellAreaBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCellAreaBox>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellAreaBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCellAreaBox>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellAreaBox` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellAreaBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellAreaBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCellAreaBox>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellAreaBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCellAreaBox>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCellAreaBox`.
    /// i.e., ownership is transferred to the `CellAreaBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCellAreaBox>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CellAreaBoxProtocol`
    /// Will retain `GtkCellAreaBox`.
    /// - Parameter other: an instance of a related type that implements `CellAreaBoxProtocol`
    @inlinable public init<T: CellAreaBoxProtocol>(cellAreaBox other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkCellAreaBox`.
    @inlinable public init() {
        let rv = gtk_cell_area_box_new()
        super.init(gpointer: gpointer(rv))
    }


}

public enum CellAreaBoxPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    /// The widget currently editing the edited cell
    /// 
    /// This property is read-only and only changes as
    /// a result of a call `gtk_cell_area_activate_cell()`.
    case editWidget = "edit-widget"
    /// The cell in the area that is currently edited
    /// 
    /// This property is read-only and only changes as
    /// a result of a call `gtk_cell_area_activate_cell()`.
    case editedCell = "edited-cell"
    /// The cell in the area that currently has focus
    case focusCell = "focus-cell"
    /// The amount of space to reserve between cells.
    case spacing = "spacing"
}

public extension CellAreaBoxProtocol {
    /// Bind a `CellAreaBoxPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellAreaBoxPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CellAreaBox property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CellAreaBoxPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CellAreaBox property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CellAreaBoxPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CellAreaBoxSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// Indicates that editing has started on `renderer` and that `editable`
    /// should be added to the owning cell-layouting widget at `cell_area`.
    case addEditable = "add-editable"
    /// This signal is emitted whenever applying attributes to `area` from `model`
    case applyAttributes = "apply-attributes"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// Indicates that focus changed on this `area`. This signal
    /// is emitted either as a result of focus handling or event
    /// handling.
    /// 
    /// It's possible that the signal is emitted even if the
    /// currently focused renderer did not change, this is
    /// because focus may change to the same renderer in the
    /// same cell area for a different row of data.
    case focusChanged = "focus-changed"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// Indicates that editing finished on `renderer` and that `editable`
    /// should be removed from the owning cell-layouting widget.
    case removeEditable = "remove-editable"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    /// The widget currently editing the edited cell
    /// 
    /// This property is read-only and only changes as
    /// a result of a call `gtk_cell_area_activate_cell()`.
    case notifyEditWidget = "notify::edit-widget"
    /// The cell in the area that is currently edited
    /// 
    /// This property is read-only and only changes as
    /// a result of a call `gtk_cell_area_activate_cell()`.
    case notifyEditedCell = "notify::edited-cell"
    /// The cell in the area that currently has focus
    case notifyFocusCell = "notify::focus-cell"
    /// The amount of space to reserve between cells.
    case notifySpacing = "notify::spacing"
}

public extension CellAreaBoxProtocol {
    /// Connect a `CellAreaBoxSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @inlinable @discardableResult func connect(signal kind: CellAreaBoxSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> Int {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> Int {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(raw: ptr).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

// MARK: CellAreaBox Class: CellAreaBoxProtocol extension (methods and fields)
public extension CellAreaBoxProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellAreaBox` instance.
    @inlinable var cell_area_box_ptr: UnsafeMutablePointer<GtkCellAreaBox>! { return ptr?.assumingMemoryBound(to: GtkCellAreaBox.self) }

    /// Gets the spacing added between cell renderers.
    @inlinable func getSpacing() -> Int {
        let rv = Int(gtk_cell_area_box_get_spacing(cell_area_box_ptr))
        return rv
    }

    /// Adds `renderer` to `box`, packed with reference to the end of `box`.
    /// 
    /// The `renderer` is packed after (away from end of) any other
    /// `GtkCellRenderer` packed with reference to the end of `box`.
    @inlinable func packEnd<CellRendererT: CellRendererProtocol>(renderer: CellRendererT, expand: Bool, align: Bool, fixed: Bool) {
        gtk_cell_area_box_pack_end(cell_area_box_ptr, renderer.cell_renderer_ptr, gboolean((expand) ? 1 : 0), gboolean((align) ? 1 : 0), gboolean((fixed) ? 1 : 0))
    
    }

    /// Adds `renderer` to `box`, packed with reference to the start of `box`.
    /// 
    /// The `renderer` is packed after any other `GtkCellRenderer` packed
    /// with reference to the start of `box`.
    @inlinable func packStart<CellRendererT: CellRendererProtocol>(renderer: CellRendererT, expand: Bool, align: Bool, fixed: Bool) {
        gtk_cell_area_box_pack_start(cell_area_box_ptr, renderer.cell_renderer_ptr, gboolean((expand) ? 1 : 0), gboolean((align) ? 1 : 0), gboolean((fixed) ? 1 : 0))
    
    }

    /// Sets the spacing to add between cell renderers in `box`.
    @inlinable func set(spacing: Int) {
        gtk_cell_area_box_set_spacing(cell_area_box_ptr, gint(spacing))
    
    }
    /// The amount of space to reserve between cells.
    @inlinable var spacing: Int {
        /// Gets the spacing added between cell renderers.
        get {
            let rv = Int(gtk_cell_area_box_get_spacing(cell_area_box_ptr))
            return rv
        }
        /// Sets the spacing to add between cell renderers in `box`.
        nonmutating set {
            gtk_cell_area_box_set_spacing(cell_area_box_ptr, gint(newValue))
        }
    }


}



// MARK: - CellAreaContext Class

/// The `CellAreaContextProtocol` protocol exposes the methods and properties of an underlying `GtkCellAreaContext` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellAreaContext`.
/// Alternatively, use `CellAreaContextRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// The `GtkCellAreaContext` object is created by a given `GtkCellArea`
/// implementation via its `GtkCellAreaClass.create_context``()` virtual
/// method and is used to store cell sizes and alignments for a series of
/// `GtkTreeModel` rows that are requested and rendered in the same context.
/// 
/// `GtkCellLayout` widgets can create any number of contexts in which to
/// request and render groups of data rows. However, it’s important that the
/// same context which was used to request sizes for a given `GtkTreeModel`
/// row also be used for the same row when calling other `GtkCellArea` APIs
/// such as `gtk_cell_area_render()` and `gtk_cell_area_event()`.
public protocol CellAreaContextProtocol: GLibObject.ObjectProtocol {
        /// Untyped pointer to the underlying `GtkCellAreaContext` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellAreaContext` instance.
    var cell_area_context_ptr: UnsafeMutablePointer<GtkCellAreaContext>! { get }

}

/// The `CellAreaContextRef` type acts as a lightweight Swift reference to an underlying `GtkCellAreaContext` instance.
/// It exposes methods that can operate on this data type through `CellAreaContextProtocol` conformance.
/// Use `CellAreaContextRef` only as an `unowned` reference to an existing `GtkCellAreaContext` instance.
///
/// The `GtkCellAreaContext` object is created by a given `GtkCellArea`
/// implementation via its `GtkCellAreaClass.create_context``()` virtual
/// method and is used to store cell sizes and alignments for a series of
/// `GtkTreeModel` rows that are requested and rendered in the same context.
/// 
/// `GtkCellLayout` widgets can create any number of contexts in which to
/// request and render groups of data rows. However, it’s important that the
/// same context which was used to request sizes for a given `GtkTreeModel`
/// row also be used for the same row when calling other `GtkCellArea` APIs
/// such as `gtk_cell_area_render()` and `gtk_cell_area_event()`.
public struct CellAreaContextRef: CellAreaContextProtocol {
        /// Untyped pointer to the underlying `GtkCellAreaContext` instance.
    /// For type-safe access, use the generated, typed pointer `cell_area_context_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellAreaContextRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellAreaContext>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellAreaContext>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellAreaContext>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellAreaContext>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellAreaContextProtocol`
    @inlinable init<T: CellAreaContextProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `CellAreaContext` type acts as a reference-counted owner of an underlying `GtkCellAreaContext` instance.
/// It provides the methods that can operate on this data type through `CellAreaContextProtocol` conformance.
/// Use `CellAreaContext` as a strong reference or owner of a `GtkCellAreaContext` instance.
///
/// The `GtkCellAreaContext` object is created by a given `GtkCellArea`
/// implementation via its `GtkCellAreaClass.create_context``()` virtual
/// method and is used to store cell sizes and alignments for a series of
/// `GtkTreeModel` rows that are requested and rendered in the same context.
/// 
/// `GtkCellLayout` widgets can create any number of contexts in which to
/// request and render groups of data rows. However, it’s important that the
/// same context which was used to request sizes for a given `GtkTreeModel`
/// row also be used for the same row when calling other `GtkCellArea` APIs
/// such as `gtk_cell_area_render()` and `gtk_cell_area_event()`.
open class CellAreaContext: GLibObject.Object, CellAreaContextProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellAreaContext` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCellAreaContext>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellAreaContext` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCellAreaContext>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellAreaContext` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellAreaContext` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellAreaContext` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCellAreaContext>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellAreaContext` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCellAreaContext>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCellAreaContext`.
    /// i.e., ownership is transferred to the `CellAreaContext` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCellAreaContext>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CellAreaContextProtocol`
    /// Will retain `GtkCellAreaContext`.
    /// - Parameter other: an instance of a related type that implements `CellAreaContextProtocol`
    @inlinable public init<T: CellAreaContextProtocol>(cellAreaContext other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum CellAreaContextPropertyName: String, PropertyNameProtocol {
    /// The `GtkCellArea` this context was created by
    case area = "area"
    /// The minimum height for the `GtkCellArea` in this context
    /// for all `GtkTreeModel` rows that this context was requested
    /// for using `gtk_cell_area_get_preferred_height()`.
    case minimumHeight = "minimum-height"
    /// The minimum width for the `GtkCellArea` in this context
    /// for all `GtkTreeModel` rows that this context was requested
    /// for using `gtk_cell_area_get_preferred_width()`.
    case minimumWidth = "minimum-width"
    /// The natural height for the `GtkCellArea` in this context
    /// for all `GtkTreeModel` rows that this context was requested
    /// for using `gtk_cell_area_get_preferred_height()`.
    case naturalHeight = "natural-height"
    /// The natural width for the `GtkCellArea` in this context
    /// for all `GtkTreeModel` rows that this context was requested
    /// for using `gtk_cell_area_get_preferred_width()`.
    case naturalWidth = "natural-width"
}

public extension CellAreaContextProtocol {
    /// Bind a `CellAreaContextPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellAreaContextPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CellAreaContext property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CellAreaContextPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CellAreaContext property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CellAreaContextPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CellAreaContextSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The `GtkCellArea` this context was created by
    case notifyArea = "notify::area"
    /// The minimum height for the `GtkCellArea` in this context
    /// for all `GtkTreeModel` rows that this context was requested
    /// for using `gtk_cell_area_get_preferred_height()`.
    case notifyMinimumHeight = "notify::minimum-height"
    /// The minimum width for the `GtkCellArea` in this context
    /// for all `GtkTreeModel` rows that this context was requested
    /// for using `gtk_cell_area_get_preferred_width()`.
    case notifyMinimumWidth = "notify::minimum-width"
    /// The natural height for the `GtkCellArea` in this context
    /// for all `GtkTreeModel` rows that this context was requested
    /// for using `gtk_cell_area_get_preferred_height()`.
    case notifyNaturalHeight = "notify::natural-height"
    /// The natural width for the `GtkCellArea` in this context
    /// for all `GtkTreeModel` rows that this context was requested
    /// for using `gtk_cell_area_get_preferred_width()`.
    case notifyNaturalWidth = "notify::natural-width"
}

public extension CellAreaContextProtocol {
    /// Connect a `CellAreaContextSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @inlinable @discardableResult func connect(signal kind: CellAreaContextSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> Int {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> Int {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(raw: ptr).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

// MARK: CellAreaContext Class: CellAreaContextProtocol extension (methods and fields)
public extension CellAreaContextProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellAreaContext` instance.
    @inlinable var cell_area_context_ptr: UnsafeMutablePointer<GtkCellAreaContext>! { return ptr?.assumingMemoryBound(to: GtkCellAreaContext.self) }

    /// Allocates a width and/or a height for all rows which are to be
    /// rendered with `context`.
    /// 
    /// Usually allocation is performed only horizontally or sometimes
    /// vertically since a group of rows are usually rendered side by
    /// side vertically or horizontally and share either the same width
    /// or the same height. Sometimes they are allocated in both horizontal
    /// and vertical orientations producing a homogeneous effect of the
    /// rows. This is generally the case for `GtkTreeView` when
    /// `GtkTreeView:fixed`-height-mode is enabled.
    @inlinable func allocate(width: Int, height: Int) {
        gtk_cell_area_context_allocate(cell_area_context_ptr, gint(width), gint(height))
    
    }

    /// Fetches the current allocation size for `context`.
    /// 
    /// If the context was not allocated in width or height, or if the
    /// context was recently reset with `gtk_cell_area_context_reset()`,
    /// the returned value will be -1.
    @inlinable func getAllocation(width: UnsafeMutablePointer<gint>! = nil, height: UnsafeMutablePointer<gint>! = nil) {
        gtk_cell_area_context_get_allocation(cell_area_context_ptr, width, height)
    
    }

    /// Fetches the `GtkCellArea` this `context` was created by.
    /// 
    /// This is generally unneeded by layouting widgets; however,
    /// it is important for the context implementation itself to
    /// fetch information about the area it is being used for.
    /// 
    /// For instance at `GtkCellAreaContextClass.allocate``()` time
    /// it’s important to know details about any cell spacing
    /// that the `GtkCellArea` is configured with in order to
    /// compute a proper allocation.
    @inlinable func getArea() -> CellAreaRef! {
        let rv = CellAreaRef(gconstpointer: gconstpointer(gtk_cell_area_context_get_area(cell_area_context_ptr)))
        return rv
    }

    /// Gets the accumulative preferred height for all rows which have been
    /// requested with this context.
    /// 
    /// After `gtk_cell_area_context_reset()` is called and/or before ever
    /// requesting the size of a `GtkCellArea`, the returned values are 0.
    @inlinable func getPreferredHeight(minimumHeight: UnsafeMutablePointer<gint>! = nil, naturalHeight: UnsafeMutablePointer<gint>! = nil) {
        gtk_cell_area_context_get_preferred_height(cell_area_context_ptr, minimumHeight, naturalHeight)
    
    }

    /// Gets the accumulative preferred height for `width` for all rows
    /// which have been requested for the same said `width` with this context.
    /// 
    /// After `gtk_cell_area_context_reset()` is called and/or before ever
    /// requesting the size of a `GtkCellArea`, the returned values are -1.
    @inlinable func getPreferredHeightFor(width: Int, minimumHeight: UnsafeMutablePointer<gint>! = nil, naturalHeight: UnsafeMutablePointer<gint>! = nil) {
        gtk_cell_area_context_get_preferred_height_for_width(cell_area_context_ptr, gint(width), minimumHeight, naturalHeight)
    
    }

    /// Gets the accumulative preferred width for all rows which have been
    /// requested with this context.
    /// 
    /// After `gtk_cell_area_context_reset()` is called and/or before ever
    /// requesting the size of a `GtkCellArea`, the returned values are 0.
    @inlinable func getPreferredWidth(minimumWidth: UnsafeMutablePointer<gint>! = nil, naturalWidth: UnsafeMutablePointer<gint>! = nil) {
        gtk_cell_area_context_get_preferred_width(cell_area_context_ptr, minimumWidth, naturalWidth)
    
    }

    /// Gets the accumulative preferred width for `height` for all rows which
    /// have been requested for the same said `height` with this context.
    /// 
    /// After `gtk_cell_area_context_reset()` is called and/or before ever
    /// requesting the size of a `GtkCellArea`, the returned values are -1.
    @inlinable func getPreferredWidthFor(height: Int, minimumWidth: UnsafeMutablePointer<gint>! = nil, naturalWidth: UnsafeMutablePointer<gint>! = nil) {
        gtk_cell_area_context_get_preferred_width_for_height(cell_area_context_ptr, gint(height), minimumWidth, naturalWidth)
    
    }

    /// Causes the minimum and/or natural height to grow if the new
    /// proposed sizes exceed the current minimum and natural height.
    /// 
    /// This is used by `GtkCellAreaContext` implementations during
    /// the request process over a series of `GtkTreeModel` rows to
    /// progressively push the requested height over a series of
    /// `gtk_cell_area_get_preferred_height()` requests.
    @inlinable func pushPreferredHeight(minimumHeight: Int, naturalHeight: Int) {
        gtk_cell_area_context_push_preferred_height(cell_area_context_ptr, gint(minimumHeight), gint(naturalHeight))
    
    }

    /// Causes the minimum and/or natural width to grow if the new
    /// proposed sizes exceed the current minimum and natural width.
    /// 
    /// This is used by `GtkCellAreaContext` implementations during
    /// the request process over a series of `GtkTreeModel` rows to
    /// progressively push the requested width over a series of
    /// `gtk_cell_area_get_preferred_width()` requests.
    @inlinable func pushPreferredWidth(minimumWidth: Int, naturalWidth: Int) {
        gtk_cell_area_context_push_preferred_width(cell_area_context_ptr, gint(minimumWidth), gint(naturalWidth))
    
    }

    /// Resets any previously cached request and allocation
    /// data.
    /// 
    /// When underlying `GtkTreeModel` data changes its
    /// important to reset the context if the content
    /// size is allowed to shrink. If the content size
    /// is only allowed to grow (this is usually an option
    /// for views rendering large data stores as a measure
    /// of optimization), then only the row that changed
    /// or was inserted needs to be (re)requested with
    /// `gtk_cell_area_get_preferred_width()`.
    /// 
    /// When the new overall size of the context requires
    /// that the allocated size changes (or whenever this
    /// allocation changes at all), the variable row
    /// sizes need to be re-requested for every row.
    /// 
    /// For instance, if the rows are displayed all with
    /// the same width from top to bottom then a change
    /// in the allocated width necessitates a recalculation
    /// of all the displayed row heights using
    /// `gtk_cell_area_get_preferred_height_for_width()`.
    @inlinable func reset() {
        gtk_cell_area_context_reset(cell_area_context_ptr)
    
    }
    /// The `GtkCellArea` this context was created by
    @inlinable var area: CellAreaRef! {
        /// Fetches the `GtkCellArea` this `context` was created by.
        /// 
        /// This is generally unneeded by layouting widgets; however,
        /// it is important for the context implementation itself to
        /// fetch information about the area it is being used for.
        /// 
        /// For instance at `GtkCellAreaContextClass.allocate``()` time
        /// it’s important to know details about any cell spacing
        /// that the `GtkCellArea` is configured with in order to
        /// compute a proper allocation.
        get {
            let rv = CellAreaRef(gconstpointer: gconstpointer(gtk_cell_area_context_get_area(cell_area_context_ptr)))
            return rv
        }
    }

    // var parentInstance is unavailable because parent_instance is private

}



// MARK: - CellRenderer Class

/// The `CellRendererProtocol` protocol exposes the methods and properties of an underlying `GtkCellRenderer` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellRenderer`.
/// Alternatively, use `CellRendererRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// The `GtkCellRenderer` is a base class of a set of objects used for
/// rendering a cell to a `cairo_t`.  These objects are used primarily by
/// the `GtkTreeView` widget, though they aren’t tied to them in any
/// specific way.  It is worth noting that `GtkCellRenderer` is not a
/// `GtkWidget` and cannot be treated as such.
/// 
/// The primary use of a `GtkCellRenderer` is for drawing a certain graphical
/// elements on a `cairo_t`. Typically, one cell renderer is used to
/// draw many cells on the screen.  To this extent, it isn’t expected that a
/// CellRenderer keep any permanent state around.  Instead, any state is set
/// just prior to use using `GObjects` property system.  Then, the
/// cell is measured using `gtk_cell_renderer_get_preferred_size()`. Finally, the cell
/// is rendered in the correct location using `gtk_cell_renderer_snapshot()`.
/// 
/// There are a number of rules that must be followed when writing a new
/// `GtkCellRenderer`.  First and foremost, it’s important that a certain set
/// of properties will always yield a cell renderer of the same size,
/// barring a style change. The `GtkCellRenderer` also has a number of
/// generic properties that are expected to be honored by all children.
/// 
/// Beyond merely rendering a cell, cell renderers can optionally
/// provide active user interface elements. A cell renderer can be
/// “activatable” like `GtkCellRendererToggle`,
/// which toggles when it gets activated by a mouse click, or it can be
/// “editable” like `GtkCellRendererText`, which
/// allows the user to edit the text using a widget implementing the
/// `GtkCellEditable` interface, e.g. `GtkEntry`.
/// To make a cell renderer activatable or editable, you have to
/// implement the `GtkCellRendererClass.activate` or
/// `GtkCellRendererClass.start_editing` virtual functions, respectively.
/// 
/// Many properties of `GtkCellRenderer` and its subclasses have a
/// corresponding “set” property, e.g. “cell-background-set” corresponds
/// to “cell-background”. These “set” properties reflect whether a property
/// has been set or not. You should not set them independently.
public protocol CellRendererProtocol: GLibObject.InitiallyUnownedProtocol {
        /// Untyped pointer to the underlying `GtkCellRenderer` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellRenderer` instance.
    var cell_renderer_ptr: UnsafeMutablePointer<GtkCellRenderer>! { get }

}

/// The `CellRendererRef` type acts as a lightweight Swift reference to an underlying `GtkCellRenderer` instance.
/// It exposes methods that can operate on this data type through `CellRendererProtocol` conformance.
/// Use `CellRendererRef` only as an `unowned` reference to an existing `GtkCellRenderer` instance.
///
/// The `GtkCellRenderer` is a base class of a set of objects used for
/// rendering a cell to a `cairo_t`.  These objects are used primarily by
/// the `GtkTreeView` widget, though they aren’t tied to them in any
/// specific way.  It is worth noting that `GtkCellRenderer` is not a
/// `GtkWidget` and cannot be treated as such.
/// 
/// The primary use of a `GtkCellRenderer` is for drawing a certain graphical
/// elements on a `cairo_t`. Typically, one cell renderer is used to
/// draw many cells on the screen.  To this extent, it isn’t expected that a
/// CellRenderer keep any permanent state around.  Instead, any state is set
/// just prior to use using `GObjects` property system.  Then, the
/// cell is measured using `gtk_cell_renderer_get_preferred_size()`. Finally, the cell
/// is rendered in the correct location using `gtk_cell_renderer_snapshot()`.
/// 
/// There are a number of rules that must be followed when writing a new
/// `GtkCellRenderer`.  First and foremost, it’s important that a certain set
/// of properties will always yield a cell renderer of the same size,
/// barring a style change. The `GtkCellRenderer` also has a number of
/// generic properties that are expected to be honored by all children.
/// 
/// Beyond merely rendering a cell, cell renderers can optionally
/// provide active user interface elements. A cell renderer can be
/// “activatable” like `GtkCellRendererToggle`,
/// which toggles when it gets activated by a mouse click, or it can be
/// “editable” like `GtkCellRendererText`, which
/// allows the user to edit the text using a widget implementing the
/// `GtkCellEditable` interface, e.g. `GtkEntry`.
/// To make a cell renderer activatable or editable, you have to
/// implement the `GtkCellRendererClass.activate` or
/// `GtkCellRendererClass.start_editing` virtual functions, respectively.
/// 
/// Many properties of `GtkCellRenderer` and its subclasses have a
/// corresponding “set” property, e.g. “cell-background-set” corresponds
/// to “cell-background”. These “set” properties reflect whether a property
/// has been set or not. You should not set them independently.
public struct CellRendererRef: CellRendererProtocol {
        /// Untyped pointer to the underlying `GtkCellRenderer` instance.
    /// For type-safe access, use the generated, typed pointer `cell_renderer_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellRendererRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellRenderer>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellRenderer>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellRenderer>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellRenderer>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellRendererProtocol`
    @inlinable init<T: CellRendererProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `CellRenderer` type acts as a reference-counted owner of an underlying `GtkCellRenderer` instance.
/// It provides the methods that can operate on this data type through `CellRendererProtocol` conformance.
/// Use `CellRenderer` as a strong reference or owner of a `GtkCellRenderer` instance.
///
/// The `GtkCellRenderer` is a base class of a set of objects used for
/// rendering a cell to a `cairo_t`.  These objects are used primarily by
/// the `GtkTreeView` widget, though they aren’t tied to them in any
/// specific way.  It is worth noting that `GtkCellRenderer` is not a
/// `GtkWidget` and cannot be treated as such.
/// 
/// The primary use of a `GtkCellRenderer` is for drawing a certain graphical
/// elements on a `cairo_t`. Typically, one cell renderer is used to
/// draw many cells on the screen.  To this extent, it isn’t expected that a
/// CellRenderer keep any permanent state around.  Instead, any state is set
/// just prior to use using `GObjects` property system.  Then, the
/// cell is measured using `gtk_cell_renderer_get_preferred_size()`. Finally, the cell
/// is rendered in the correct location using `gtk_cell_renderer_snapshot()`.
/// 
/// There are a number of rules that must be followed when writing a new
/// `GtkCellRenderer`.  First and foremost, it’s important that a certain set
/// of properties will always yield a cell renderer of the same size,
/// barring a style change. The `GtkCellRenderer` also has a number of
/// generic properties that are expected to be honored by all children.
/// 
/// Beyond merely rendering a cell, cell renderers can optionally
/// provide active user interface elements. A cell renderer can be
/// “activatable” like `GtkCellRendererToggle`,
/// which toggles when it gets activated by a mouse click, or it can be
/// “editable” like `GtkCellRendererText`, which
/// allows the user to edit the text using a widget implementing the
/// `GtkCellEditable` interface, e.g. `GtkEntry`.
/// To make a cell renderer activatable or editable, you have to
/// implement the `GtkCellRendererClass.activate` or
/// `GtkCellRendererClass.start_editing` virtual functions, respectively.
/// 
/// Many properties of `GtkCellRenderer` and its subclasses have a
/// corresponding “set” property, e.g. “cell-background-set” corresponds
/// to “cell-background”. These “set” properties reflect whether a property
/// has been set or not. You should not set them independently.
open class CellRenderer: GLibObject.InitiallyUnowned, CellRendererProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRenderer` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCellRenderer>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRenderer` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCellRenderer>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRenderer` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRenderer` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRenderer` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCellRenderer>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRenderer` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCellRenderer>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCellRenderer`.
    /// i.e., ownership is transferred to the `CellRenderer` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCellRenderer>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CellRendererProtocol`
    /// Will retain `GtkCellRenderer`.
    /// - Parameter other: an instance of a related type that implements `CellRendererProtocol`
    @inlinable public init<T: CellRendererProtocol>(cellRenderer other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum CellRendererPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case cellBackground = "cell-background"
    /// Cell background as a `GdkRGBA`
    case cellBackgroundRgba = "cell-background-rgba"
    case cellBackgroundSet = "cell-background-set"
    case editing = "editing"
    case height = "height"
    case isExpanded = "is-expanded"
    case isExpander = "is-expander"
    case mode = "mode"
    case sensitive = "sensitive"
    case visible = "visible"
    case width = "width"
    case xalign = "xalign"
    case xpad = "xpad"
    case yalign = "yalign"
    case ypad = "ypad"
}

public extension CellRendererProtocol {
    /// Bind a `CellRendererPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellRendererPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CellRenderer property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CellRendererPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CellRenderer property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CellRendererPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CellRendererSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// This signal gets emitted when the user cancels the process of editing a
    /// cell.  For example, an editable cell renderer could be written to cancel
    /// editing when the user presses Escape.
    /// 
    /// See also: `gtk_cell_renderer_stop_editing()`.
    case editingCanceled = "editing-canceled"
    /// This signal gets emitted when a cell starts to be edited.
    /// The intended use of this signal is to do special setup
    /// on `editable`, e.g. adding a `GtkEntryCompletion` or setting
    /// up additional columns in a `GtkComboBox`.
    /// 
    /// See `gtk_cell_editable_start_editing()` for information on the lifecycle of
    /// the `editable` and a way to do setup that doesn’t depend on the `renderer`.
    /// 
    /// Note that GTK doesn't guarantee that cell renderers will
    /// continue to use the same kind of widget for editing in future
    /// releases, therefore you should check the type of `editable`
    /// before doing any specific setup, as in the following example:
    /// (C Language Example):
    /// ```C
    /// static void
    /// text_editing_started (GtkCellRenderer *cell,
    ///                       GtkCellEditable *editable,
    ///                       const char      *path,
    ///                       gpointer         data)
    /// {
    ///   if (GTK_IS_ENTRY (editable))
    ///     {
    ///       GtkEntry *entry = GTK_ENTRY (editable);
    ///       
    ///       // ... create a GtkEntryCompletion
    ///       
    ///       gtk_entry_set_completion (entry, completion);
    ///     }
    /// }
    /// ```
    /// 
    case editingStarted = "editing-started"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyCellBackground = "notify::cell-background"
    /// Cell background as a `GdkRGBA`
    case notifyCellBackgroundRgba = "notify::cell-background-rgba"
    case notifyCellBackgroundSet = "notify::cell-background-set"
    case notifyEditing = "notify::editing"
    case notifyHeight = "notify::height"
    case notifyIsExpanded = "notify::is-expanded"
    case notifyIsExpander = "notify::is-expander"
    case notifyMode = "notify::mode"
    case notifySensitive = "notify::sensitive"
    case notifyVisible = "notify::visible"
    case notifyWidth = "notify::width"
    case notifyXalign = "notify::xalign"
    case notifyXpad = "notify::xpad"
    case notifyYalign = "notify::yalign"
    case notifyYpad = "notify::ypad"
}

public extension CellRendererProtocol {
    /// Connect a `CellRendererSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @inlinable @discardableResult func connect(signal kind: CellRendererSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> Int {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> Int {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(raw: ptr).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

// MARK: CellRenderer Class: CellRendererProtocol extension (methods and fields)
public extension CellRendererProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellRenderer` instance.
    @inlinable var cell_renderer_ptr: UnsafeMutablePointer<GtkCellRenderer>! { return ptr?.assumingMemoryBound(to: GtkCellRenderer.self) }

    /// Passes an activate event to the cell renderer for possible processing.
    /// Some cell renderers may use events; for example, `GtkCellRendererToggle`
    /// toggles when it gets a mouse click.
    @inlinable func activate<EventT: Gdk.EventProtocol, RectangleT: Gdk.RectangleProtocol, WidgetT: WidgetProtocol>(event: EventT, widget: WidgetT, path: UnsafePointer<CChar>!, backgroundArea: RectangleT, cellArea: RectangleT, flags: CellRendererState) -> Bool {
        let rv = ((gtk_cell_renderer_activate(cell_renderer_ptr, event.event_ptr, widget.widget_ptr, path, backgroundArea.rectangle_ptr, cellArea.rectangle_ptr, flags.value)) != 0)
        return rv
    }

    /// Gets the aligned area used by `cell` inside `cell_area`. Used for finding
    /// the appropriate edit and focus rectangle.
    @inlinable func getAlignedArea<RectangleT: Gdk.RectangleProtocol, WidgetT: WidgetProtocol>(widget: WidgetT, flags: CellRendererState, cellArea: RectangleT, alignedArea: RectangleT) {
        gtk_cell_renderer_get_aligned_area(cell_renderer_ptr, widget.widget_ptr, flags.value, cellArea.rectangle_ptr, alignedArea.rectangle_ptr)
    
    }

    /// Fills in `xalign` and `yalign` with the appropriate values of `cell`.
    @inlinable func getAlignment(xalign: UnsafeMutablePointer<CFloat>! = nil, yalign: UnsafeMutablePointer<CFloat>! = nil) {
        gtk_cell_renderer_get_alignment(cell_renderer_ptr, xalign, yalign)
    
    }

    /// Fills in `width` and `height` with the appropriate size of `cell`.
    @inlinable func getFixedSize(width: UnsafeMutablePointer<gint>! = nil, height: UnsafeMutablePointer<gint>! = nil) {
        gtk_cell_renderer_get_fixed_size(cell_renderer_ptr, width, height)
    
    }

    /// Checks whether the given `GtkCellRenderer` is expanded.
    @inlinable func getIsExpanded() -> Bool {
        let rv = ((gtk_cell_renderer_get_is_expanded(cell_renderer_ptr)) != 0)
        return rv
    }

    /// Checks whether the given `GtkCellRenderer` is an expander.
    @inlinable func getIsExpander() -> Bool {
        let rv = ((gtk_cell_renderer_get_is_expander(cell_renderer_ptr)) != 0)
        return rv
    }

    /// Fills in `xpad` and `ypad` with the appropriate values of `cell`.
    @inlinable func getPadding(xpad: UnsafeMutablePointer<gint>! = nil, ypad: UnsafeMutablePointer<gint>! = nil) {
        gtk_cell_renderer_get_padding(cell_renderer_ptr, xpad, ypad)
    
    }

    /// Retrieves a renderer’s natural size when rendered to `widget`.
    @inlinable func getPreferredHeight<WidgetT: WidgetProtocol>(widget: WidgetT, minimumSize: UnsafeMutablePointer<gint>! = nil, naturalSize: UnsafeMutablePointer<gint>! = nil) {
        gtk_cell_renderer_get_preferred_height(cell_renderer_ptr, widget.widget_ptr, minimumSize, naturalSize)
    
    }

    /// Retrieves a cell renderers’s minimum and natural height if it were rendered to
    /// `widget` with the specified `width`.
    @inlinable func getPreferredHeightForWidth<WidgetT: WidgetProtocol>(widget: WidgetT, width: Int, minimumHeight: UnsafeMutablePointer<gint>! = nil, naturalHeight: UnsafeMutablePointer<gint>! = nil) {
        gtk_cell_renderer_get_preferred_height_for_width(cell_renderer_ptr, widget.widget_ptr, gint(width), minimumHeight, naturalHeight)
    
    }

    /// Retrieves the minimum and natural size of a cell taking
    /// into account the widget’s preference for height-for-width management.
    @inlinable func getPreferredSize<WidgetT: WidgetProtocol>(widget: WidgetT, minimumSize: RequisitionRef? = nil, naturalSize: RequisitionRef? = nil) {
        gtk_cell_renderer_get_preferred_size(cell_renderer_ptr, widget.widget_ptr, minimumSize?.requisition_ptr, naturalSize?.requisition_ptr)
    
    }
    /// Retrieves the minimum and natural size of a cell taking
    /// into account the widget’s preference for height-for-width management.
    @inlinable func getPreferredSize<RequisitionT: RequisitionProtocol, WidgetT: WidgetProtocol>(widget: WidgetT, minimumSize: RequisitionT?, naturalSize: RequisitionT?) {
        gtk_cell_renderer_get_preferred_size(cell_renderer_ptr, widget.widget_ptr, minimumSize?.requisition_ptr, naturalSize?.requisition_ptr)
    
    }

    /// Retrieves a renderer’s natural size when rendered to `widget`.
    @inlinable func getPreferredWidth<WidgetT: WidgetProtocol>(widget: WidgetT, minimumSize: UnsafeMutablePointer<gint>! = nil, naturalSize: UnsafeMutablePointer<gint>! = nil) {
        gtk_cell_renderer_get_preferred_width(cell_renderer_ptr, widget.widget_ptr, minimumSize, naturalSize)
    
    }

    /// Retrieves a cell renderers’s minimum and natural width if it were rendered to
    /// `widget` with the specified `height`.
    @inlinable func getPreferredWidthForHeight<WidgetT: WidgetProtocol>(widget: WidgetT, height: Int, minimumWidth: UnsafeMutablePointer<gint>! = nil, naturalWidth: UnsafeMutablePointer<gint>! = nil) {
        gtk_cell_renderer_get_preferred_width_for_height(cell_renderer_ptr, widget.widget_ptr, gint(height), minimumWidth, naturalWidth)
    
    }

    /// Gets whether the cell renderer prefers a height-for-width layout
    /// or a width-for-height layout.
    @inlinable func getRequestMode() -> GtkSizeRequestMode {
        let rv = gtk_cell_renderer_get_request_mode(cell_renderer_ptr)
        return rv
    }

    /// Returns the cell renderer’s sensitivity.
    @inlinable func getSensitive() -> Bool {
        let rv = ((gtk_cell_renderer_get_sensitive(cell_renderer_ptr)) != 0)
        return rv
    }

    /// Translates the cell renderer state to `GtkStateFlags`,
    /// based on the cell renderer and widget sensitivity, and
    /// the given `GtkCellRendererState`.
    @inlinable func getState(widget: WidgetRef? = nil, cellState: CellRendererState) -> StateFlags {
        let rv = StateFlags(gtk_cell_renderer_get_state(cell_renderer_ptr, widget?.widget_ptr, cellState.value))
        return rv
    }
    /// Translates the cell renderer state to `GtkStateFlags`,
    /// based on the cell renderer and widget sensitivity, and
    /// the given `GtkCellRendererState`.
    @inlinable func getState<WidgetT: WidgetProtocol>(widget: WidgetT?, cellState: CellRendererState) -> StateFlags {
        let rv = StateFlags(gtk_cell_renderer_get_state(cell_renderer_ptr, widget?.widget_ptr, cellState.value))
        return rv
    }

    /// Returns the cell renderer’s visibility.
    @inlinable func getVisible() -> Bool {
        let rv = ((gtk_cell_renderer_get_visible(cell_renderer_ptr)) != 0)
        return rv
    }

    /// Sets the renderer’s alignment within its available space.
    @inlinable func setAlignment(xalign: CFloat, yalign: CFloat) {
        gtk_cell_renderer_set_alignment(cell_renderer_ptr, xalign, yalign)
    
    }

    /// Sets the renderer size to be explicit, independent of the properties set.
    @inlinable func setFixedSize(width: Int, height: Int) {
        gtk_cell_renderer_set_fixed_size(cell_renderer_ptr, gint(width), gint(height))
    
    }

    /// Sets whether the given `GtkCellRenderer` is expanded.
    @inlinable func set(isExpanded: Bool) {
        gtk_cell_renderer_set_is_expanded(cell_renderer_ptr, gboolean((isExpanded) ? 1 : 0))
    
    }

    /// Sets whether the given `GtkCellRenderer` is an expander.
    @inlinable func set(isExpander: Bool) {
        gtk_cell_renderer_set_is_expander(cell_renderer_ptr, gboolean((isExpander) ? 1 : 0))
    
    }

    /// Sets the renderer’s padding.
    @inlinable func setPadding(xpad: Int, ypad: Int) {
        gtk_cell_renderer_set_padding(cell_renderer_ptr, gint(xpad), gint(ypad))
    
    }

    /// Sets the cell renderer’s sensitivity.
    @inlinable func set(sensitive: Bool) {
        gtk_cell_renderer_set_sensitive(cell_renderer_ptr, gboolean((sensitive) ? 1 : 0))
    
    }

    /// Sets the cell renderer’s visibility.
    @inlinable func set(visible: Bool) {
        gtk_cell_renderer_set_visible(cell_renderer_ptr, gboolean((visible) ? 1 : 0))
    
    }

    /// Invokes the virtual render function of the `GtkCellRenderer`. The three
    /// passed-in rectangles are areas in `cr`. Most renderers will draw within
    /// `cell_area`; the xalign, yalign, xpad, and ypad fields of the `GtkCellRenderer`
    /// should be honored with respect to `cell_area`. `background_area` includes the
    /// blank space around the cell, and also the area containing the tree expander;
    /// so the `background_area` rectangles for all cells tile to cover the entire
    /// `window`.
    @inlinable func snapshot<RectangleT: Gdk.RectangleProtocol, SnapshotT: SnapshotProtocol, WidgetT: WidgetProtocol>(snapshot: SnapshotT, widget: WidgetT, backgroundArea: RectangleT, cellArea: RectangleT, flags: CellRendererState) {
        gtk_cell_renderer_snapshot(cell_renderer_ptr, snapshot.snapshot_ptr, widget.widget_ptr, backgroundArea.rectangle_ptr, cellArea.rectangle_ptr, flags.value)
    
    }

    /// Starts editing the contents of this `cell`, through a new `GtkCellEditable`
    /// widget created by the `GtkCellRendererClass.start_editing` virtual function.
    @inlinable func startEditing<RectangleT: Gdk.RectangleProtocol, WidgetT: WidgetProtocol>(event: Gdk.EventRef? = nil, widget: WidgetT, path: UnsafePointer<CChar>!, backgroundArea: RectangleT, cellArea: RectangleT, flags: CellRendererState) -> CellEditableRef! {
        let rv = CellEditableRef(gconstpointer: gconstpointer(gtk_cell_renderer_start_editing(cell_renderer_ptr, event?.event_ptr, widget.widget_ptr, path, backgroundArea.rectangle_ptr, cellArea.rectangle_ptr, flags.value)))
        return rv
    }
    /// Starts editing the contents of this `cell`, through a new `GtkCellEditable`
    /// widget created by the `GtkCellRendererClass.start_editing` virtual function.
    @inlinable func startEditing<EventT: Gdk.EventProtocol, RectangleT: Gdk.RectangleProtocol, WidgetT: WidgetProtocol>(event: EventT?, widget: WidgetT, path: UnsafePointer<CChar>!, backgroundArea: RectangleT, cellArea: RectangleT, flags: CellRendererState) -> CellEditableRef! {
        let rv = CellEditableRef(gconstpointer: gconstpointer(gtk_cell_renderer_start_editing(cell_renderer_ptr, event?.event_ptr, widget.widget_ptr, path, backgroundArea.rectangle_ptr, cellArea.rectangle_ptr, flags.value)))
        return rv
    }

    /// Informs the cell renderer that the editing is stopped.
    /// If `canceled` is `true`, the cell renderer will emit the
    /// `GtkCellRenderer::editing`-canceled signal.
    /// 
    /// This function should be called by cell renderer implementations
    /// in response to the `GtkCellEditable::editing`-done signal of
    /// `GtkCellEditable`.
    @inlinable func stopEditing(canceled: Bool) {
        gtk_cell_renderer_stop_editing(cell_renderer_ptr, gboolean((canceled) ? 1 : 0))
    
    }
    /// Checks whether the cell renderer can do something when activated.
    @inlinable var isActivatable: Bool {
        /// Checks whether the cell renderer can do something when activated.
        get {
            let rv = ((gtk_cell_renderer_is_activatable(cell_renderer_ptr)) != 0)
            return rv
        }
    }

    /// Checks whether the given `GtkCellRenderer` is expanded.
    @inlinable var isExpanded: Bool {
        /// Checks whether the given `GtkCellRenderer` is expanded.
        get {
            let rv = ((gtk_cell_renderer_get_is_expanded(cell_renderer_ptr)) != 0)
            return rv
        }
        /// Sets whether the given `GtkCellRenderer` is expanded.
        nonmutating set {
            gtk_cell_renderer_set_is_expanded(cell_renderer_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Checks whether the given `GtkCellRenderer` is an expander.
    @inlinable var isExpander: Bool {
        /// Checks whether the given `GtkCellRenderer` is an expander.
        get {
            let rv = ((gtk_cell_renderer_get_is_expander(cell_renderer_ptr)) != 0)
            return rv
        }
        /// Sets whether the given `GtkCellRenderer` is an expander.
        nonmutating set {
            gtk_cell_renderer_set_is_expander(cell_renderer_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Gets whether the cell renderer prefers a height-for-width layout
    /// or a width-for-height layout.
    @inlinable var requestMode: GtkSizeRequestMode {
        /// Gets whether the cell renderer prefers a height-for-width layout
        /// or a width-for-height layout.
        get {
            let rv = gtk_cell_renderer_get_request_mode(cell_renderer_ptr)
            return rv
        }
    }

    @inlinable var sensitive: Bool {
        /// Returns the cell renderer’s sensitivity.
        get {
            let rv = ((gtk_cell_renderer_get_sensitive(cell_renderer_ptr)) != 0)
            return rv
        }
        /// Sets the cell renderer’s sensitivity.
        nonmutating set {
            gtk_cell_renderer_set_sensitive(cell_renderer_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    @inlinable var visible: Bool {
        /// Returns the cell renderer’s visibility.
        get {
            let rv = ((gtk_cell_renderer_get_visible(cell_renderer_ptr)) != 0)
            return rv
        }
        /// Sets the cell renderer’s visibility.
        nonmutating set {
            gtk_cell_renderer_set_visible(cell_renderer_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    @inlinable var parentInstance: GInitiallyUnowned {
        get {
            let rv = cell_renderer_ptr.pointee.parent_instance
            return rv
        }
    }

    // var priv is unavailable because priv is private

}



// MARK: - CellRendererAccel Class

/// The `CellRendererAccelProtocol` protocol exposes the methods and properties of an underlying `GtkCellRendererAccel` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellRendererAccel`.
/// Alternatively, use `CellRendererAccelRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkCellRendererAccel` displays a keyboard accelerator (i.e. a key
/// combination like `Control + a`). If the cell renderer is editable,
/// the accelerator can be changed by simply typing the new combination.
public protocol CellRendererAccelProtocol: CellRendererTextProtocol {
        /// Untyped pointer to the underlying `GtkCellRendererAccel` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellRendererAccel` instance.
    var cell_renderer_accel_ptr: UnsafeMutablePointer<GtkCellRendererAccel>! { get }

}

/// The `CellRendererAccelRef` type acts as a lightweight Swift reference to an underlying `GtkCellRendererAccel` instance.
/// It exposes methods that can operate on this data type through `CellRendererAccelProtocol` conformance.
/// Use `CellRendererAccelRef` only as an `unowned` reference to an existing `GtkCellRendererAccel` instance.
///
/// `GtkCellRendererAccel` displays a keyboard accelerator (i.e. a key
/// combination like `Control + a`). If the cell renderer is editable,
/// the accelerator can be changed by simply typing the new combination.
public struct CellRendererAccelRef: CellRendererAccelProtocol {
        /// Untyped pointer to the underlying `GtkCellRendererAccel` instance.
    /// For type-safe access, use the generated, typed pointer `cell_renderer_accel_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellRendererAccelRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellRendererAccel>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellRendererAccel>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellRendererAccel>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellRendererAccel>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellRendererAccelProtocol`
    @inlinable init<T: CellRendererAccelProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCellRendererAccel`.
    @inlinable init() {
        let rv = gtk_cell_renderer_accel_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `CellRendererAccel` type acts as a reference-counted owner of an underlying `GtkCellRendererAccel` instance.
/// It provides the methods that can operate on this data type through `CellRendererAccelProtocol` conformance.
/// Use `CellRendererAccel` as a strong reference or owner of a `GtkCellRendererAccel` instance.
///
/// `GtkCellRendererAccel` displays a keyboard accelerator (i.e. a key
/// combination like `Control + a`). If the cell renderer is editable,
/// the accelerator can be changed by simply typing the new combination.
open class CellRendererAccel: CellRendererText, CellRendererAccelProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererAccel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCellRendererAccel>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererAccel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCellRendererAccel>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererAccel` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererAccel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererAccel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCellRendererAccel>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererAccel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCellRendererAccel>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCellRendererAccel`.
    /// i.e., ownership is transferred to the `CellRendererAccel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCellRendererAccel>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CellRendererAccelProtocol`
    /// Will retain `GtkCellRendererAccel`.
    /// - Parameter other: an instance of a related type that implements `CellRendererAccelProtocol`
    @inlinable public init<T: CellRendererAccelProtocol>(cellRendererAccel other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkCellRendererAccel`.
    @inlinable override public init() {
        let rv = gtk_cell_renderer_accel_new()
        super.init(gpointer: gpointer(rv))
    }


}

public enum CellRendererAccelPropertyName: String, PropertyNameProtocol {
    /// The keyval of the accelerator.
    case accelKey = "accel-key"
    /// Determines if the edited accelerators are GTK accelerators. If
    /// they are, consumed modifiers are suppressed, only accelerators
    /// accepted by GTK are allowed, and the accelerators are rendered
    /// in the same way as they are in menus.
    case accelMode = "accel-mode"
    /// The modifier mask of the accelerator.
    case accelMods = "accel-mods"
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case alignSet = "align-set"
    /// Specifies how to align the lines of text with respect to each other.
    /// 
    /// Note that this property describes how to align the lines of text in
    /// case there are several of them. The "xalign" property of `GtkCellRenderer`,
    /// on the other hand, sets the horizontal alignment of the whole text.
    case alignment = "alignment"
    case attributes = "attributes"
    case background = "background"
    /// Background color as a `GdkRGBA`
    case backgroundRgba = "background-rgba"
    case backgroundSet = "background-set"
    case cellBackground = "cell-background"
    /// Cell background as a `GdkRGBA`
    case cellBackgroundRgba = "cell-background-rgba"
    case cellBackgroundSet = "cell-background-set"
    case editable = "editable"
    case editableSet = "editable-set"
    case editing = "editing"
    /// Specifies the preferred place to ellipsize the string, if the cell renderer
    /// does not have enough room to display the entire string. Setting it to
    /// `PANGO_ELLIPSIZE_NONE` turns off ellipsizing. See the wrap-width property
    /// for another way of making the text fit into a given width.
    case ellipsize = "ellipsize"
    case ellipsizeSet = "ellipsize-set"
    case family = "family"
    case familySet = "family-set"
    case font = "font"
    case fontDesc = "font-desc"
    case foreground = "foreground"
    /// Foreground color as a `GdkRGBA`
    case foregroundRgba = "foreground-rgba"
    case foregroundSet = "foreground-set"
    case height = "height"
    case isExpanded = "is-expanded"
    case isExpander = "is-expander"
    /// The hardware keycode of the accelerator. Note that the hardware keycode is
    /// only relevant if the key does not have a keyval. Normally, the keyboard
    /// configuration should assign keyvals to all keys.
    case keycode = "keycode"
    case language = "language"
    case languageSet = "language-set"
    case markup = "markup"
    /// The desired maximum width of the cell, in characters. If this property
    /// is set to -1, the width will be calculated automatically.
    /// 
    /// For cell renderers that ellipsize or wrap text; this property
    /// controls the maximum reported width of the cell. The
    /// cell should not receive any greater allocation unless it is
    /// set to expand in its `GtkCellLayout` and all of the cell's siblings
    /// have received their natural width.
    case maxWidthChars = "max-width-chars"
    case mode = "mode"
    /// The text that will be displayed in the `GtkCellRenderer` if
    /// `GtkCellRendererText:editable` is `true` and the cell is empty.
    case placeholderText = "placeholder-text"
    case rise = "rise"
    case riseSet = "rise-set"
    case scale = "scale"
    case scaleSet = "scale-set"
    case sensitive = "sensitive"
    case singleParagraphMode = "single-paragraph-mode"
    case size = "size"
    case sizePoints = "size-points"
    case sizeSet = "size-set"
    case stretch = "stretch"
    case stretchSet = "stretch-set"
    case strikethrough = "strikethrough"
    case strikethroughSet = "strikethrough-set"
    case style = "style"
    case styleSet = "style-set"
    case text = "text"
    case underline = "underline"
    case underlineSet = "underline-set"
    case variant = "variant"
    case variantSet = "variant-set"
    case visible = "visible"
    case weight = "weight"
    case weightSet = "weight-set"
    case width = "width"
    /// The desired width of the cell, in characters. If this property is set to
    /// -1, the width will be calculated automatically, otherwise the cell will
    /// request either 3 characters or the property value, whichever is greater.
    case widthChars = "width-chars"
    /// Specifies how to break the string into multiple lines, if the cell
    /// renderer does not have enough room to display the entire string.
    /// This property has no effect unless the wrap-width property is set.
    case wrapMode = "wrap-mode"
    /// Specifies the minimum width at which the text is wrapped. The wrap-mode property can
    /// be used to influence at what character positions the line breaks can be placed.
    /// Setting wrap-width to -1 turns wrapping off.
    case wrapWidth = "wrap-width"
    case xalign = "xalign"
    case xpad = "xpad"
    case yalign = "yalign"
    case ypad = "ypad"
}

public extension CellRendererAccelProtocol {
    /// Bind a `CellRendererAccelPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellRendererAccelPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CellRendererAccel property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CellRendererAccelPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CellRendererAccel property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CellRendererAccelPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CellRendererAccelSignalName: String, SignalNameProtocol {
    /// Gets emitted when the user has removed the accelerator.
    case accelCleared = "accel-cleared"
    /// Gets emitted when the user has selected a new accelerator.
    case accelEdited = "accel-edited"
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// This signal is emitted after `renderer` has been edited.
    /// 
    /// It is the responsibility of the application to update the model
    /// and store `new_text` at the position indicated by `path`.
    case edited = "edited"
    /// This signal gets emitted when the user cancels the process of editing a
    /// cell.  For example, an editable cell renderer could be written to cancel
    /// editing when the user presses Escape.
    /// 
    /// See also: `gtk_cell_renderer_stop_editing()`.
    case editingCanceled = "editing-canceled"
    /// This signal gets emitted when a cell starts to be edited.
    /// The intended use of this signal is to do special setup
    /// on `editable`, e.g. adding a `GtkEntryCompletion` or setting
    /// up additional columns in a `GtkComboBox`.
    /// 
    /// See `gtk_cell_editable_start_editing()` for information on the lifecycle of
    /// the `editable` and a way to do setup that doesn’t depend on the `renderer`.
    /// 
    /// Note that GTK doesn't guarantee that cell renderers will
    /// continue to use the same kind of widget for editing in future
    /// releases, therefore you should check the type of `editable`
    /// before doing any specific setup, as in the following example:
    /// (C Language Example):
    /// ```C
    /// static void
    /// text_editing_started (GtkCellRenderer *cell,
    ///                       GtkCellEditable *editable,
    ///                       const char      *path,
    ///                       gpointer         data)
    /// {
    ///   if (GTK_IS_ENTRY (editable))
    ///     {
    ///       GtkEntry *entry = GTK_ENTRY (editable);
    ///       
    ///       // ... create a GtkEntryCompletion
    ///       
    ///       gtk_entry_set_completion (entry, completion);
    ///     }
    /// }
    /// ```
    /// 
    case editingStarted = "editing-started"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    /// The keyval of the accelerator.
    case notifyAccelKey = "notify::accel-key"
    /// Determines if the edited accelerators are GTK accelerators. If
    /// they are, consumed modifiers are suppressed, only accelerators
    /// accepted by GTK are allowed, and the accelerators are rendered
    /// in the same way as they are in menus.
    case notifyAccelMode = "notify::accel-mode"
    /// The modifier mask of the accelerator.
    case notifyAccelMods = "notify::accel-mods"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyAlignSet = "notify::align-set"
    /// Specifies how to align the lines of text with respect to each other.
    /// 
    /// Note that this property describes how to align the lines of text in
    /// case there are several of them. The "xalign" property of `GtkCellRenderer`,
    /// on the other hand, sets the horizontal alignment of the whole text.
    case notifyAlignment = "notify::alignment"
    case notifyAttributes = "notify::attributes"
    case notifyBackground = "notify::background"
    /// Background color as a `GdkRGBA`
    case notifyBackgroundRgba = "notify::background-rgba"
    case notifyBackgroundSet = "notify::background-set"
    case notifyCellBackground = "notify::cell-background"
    /// Cell background as a `GdkRGBA`
    case notifyCellBackgroundRgba = "notify::cell-background-rgba"
    case notifyCellBackgroundSet = "notify::cell-background-set"
    case notifyEditable = "notify::editable"
    case notifyEditableSet = "notify::editable-set"
    case notifyEditing = "notify::editing"
    /// Specifies the preferred place to ellipsize the string, if the cell renderer
    /// does not have enough room to display the entire string. Setting it to
    /// `PANGO_ELLIPSIZE_NONE` turns off ellipsizing. See the wrap-width property
    /// for another way of making the text fit into a given width.
    case notifyEllipsize = "notify::ellipsize"
    case notifyEllipsizeSet = "notify::ellipsize-set"
    case notifyFamily = "notify::family"
    case notifyFamilySet = "notify::family-set"
    case notifyFont = "notify::font"
    case notifyFontDesc = "notify::font-desc"
    case notifyForeground = "notify::foreground"
    /// Foreground color as a `GdkRGBA`
    case notifyForegroundRgba = "notify::foreground-rgba"
    case notifyForegroundSet = "notify::foreground-set"
    case notifyHeight = "notify::height"
    case notifyIsExpanded = "notify::is-expanded"
    case notifyIsExpander = "notify::is-expander"
    /// The hardware keycode of the accelerator. Note that the hardware keycode is
    /// only relevant if the key does not have a keyval. Normally, the keyboard
    /// configuration should assign keyvals to all keys.
    case notifyKeycode = "notify::keycode"
    case notifyLanguage = "notify::language"
    case notifyLanguageSet = "notify::language-set"
    case notifyMarkup = "notify::markup"
    /// The desired maximum width of the cell, in characters. If this property
    /// is set to -1, the width will be calculated automatically.
    /// 
    /// For cell renderers that ellipsize or wrap text; this property
    /// controls the maximum reported width of the cell. The
    /// cell should not receive any greater allocation unless it is
    /// set to expand in its `GtkCellLayout` and all of the cell's siblings
    /// have received their natural width.
    case notifyMaxWidthChars = "notify::max-width-chars"
    case notifyMode = "notify::mode"
    /// The text that will be displayed in the `GtkCellRenderer` if
    /// `GtkCellRendererText:editable` is `true` and the cell is empty.
    case notifyPlaceholderText = "notify::placeholder-text"
    case notifyRise = "notify::rise"
    case notifyRiseSet = "notify::rise-set"
    case notifyScale = "notify::scale"
    case notifyScaleSet = "notify::scale-set"
    case notifySensitive = "notify::sensitive"
    case notifySingleParagraphMode = "notify::single-paragraph-mode"
    case notifySize = "notify::size"
    case notifySizePoints = "notify::size-points"
    case notifySizeSet = "notify::size-set"
    case notifyStretch = "notify::stretch"
    case notifyStretchSet = "notify::stretch-set"
    case notifyStrikethrough = "notify::strikethrough"
    case notifyStrikethroughSet = "notify::strikethrough-set"
    case notifyStyle = "notify::style"
    case notifyStyleSet = "notify::style-set"
    case notifyText = "notify::text"
    case notifyUnderline = "notify::underline"
    case notifyUnderlineSet = "notify::underline-set"
    case notifyVariant = "notify::variant"
    case notifyVariantSet = "notify::variant-set"
    case notifyVisible = "notify::visible"
    case notifyWeight = "notify::weight"
    case notifyWeightSet = "notify::weight-set"
    case notifyWidth = "notify::width"
    /// The desired width of the cell, in characters. If this property is set to
    /// -1, the width will be calculated automatically, otherwise the cell will
    /// request either 3 characters or the property value, whichever is greater.
    case notifyWidthChars = "notify::width-chars"
    /// Specifies how to break the string into multiple lines, if the cell
    /// renderer does not have enough room to display the entire string.
    /// This property has no effect unless the wrap-width property is set.
    case notifyWrapMode = "notify::wrap-mode"
    /// Specifies the minimum width at which the text is wrapped. The wrap-mode property can
    /// be used to influence at what character positions the line breaks can be placed.
    /// Setting wrap-width to -1 turns wrapping off.
    case notifyWrapWidth = "notify::wrap-width"
    case notifyXalign = "notify::xalign"
    case notifyXpad = "notify::xpad"
    case notifyYalign = "notify::yalign"
    case notifyYpad = "notify::ypad"
}

public extension CellRendererAccelProtocol {
    /// Connect a `CellRendererAccelSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @inlinable @discardableResult func connect(signal kind: CellRendererAccelSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> Int {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> Int {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(raw: ptr).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

// MARK: CellRendererAccel Class: CellRendererAccelProtocol extension (methods and fields)
public extension CellRendererAccelProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellRendererAccel` instance.
    @inlinable var cell_renderer_accel_ptr: UnsafeMutablePointer<GtkCellRendererAccel>! { return ptr?.assumingMemoryBound(to: GtkCellRendererAccel.self) }



}



// MARK: - CellRendererCombo Class

/// The `CellRendererComboProtocol` protocol exposes the methods and properties of an underlying `GtkCellRendererCombo` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellRendererCombo`.
/// Alternatively, use `CellRendererComboRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkCellRendererCombo` renders text in a cell like `GtkCellRendererText` from
/// which it is derived. But while `GtkCellRendererText` offers a simple entry to
/// edit the text, `GtkCellRendererCombo` offers a `GtkComboBox`
/// widget to edit the text. The values to display in the combo box are taken from
/// the tree model specified in the `GtkCellRendererCombo:model` property.
/// 
/// The combo cell renderer takes care of adding a text cell renderer to the combo
/// box and sets it to display the column specified by its
/// `GtkCellRendererCombo:text`-column property. Further properties of the combo box
/// can be set in a handler for the `GtkCellRenderer::editing`-started signal.
public protocol CellRendererComboProtocol: CellRendererTextProtocol {
        /// Untyped pointer to the underlying `GtkCellRendererCombo` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellRendererCombo` instance.
    var cell_renderer_combo_ptr: UnsafeMutablePointer<GtkCellRendererCombo>! { get }

}

/// The `CellRendererComboRef` type acts as a lightweight Swift reference to an underlying `GtkCellRendererCombo` instance.
/// It exposes methods that can operate on this data type through `CellRendererComboProtocol` conformance.
/// Use `CellRendererComboRef` only as an `unowned` reference to an existing `GtkCellRendererCombo` instance.
///
/// `GtkCellRendererCombo` renders text in a cell like `GtkCellRendererText` from
/// which it is derived. But while `GtkCellRendererText` offers a simple entry to
/// edit the text, `GtkCellRendererCombo` offers a `GtkComboBox`
/// widget to edit the text. The values to display in the combo box are taken from
/// the tree model specified in the `GtkCellRendererCombo:model` property.
/// 
/// The combo cell renderer takes care of adding a text cell renderer to the combo
/// box and sets it to display the column specified by its
/// `GtkCellRendererCombo:text`-column property. Further properties of the combo box
/// can be set in a handler for the `GtkCellRenderer::editing`-started signal.
public struct CellRendererComboRef: CellRendererComboProtocol {
        /// Untyped pointer to the underlying `GtkCellRendererCombo` instance.
    /// For type-safe access, use the generated, typed pointer `cell_renderer_combo_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellRendererComboRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellRendererCombo>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellRendererCombo>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellRendererCombo>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellRendererCombo>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellRendererComboProtocol`
    @inlinable init<T: CellRendererComboProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCellRendererCombo`.
    /// Adjust how text is drawn using object properties.
    /// Object properties can be set globally (with `g_object_set()`).
    /// Also, with `GtkTreeViewColumn`, you can bind a property to a value
    /// in a `GtkTreeModel`. For example, you can bind the “text” property
    /// on the cell renderer to a string value in the model, thus rendering
    /// a different string in each row of the `GtkTreeView`.
    @inlinable init() {
        let rv = gtk_cell_renderer_combo_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `CellRendererCombo` type acts as a reference-counted owner of an underlying `GtkCellRendererCombo` instance.
/// It provides the methods that can operate on this data type through `CellRendererComboProtocol` conformance.
/// Use `CellRendererCombo` as a strong reference or owner of a `GtkCellRendererCombo` instance.
///
/// `GtkCellRendererCombo` renders text in a cell like `GtkCellRendererText` from
/// which it is derived. But while `GtkCellRendererText` offers a simple entry to
/// edit the text, `GtkCellRendererCombo` offers a `GtkComboBox`
/// widget to edit the text. The values to display in the combo box are taken from
/// the tree model specified in the `GtkCellRendererCombo:model` property.
/// 
/// The combo cell renderer takes care of adding a text cell renderer to the combo
/// box and sets it to display the column specified by its
/// `GtkCellRendererCombo:text`-column property. Further properties of the combo box
/// can be set in a handler for the `GtkCellRenderer::editing`-started signal.
open class CellRendererCombo: CellRendererText, CellRendererComboProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererCombo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCellRendererCombo>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererCombo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCellRendererCombo>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererCombo` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererCombo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererCombo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCellRendererCombo>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererCombo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCellRendererCombo>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCellRendererCombo`.
    /// i.e., ownership is transferred to the `CellRendererCombo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCellRendererCombo>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CellRendererComboProtocol`
    /// Will retain `GtkCellRendererCombo`.
    /// - Parameter other: an instance of a related type that implements `CellRendererComboProtocol`
    @inlinable public init<T: CellRendererComboProtocol>(cellRendererCombo other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkCellRendererCombo`.
    /// Adjust how text is drawn using object properties.
    /// Object properties can be set globally (with `g_object_set()`).
    /// Also, with `GtkTreeViewColumn`, you can bind a property to a value
    /// in a `GtkTreeModel`. For example, you can bind the “text” property
    /// on the cell renderer to a string value in the model, thus rendering
    /// a different string in each row of the `GtkTreeView`.
    @inlinable override public init() {
        let rv = gtk_cell_renderer_combo_new()
        super.init(gpointer: gpointer(rv))
    }


}

public enum CellRendererComboPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case alignSet = "align-set"
    /// Specifies how to align the lines of text with respect to each other.
    /// 
    /// Note that this property describes how to align the lines of text in
    /// case there are several of them. The "xalign" property of `GtkCellRenderer`,
    /// on the other hand, sets the horizontal alignment of the whole text.
    case alignment = "alignment"
    case attributes = "attributes"
    case background = "background"
    /// Background color as a `GdkRGBA`
    case backgroundRgba = "background-rgba"
    case backgroundSet = "background-set"
    case cellBackground = "cell-background"
    /// Cell background as a `GdkRGBA`
    case cellBackgroundRgba = "cell-background-rgba"
    case cellBackgroundSet = "cell-background-set"
    case editable = "editable"
    case editableSet = "editable-set"
    case editing = "editing"
    /// Specifies the preferred place to ellipsize the string, if the cell renderer
    /// does not have enough room to display the entire string. Setting it to
    /// `PANGO_ELLIPSIZE_NONE` turns off ellipsizing. See the wrap-width property
    /// for another way of making the text fit into a given width.
    case ellipsize = "ellipsize"
    case ellipsizeSet = "ellipsize-set"
    case family = "family"
    case familySet = "family-set"
    case font = "font"
    case fontDesc = "font-desc"
    case foreground = "foreground"
    /// Foreground color as a `GdkRGBA`
    case foregroundRgba = "foreground-rgba"
    case foregroundSet = "foreground-set"
    /// If `true`, the cell renderer will include an entry and allow to enter
    /// values other than the ones in the popup list.
    case hasEntry = "has-entry"
    case height = "height"
    case isExpanded = "is-expanded"
    case isExpander = "is-expander"
    case language = "language"
    case languageSet = "language-set"
    case markup = "markup"
    /// The desired maximum width of the cell, in characters. If this property
    /// is set to -1, the width will be calculated automatically.
    /// 
    /// For cell renderers that ellipsize or wrap text; this property
    /// controls the maximum reported width of the cell. The
    /// cell should not receive any greater allocation unless it is
    /// set to expand in its `GtkCellLayout` and all of the cell's siblings
    /// have received their natural width.
    case maxWidthChars = "max-width-chars"
    case mode = "mode"
    /// Holds a tree model containing the possible values for the combo box.
    /// Use the text_column property to specify the column holding the values.
    case model = "model"
    /// The text that will be displayed in the `GtkCellRenderer` if
    /// `GtkCellRendererText:editable` is `true` and the cell is empty.
    case placeholderText = "placeholder-text"
    case rise = "rise"
    case riseSet = "rise-set"
    case scale = "scale"
    case scaleSet = "scale-set"
    case sensitive = "sensitive"
    case singleParagraphMode = "single-paragraph-mode"
    case size = "size"
    case sizePoints = "size-points"
    case sizeSet = "size-set"
    case stretch = "stretch"
    case stretchSet = "stretch-set"
    case strikethrough = "strikethrough"
    case strikethroughSet = "strikethrough-set"
    case style = "style"
    case styleSet = "style-set"
    case text = "text"
    /// Specifies the model column which holds the possible values for the
    /// combo box.
    /// 
    /// Note that this refers to the model specified in the model property,
    /// not the model backing the tree view to which
    /// this cell renderer is attached.
    /// 
    /// `GtkCellRendererCombo` automatically adds a text cell renderer for
    /// this column to its combo box.
    case textColumn = "text-column"
    case underline = "underline"
    case underlineSet = "underline-set"
    case variant = "variant"
    case variantSet = "variant-set"
    case visible = "visible"
    case weight = "weight"
    case weightSet = "weight-set"
    case width = "width"
    /// The desired width of the cell, in characters. If this property is set to
    /// -1, the width will be calculated automatically, otherwise the cell will
    /// request either 3 characters or the property value, whichever is greater.
    case widthChars = "width-chars"
    /// Specifies how to break the string into multiple lines, if the cell
    /// renderer does not have enough room to display the entire string.
    /// This property has no effect unless the wrap-width property is set.
    case wrapMode = "wrap-mode"
    /// Specifies the minimum width at which the text is wrapped. The wrap-mode property can
    /// be used to influence at what character positions the line breaks can be placed.
    /// Setting wrap-width to -1 turns wrapping off.
    case wrapWidth = "wrap-width"
    case xalign = "xalign"
    case xpad = "xpad"
    case yalign = "yalign"
    case ypad = "ypad"
}

public extension CellRendererComboProtocol {
    /// Bind a `CellRendererComboPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellRendererComboPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CellRendererCombo property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CellRendererComboPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CellRendererCombo property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CellRendererComboPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CellRendererComboSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// This signal is emitted each time after the user selected an item in
    /// the combo box, either by using the mouse or the arrow keys.  Contrary
    /// to GtkComboBox, GtkCellRendererCombo`changed` is not emitted for
    /// changes made to a selected item in the entry.  The argument `new_iter`
    /// corresponds to the newly selected item in the combo box and it is relative
    /// to the GtkTreeModel set via the model property on GtkCellRendererCombo.
    /// 
    /// Note that as soon as you change the model displayed in the tree view,
    /// the tree view will immediately cease the editing operating.  This
    /// means that you most probably want to refrain from changing the model
    /// until the combo cell renderer emits the edited or editing_canceled signal.
    case changed = "changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// This signal is emitted after `renderer` has been edited.
    /// 
    /// It is the responsibility of the application to update the model
    /// and store `new_text` at the position indicated by `path`.
    case edited = "edited"
    /// This signal gets emitted when the user cancels the process of editing a
    /// cell.  For example, an editable cell renderer could be written to cancel
    /// editing when the user presses Escape.
    /// 
    /// See also: `gtk_cell_renderer_stop_editing()`.
    case editingCanceled = "editing-canceled"
    /// This signal gets emitted when a cell starts to be edited.
    /// The intended use of this signal is to do special setup
    /// on `editable`, e.g. adding a `GtkEntryCompletion` or setting
    /// up additional columns in a `GtkComboBox`.
    /// 
    /// See `gtk_cell_editable_start_editing()` for information on the lifecycle of
    /// the `editable` and a way to do setup that doesn’t depend on the `renderer`.
    /// 
    /// Note that GTK doesn't guarantee that cell renderers will
    /// continue to use the same kind of widget for editing in future
    /// releases, therefore you should check the type of `editable`
    /// before doing any specific setup, as in the following example:
    /// (C Language Example):
    /// ```C
    /// static void
    /// text_editing_started (GtkCellRenderer *cell,
    ///                       GtkCellEditable *editable,
    ///                       const char      *path,
    ///                       gpointer         data)
    /// {
    ///   if (GTK_IS_ENTRY (editable))
    ///     {
    ///       GtkEntry *entry = GTK_ENTRY (editable);
    ///       
    ///       // ... create a GtkEntryCompletion
    ///       
    ///       gtk_entry_set_completion (entry, completion);
    ///     }
    /// }
    /// ```
    /// 
    case editingStarted = "editing-started"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyAlignSet = "notify::align-set"
    /// Specifies how to align the lines of text with respect to each other.
    /// 
    /// Note that this property describes how to align the lines of text in
    /// case there are several of them. The "xalign" property of `GtkCellRenderer`,
    /// on the other hand, sets the horizontal alignment of the whole text.
    case notifyAlignment = "notify::alignment"
    case notifyAttributes = "notify::attributes"
    case notifyBackground = "notify::background"
    /// Background color as a `GdkRGBA`
    case notifyBackgroundRgba = "notify::background-rgba"
    case notifyBackgroundSet = "notify::background-set"
    case notifyCellBackground = "notify::cell-background"
    /// Cell background as a `GdkRGBA`
    case notifyCellBackgroundRgba = "notify::cell-background-rgba"
    case notifyCellBackgroundSet = "notify::cell-background-set"
    case notifyEditable = "notify::editable"
    case notifyEditableSet = "notify::editable-set"
    case notifyEditing = "notify::editing"
    /// Specifies the preferred place to ellipsize the string, if the cell renderer
    /// does not have enough room to display the entire string. Setting it to
    /// `PANGO_ELLIPSIZE_NONE` turns off ellipsizing. See the wrap-width property
    /// for another way of making the text fit into a given width.
    case notifyEllipsize = "notify::ellipsize"
    case notifyEllipsizeSet = "notify::ellipsize-set"
    case notifyFamily = "notify::family"
    case notifyFamilySet = "notify::family-set"
    case notifyFont = "notify::font"
    case notifyFontDesc = "notify::font-desc"
    case notifyForeground = "notify::foreground"
    /// Foreground color as a `GdkRGBA`
    case notifyForegroundRgba = "notify::foreground-rgba"
    case notifyForegroundSet = "notify::foreground-set"
    /// If `true`, the cell renderer will include an entry and allow to enter
    /// values other than the ones in the popup list.
    case notifyHasEntry = "notify::has-entry"
    case notifyHeight = "notify::height"
    case notifyIsExpanded = "notify::is-expanded"
    case notifyIsExpander = "notify::is-expander"
    case notifyLanguage = "notify::language"
    case notifyLanguageSet = "notify::language-set"
    case notifyMarkup = "notify::markup"
    /// The desired maximum width of the cell, in characters. If this property
    /// is set to -1, the width will be calculated automatically.
    /// 
    /// For cell renderers that ellipsize or wrap text; this property
    /// controls the maximum reported width of the cell. The
    /// cell should not receive any greater allocation unless it is
    /// set to expand in its `GtkCellLayout` and all of the cell's siblings
    /// have received their natural width.
    case notifyMaxWidthChars = "notify::max-width-chars"
    case notifyMode = "notify::mode"
    /// Holds a tree model containing the possible values for the combo box.
    /// Use the text_column property to specify the column holding the values.
    case notifyModel = "notify::model"
    /// The text that will be displayed in the `GtkCellRenderer` if
    /// `GtkCellRendererText:editable` is `true` and the cell is empty.
    case notifyPlaceholderText = "notify::placeholder-text"
    case notifyRise = "notify::rise"
    case notifyRiseSet = "notify::rise-set"
    case notifyScale = "notify::scale"
    case notifyScaleSet = "notify::scale-set"
    case notifySensitive = "notify::sensitive"
    case notifySingleParagraphMode = "notify::single-paragraph-mode"
    case notifySize = "notify::size"
    case notifySizePoints = "notify::size-points"
    case notifySizeSet = "notify::size-set"
    case notifyStretch = "notify::stretch"
    case notifyStretchSet = "notify::stretch-set"
    case notifyStrikethrough = "notify::strikethrough"
    case notifyStrikethroughSet = "notify::strikethrough-set"
    case notifyStyle = "notify::style"
    case notifyStyleSet = "notify::style-set"
    case notifyText = "notify::text"
    /// Specifies the model column which holds the possible values for the
    /// combo box.
    /// 
    /// Note that this refers to the model specified in the model property,
    /// not the model backing the tree view to which
    /// this cell renderer is attached.
    /// 
    /// `GtkCellRendererCombo` automatically adds a text cell renderer for
    /// this column to its combo box.
    case notifyTextColumn = "notify::text-column"
    case notifyUnderline = "notify::underline"
    case notifyUnderlineSet = "notify::underline-set"
    case notifyVariant = "notify::variant"
    case notifyVariantSet = "notify::variant-set"
    case notifyVisible = "notify::visible"
    case notifyWeight = "notify::weight"
    case notifyWeightSet = "notify::weight-set"
    case notifyWidth = "notify::width"
    /// The desired width of the cell, in characters. If this property is set to
    /// -1, the width will be calculated automatically, otherwise the cell will
    /// request either 3 characters or the property value, whichever is greater.
    case notifyWidthChars = "notify::width-chars"
    /// Specifies how to break the string into multiple lines, if the cell
    /// renderer does not have enough room to display the entire string.
    /// This property has no effect unless the wrap-width property is set.
    case notifyWrapMode = "notify::wrap-mode"
    /// Specifies the minimum width at which the text is wrapped. The wrap-mode property can
    /// be used to influence at what character positions the line breaks can be placed.
    /// Setting wrap-width to -1 turns wrapping off.
    case notifyWrapWidth = "notify::wrap-width"
    case notifyXalign = "notify::xalign"
    case notifyXpad = "notify::xpad"
    case notifyYalign = "notify::yalign"
    case notifyYpad = "notify::ypad"
}

public extension CellRendererComboProtocol {
    /// Connect a `CellRendererComboSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @inlinable @discardableResult func connect(signal kind: CellRendererComboSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> Int {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> Int {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(raw: ptr).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

// MARK: CellRendererCombo Class: CellRendererComboProtocol extension (methods and fields)
public extension CellRendererComboProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellRendererCombo` instance.
    @inlinable var cell_renderer_combo_ptr: UnsafeMutablePointer<GtkCellRendererCombo>! { return ptr?.assumingMemoryBound(to: GtkCellRendererCombo.self) }



}



// MARK: - CellRendererPixbuf Class

/// The `CellRendererPixbufProtocol` protocol exposes the methods and properties of an underlying `GtkCellRendererPixbuf` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellRendererPixbuf`.
/// Alternatively, use `CellRendererPixbufRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A `GtkCellRendererPixbuf` can be used to render an image in a cell. It allows
/// to render either a given `GdkPixbuf` (set via the
/// `GtkCellRendererPixbuf:pixbuf` property) or a named icon (set via the
/// `GtkCellRendererPixbuf:icon`-name property).
/// 
/// To support the tree view, `GtkCellRendererPixbuf` also supports rendering two
/// alternative pixbufs, when the `GtkCellRenderer:is`-expander property is `true`.
/// If the `GtkCellRenderer:is`-expanded property is `true` and the
/// `GtkCellRendererPixbuf:pixbuf`-expander-open property is set to a pixbuf, it
/// renders that pixbuf, if the `GtkCellRenderer:is`-expanded property is `false`
/// and the `GtkCellRendererPixbuf:pixbuf`-expander-closed property is set to a
/// pixbuf, it renders that one.
public protocol CellRendererPixbufProtocol: CellRendererProtocol {
        /// Untyped pointer to the underlying `GtkCellRendererPixbuf` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellRendererPixbuf` instance.
    var cell_renderer_pixbuf_ptr: UnsafeMutablePointer<GtkCellRendererPixbuf>! { get }

}

/// The `CellRendererPixbufRef` type acts as a lightweight Swift reference to an underlying `GtkCellRendererPixbuf` instance.
/// It exposes methods that can operate on this data type through `CellRendererPixbufProtocol` conformance.
/// Use `CellRendererPixbufRef` only as an `unowned` reference to an existing `GtkCellRendererPixbuf` instance.
///
/// A `GtkCellRendererPixbuf` can be used to render an image in a cell. It allows
/// to render either a given `GdkPixbuf` (set via the
/// `GtkCellRendererPixbuf:pixbuf` property) or a named icon (set via the
/// `GtkCellRendererPixbuf:icon`-name property).
/// 
/// To support the tree view, `GtkCellRendererPixbuf` also supports rendering two
/// alternative pixbufs, when the `GtkCellRenderer:is`-expander property is `true`.
/// If the `GtkCellRenderer:is`-expanded property is `true` and the
/// `GtkCellRendererPixbuf:pixbuf`-expander-open property is set to a pixbuf, it
/// renders that pixbuf, if the `GtkCellRenderer:is`-expanded property is `false`
/// and the `GtkCellRendererPixbuf:pixbuf`-expander-closed property is set to a
/// pixbuf, it renders that one.
public struct CellRendererPixbufRef: CellRendererPixbufProtocol {
        /// Untyped pointer to the underlying `GtkCellRendererPixbuf` instance.
    /// For type-safe access, use the generated, typed pointer `cell_renderer_pixbuf_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellRendererPixbufRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellRendererPixbuf>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellRendererPixbuf>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellRendererPixbuf>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellRendererPixbuf>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellRendererPixbufProtocol`
    @inlinable init<T: CellRendererPixbufProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCellRendererPixbuf`. Adjust rendering
    /// parameters using object properties. Object properties can be set
    /// globally (with `g_object_set()`). Also, with `GtkTreeViewColumn`, you
    /// can bind a property to a value in a `GtkTreeModel`. For example, you
    /// can bind the “pixbuf” property on the cell renderer to a pixbuf value
    /// in the model, thus rendering a different image in each row of the
    /// `GtkTreeView`.
    @inlinable init() {
        let rv = gtk_cell_renderer_pixbuf_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `CellRendererPixbuf` type acts as a reference-counted owner of an underlying `GtkCellRendererPixbuf` instance.
/// It provides the methods that can operate on this data type through `CellRendererPixbufProtocol` conformance.
/// Use `CellRendererPixbuf` as a strong reference or owner of a `GtkCellRendererPixbuf` instance.
///
/// A `GtkCellRendererPixbuf` can be used to render an image in a cell. It allows
/// to render either a given `GdkPixbuf` (set via the
/// `GtkCellRendererPixbuf:pixbuf` property) or a named icon (set via the
/// `GtkCellRendererPixbuf:icon`-name property).
/// 
/// To support the tree view, `GtkCellRendererPixbuf` also supports rendering two
/// alternative pixbufs, when the `GtkCellRenderer:is`-expander property is `true`.
/// If the `GtkCellRenderer:is`-expanded property is `true` and the
/// `GtkCellRendererPixbuf:pixbuf`-expander-open property is set to a pixbuf, it
/// renders that pixbuf, if the `GtkCellRenderer:is`-expanded property is `false`
/// and the `GtkCellRendererPixbuf:pixbuf`-expander-closed property is set to a
/// pixbuf, it renders that one.
open class CellRendererPixbuf: CellRenderer, CellRendererPixbufProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererPixbuf` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCellRendererPixbuf>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererPixbuf` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCellRendererPixbuf>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererPixbuf` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererPixbuf` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererPixbuf` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCellRendererPixbuf>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererPixbuf` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCellRendererPixbuf>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCellRendererPixbuf`.
    /// i.e., ownership is transferred to the `CellRendererPixbuf` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCellRendererPixbuf>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CellRendererPixbufProtocol`
    /// Will retain `GtkCellRendererPixbuf`.
    /// - Parameter other: an instance of a related type that implements `CellRendererPixbufProtocol`
    @inlinable public init<T: CellRendererPixbufProtocol>(cellRendererPixbuf other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkCellRendererPixbuf`. Adjust rendering
    /// parameters using object properties. Object properties can be set
    /// globally (with `g_object_set()`). Also, with `GtkTreeViewColumn`, you
    /// can bind a property to a value in a `GtkTreeModel`. For example, you
    /// can bind the “pixbuf” property on the cell renderer to a pixbuf value
    /// in the model, thus rendering a different image in each row of the
    /// `GtkTreeView`.
    @inlinable public init() {
        let rv = gtk_cell_renderer_pixbuf_new()
        super.init(gpointer: gpointer(rv))
    }


}

public enum CellRendererPixbufPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case cellBackground = "cell-background"
    /// Cell background as a `GdkRGBA`
    case cellBackgroundRgba = "cell-background-rgba"
    case cellBackgroundSet = "cell-background-set"
    case editing = "editing"
    /// The GIcon representing the icon to display.
    /// If the icon theme is changed, the image will be updated
    /// automatically.
    case gicon = "gicon"
    case height = "height"
    /// The name of the themed icon to display.
    /// This property only has an effect if not overridden by the "pixbuf" property.
    case iconName = "icon-name"
    /// The `GtkIconSize` value that specifies the size of the rendered icon.
    case iconSize = "icon-size"
    case isExpanded = "is-expanded"
    case isExpander = "is-expander"
    case mode = "mode"
    case pixbuf = "pixbuf"
    case pixbufExpanderClosed = "pixbuf-expander-closed"
    case pixbufExpanderOpen = "pixbuf-expander-open"
    case sensitive = "sensitive"
    case texture = "texture"
    case visible = "visible"
    case width = "width"
    case xalign = "xalign"
    case xpad = "xpad"
    case yalign = "yalign"
    case ypad = "ypad"
}

public extension CellRendererPixbufProtocol {
    /// Bind a `CellRendererPixbufPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellRendererPixbufPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CellRendererPixbuf property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CellRendererPixbufPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CellRendererPixbuf property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CellRendererPixbufPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CellRendererPixbufSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// This signal gets emitted when the user cancels the process of editing a
    /// cell.  For example, an editable cell renderer could be written to cancel
    /// editing when the user presses Escape.
    /// 
    /// See also: `gtk_cell_renderer_stop_editing()`.
    case editingCanceled = "editing-canceled"
    /// This signal gets emitted when a cell starts to be edited.
    /// The intended use of this signal is to do special setup
    /// on `editable`, e.g. adding a `GtkEntryCompletion` or setting
    /// up additional columns in a `GtkComboBox`.
    /// 
    /// See `gtk_cell_editable_start_editing()` for information on the lifecycle of
    /// the `editable` and a way to do setup that doesn’t depend on the `renderer`.
    /// 
    /// Note that GTK doesn't guarantee that cell renderers will
    /// continue to use the same kind of widget for editing in future
    /// releases, therefore you should check the type of `editable`
    /// before doing any specific setup, as in the following example:
    /// (C Language Example):
    /// ```C
    /// static void
    /// text_editing_started (GtkCellRenderer *cell,
    ///                       GtkCellEditable *editable,
    ///                       const char      *path,
    ///                       gpointer         data)
    /// {
    ///   if (GTK_IS_ENTRY (editable))
    ///     {
    ///       GtkEntry *entry = GTK_ENTRY (editable);
    ///       
    ///       // ... create a GtkEntryCompletion
    ///       
    ///       gtk_entry_set_completion (entry, completion);
    ///     }
    /// }
    /// ```
    /// 
    case editingStarted = "editing-started"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyCellBackground = "notify::cell-background"
    /// Cell background as a `GdkRGBA`
    case notifyCellBackgroundRgba = "notify::cell-background-rgba"
    case notifyCellBackgroundSet = "notify::cell-background-set"
    case notifyEditing = "notify::editing"
    /// The GIcon representing the icon to display.
    /// If the icon theme is changed, the image will be updated
    /// automatically.
    case notifyGicon = "notify::gicon"
    case notifyHeight = "notify::height"
    /// The name of the themed icon to display.
    /// This property only has an effect if not overridden by the "pixbuf" property.
    case notifyIconName = "notify::icon-name"
    /// The `GtkIconSize` value that specifies the size of the rendered icon.
    case notifyIconSize = "notify::icon-size"
    case notifyIsExpanded = "notify::is-expanded"
    case notifyIsExpander = "notify::is-expander"
    case notifyMode = "notify::mode"
    case notifyPixbuf = "notify::pixbuf"
    case notifyPixbufExpanderClosed = "notify::pixbuf-expander-closed"
    case notifyPixbufExpanderOpen = "notify::pixbuf-expander-open"
    case notifySensitive = "notify::sensitive"
    case notifyTexture = "notify::texture"
    case notifyVisible = "notify::visible"
    case notifyWidth = "notify::width"
    case notifyXalign = "notify::xalign"
    case notifyXpad = "notify::xpad"
    case notifyYalign = "notify::yalign"
    case notifyYpad = "notify::ypad"
}

public extension CellRendererPixbufProtocol {
    /// Connect a `CellRendererPixbufSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @inlinable @discardableResult func connect(signal kind: CellRendererPixbufSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> Int {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> Int {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(raw: ptr).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

// MARK: CellRendererPixbuf Class: CellRendererPixbufProtocol extension (methods and fields)
public extension CellRendererPixbufProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellRendererPixbuf` instance.
    @inlinable var cell_renderer_pixbuf_ptr: UnsafeMutablePointer<GtkCellRendererPixbuf>! { return ptr?.assumingMemoryBound(to: GtkCellRendererPixbuf.self) }



}



// MARK: - CellRendererProgress Class

/// The `CellRendererProgressProtocol` protocol exposes the methods and properties of an underlying `GtkCellRendererProgress` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellRendererProgress`.
/// Alternatively, use `CellRendererProgressRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkCellRendererProgress` renders a numeric value as a progress par in a cell.
/// Additionally, it can display a text on top of the progress bar.
public protocol CellRendererProgressProtocol: CellRendererProtocol, OrientableProtocol {
        /// Untyped pointer to the underlying `GtkCellRendererProgress` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellRendererProgress` instance.
    var cell_renderer_progress_ptr: UnsafeMutablePointer<GtkCellRendererProgress>! { get }

}

/// The `CellRendererProgressRef` type acts as a lightweight Swift reference to an underlying `GtkCellRendererProgress` instance.
/// It exposes methods that can operate on this data type through `CellRendererProgressProtocol` conformance.
/// Use `CellRendererProgressRef` only as an `unowned` reference to an existing `GtkCellRendererProgress` instance.
///
/// `GtkCellRendererProgress` renders a numeric value as a progress par in a cell.
/// Additionally, it can display a text on top of the progress bar.
public struct CellRendererProgressRef: CellRendererProgressProtocol {
        /// Untyped pointer to the underlying `GtkCellRendererProgress` instance.
    /// For type-safe access, use the generated, typed pointer `cell_renderer_progress_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellRendererProgressRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellRendererProgress>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellRendererProgress>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellRendererProgress>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellRendererProgress>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellRendererProgressProtocol`
    @inlinable init<T: CellRendererProgressProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCellRendererProgress`.
    @inlinable init() {
        let rv = gtk_cell_renderer_progress_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `CellRendererProgress` type acts as a reference-counted owner of an underlying `GtkCellRendererProgress` instance.
/// It provides the methods that can operate on this data type through `CellRendererProgressProtocol` conformance.
/// Use `CellRendererProgress` as a strong reference or owner of a `GtkCellRendererProgress` instance.
///
/// `GtkCellRendererProgress` renders a numeric value as a progress par in a cell.
/// Additionally, it can display a text on top of the progress bar.
open class CellRendererProgress: CellRenderer, CellRendererProgressProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererProgress` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCellRendererProgress>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererProgress` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCellRendererProgress>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererProgress` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererProgress` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererProgress` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCellRendererProgress>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererProgress` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCellRendererProgress>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCellRendererProgress`.
    /// i.e., ownership is transferred to the `CellRendererProgress` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCellRendererProgress>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CellRendererProgressProtocol`
    /// Will retain `GtkCellRendererProgress`.
    /// - Parameter other: an instance of a related type that implements `CellRendererProgressProtocol`
    @inlinable public init<T: CellRendererProgressProtocol>(cellRendererProgress other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkCellRendererProgress`.
    @inlinable public init() {
        let rv = gtk_cell_renderer_progress_new()
        super.init(gpointer: gpointer(rv))
    }


}

public enum CellRendererProgressPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case cellBackground = "cell-background"
    /// Cell background as a `GdkRGBA`
    case cellBackgroundRgba = "cell-background-rgba"
    case cellBackgroundSet = "cell-background-set"
    case editing = "editing"
    case height = "height"
    case inverted = "inverted"
    case isExpanded = "is-expanded"
    case isExpander = "is-expander"
    case mode = "mode"
    /// Setting this to a non-negative value causes the cell renderer to
    /// enter "activity mode", where a block bounces back and forth to
    /// indicate that some progress is made, without specifying exactly how
    /// much.
    /// 
    /// Each increment of the property causes the block to move by a little
    /// bit.
    /// 
    /// To indicate that the activity has not started yet, set the property
    /// to zero. To indicate completion, set the property to `G_MAXINT`.
    case pulse = "pulse"
    case sensitive = "sensitive"
    /// The "text" property determines the label which will be drawn
    /// over the progress bar. Setting this property to `nil` causes the default
    /// label to be displayed. Setting this property to an empty string causes
    /// no label to be displayed.
    case text = "text"
    /// The "text-xalign" property controls the horizontal alignment of the
    /// text in the progress bar.  Valid values range from 0 (left) to 1
    /// (right).  Reserved for RTL layouts.
    case textXalign = "text-xalign"
    /// The "text-yalign" property controls the vertical alignment of the
    /// text in the progress bar.  Valid values range from 0 (top) to 1
    /// (bottom).
    case textYalign = "text-yalign"
    /// The "value" property determines the percentage to which the
    /// progress bar will be "filled in".
    case value = "value"
    case visible = "visible"
    case width = "width"
    case xalign = "xalign"
    case xpad = "xpad"
    case yalign = "yalign"
    case ypad = "ypad"
}

public extension CellRendererProgressProtocol {
    /// Bind a `CellRendererProgressPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellRendererProgressPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CellRendererProgress property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CellRendererProgressPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CellRendererProgress property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CellRendererProgressPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CellRendererProgressSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// This signal gets emitted when the user cancels the process of editing a
    /// cell.  For example, an editable cell renderer could be written to cancel
    /// editing when the user presses Escape.
    /// 
    /// See also: `gtk_cell_renderer_stop_editing()`.
    case editingCanceled = "editing-canceled"
    /// This signal gets emitted when a cell starts to be edited.
    /// The intended use of this signal is to do special setup
    /// on `editable`, e.g. adding a `GtkEntryCompletion` or setting
    /// up additional columns in a `GtkComboBox`.
    /// 
    /// See `gtk_cell_editable_start_editing()` for information on the lifecycle of
    /// the `editable` and a way to do setup that doesn’t depend on the `renderer`.
    /// 
    /// Note that GTK doesn't guarantee that cell renderers will
    /// continue to use the same kind of widget for editing in future
    /// releases, therefore you should check the type of `editable`
    /// before doing any specific setup, as in the following example:
    /// (C Language Example):
    /// ```C
    /// static void
    /// text_editing_started (GtkCellRenderer *cell,
    ///                       GtkCellEditable *editable,
    ///                       const char      *path,
    ///                       gpointer         data)
    /// {
    ///   if (GTK_IS_ENTRY (editable))
    ///     {
    ///       GtkEntry *entry = GTK_ENTRY (editable);
    ///       
    ///       // ... create a GtkEntryCompletion
    ///       
    ///       gtk_entry_set_completion (entry, completion);
    ///     }
    /// }
    /// ```
    /// 
    case editingStarted = "editing-started"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyCellBackground = "notify::cell-background"
    /// Cell background as a `GdkRGBA`
    case notifyCellBackgroundRgba = "notify::cell-background-rgba"
    case notifyCellBackgroundSet = "notify::cell-background-set"
    case notifyEditing = "notify::editing"
    case notifyHeight = "notify::height"
    case notifyInverted = "notify::inverted"
    case notifyIsExpanded = "notify::is-expanded"
    case notifyIsExpander = "notify::is-expander"
    case notifyMode = "notify::mode"
    /// Setting this to a non-negative value causes the cell renderer to
    /// enter "activity mode", where a block bounces back and forth to
    /// indicate that some progress is made, without specifying exactly how
    /// much.
    /// 
    /// Each increment of the property causes the block to move by a little
    /// bit.
    /// 
    /// To indicate that the activity has not started yet, set the property
    /// to zero. To indicate completion, set the property to `G_MAXINT`.
    case notifyPulse = "notify::pulse"
    case notifySensitive = "notify::sensitive"
    /// The "text" property determines the label which will be drawn
    /// over the progress bar. Setting this property to `nil` causes the default
    /// label to be displayed. Setting this property to an empty string causes
    /// no label to be displayed.
    case notifyText = "notify::text"
    /// The "text-xalign" property controls the horizontal alignment of the
    /// text in the progress bar.  Valid values range from 0 (left) to 1
    /// (right).  Reserved for RTL layouts.
    case notifyTextXalign = "notify::text-xalign"
    /// The "text-yalign" property controls the vertical alignment of the
    /// text in the progress bar.  Valid values range from 0 (top) to 1
    /// (bottom).
    case notifyTextYalign = "notify::text-yalign"
    /// The "value" property determines the percentage to which the
    /// progress bar will be "filled in".
    case notifyValue = "notify::value"
    case notifyVisible = "notify::visible"
    case notifyWidth = "notify::width"
    case notifyXalign = "notify::xalign"
    case notifyXpad = "notify::xpad"
    case notifyYalign = "notify::yalign"
    case notifyYpad = "notify::ypad"
}

public extension CellRendererProgressProtocol {
    /// Connect a `CellRendererProgressSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @inlinable @discardableResult func connect(signal kind: CellRendererProgressSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> Int {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> Int {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(raw: ptr).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

// MARK: CellRendererProgress Class: CellRendererProgressProtocol extension (methods and fields)
public extension CellRendererProgressProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellRendererProgress` instance.
    @inlinable var cell_renderer_progress_ptr: UnsafeMutablePointer<GtkCellRendererProgress>! { return ptr?.assumingMemoryBound(to: GtkCellRendererProgress.self) }



}



// MARK: - CellRendererSpin Class

/// The `CellRendererSpinProtocol` protocol exposes the methods and properties of an underlying `GtkCellRendererSpin` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellRendererSpin`.
/// Alternatively, use `CellRendererSpinRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkCellRendererSpin` renders text in a cell like `GtkCellRendererText` from
/// which it is derived. But while `GtkCellRendererText` offers a simple entry to
/// edit the text, `GtkCellRendererSpin` offers a `GtkSpinButton` widget. Of course,
/// that means that the text has to be parseable as a floating point number.
/// 
/// The range of the spinbutton is taken from the adjustment property of the
/// cell renderer, which can be set explicitly or mapped to a column in the
/// tree model, like all properties of cell renders. `GtkCellRendererSpin`
/// also has properties for the `GtkCellRendererSpin:climb`-rate and the number
/// of `GtkCellRendererSpin:digits` to display. Other `GtkSpinButton` properties
/// can be set in a handler for the `GtkCellRenderer::editing`-started signal.
/// 
/// The `GtkCellRendererSpin` cell renderer was added in GTK 2.10.
public protocol CellRendererSpinProtocol: CellRendererTextProtocol {
        /// Untyped pointer to the underlying `GtkCellRendererSpin` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellRendererSpin` instance.
    var cell_renderer_spin_ptr: UnsafeMutablePointer<GtkCellRendererSpin>! { get }

}

/// The `CellRendererSpinRef` type acts as a lightweight Swift reference to an underlying `GtkCellRendererSpin` instance.
/// It exposes methods that can operate on this data type through `CellRendererSpinProtocol` conformance.
/// Use `CellRendererSpinRef` only as an `unowned` reference to an existing `GtkCellRendererSpin` instance.
///
/// `GtkCellRendererSpin` renders text in a cell like `GtkCellRendererText` from
/// which it is derived. But while `GtkCellRendererText` offers a simple entry to
/// edit the text, `GtkCellRendererSpin` offers a `GtkSpinButton` widget. Of course,
/// that means that the text has to be parseable as a floating point number.
/// 
/// The range of the spinbutton is taken from the adjustment property of the
/// cell renderer, which can be set explicitly or mapped to a column in the
/// tree model, like all properties of cell renders. `GtkCellRendererSpin`
/// also has properties for the `GtkCellRendererSpin:climb`-rate and the number
/// of `GtkCellRendererSpin:digits` to display. Other `GtkSpinButton` properties
/// can be set in a handler for the `GtkCellRenderer::editing`-started signal.
/// 
/// The `GtkCellRendererSpin` cell renderer was added in GTK 2.10.
public struct CellRendererSpinRef: CellRendererSpinProtocol {
        /// Untyped pointer to the underlying `GtkCellRendererSpin` instance.
    /// For type-safe access, use the generated, typed pointer `cell_renderer_spin_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellRendererSpinRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellRendererSpin>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellRendererSpin>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellRendererSpin>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellRendererSpin>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellRendererSpinProtocol`
    @inlinable init<T: CellRendererSpinProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCellRendererSpin`.
    @inlinable init() {
        let rv = gtk_cell_renderer_spin_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `CellRendererSpin` type acts as a reference-counted owner of an underlying `GtkCellRendererSpin` instance.
/// It provides the methods that can operate on this data type through `CellRendererSpinProtocol` conformance.
/// Use `CellRendererSpin` as a strong reference or owner of a `GtkCellRendererSpin` instance.
///
/// `GtkCellRendererSpin` renders text in a cell like `GtkCellRendererText` from
/// which it is derived. But while `GtkCellRendererText` offers a simple entry to
/// edit the text, `GtkCellRendererSpin` offers a `GtkSpinButton` widget. Of course,
/// that means that the text has to be parseable as a floating point number.
/// 
/// The range of the spinbutton is taken from the adjustment property of the
/// cell renderer, which can be set explicitly or mapped to a column in the
/// tree model, like all properties of cell renders. `GtkCellRendererSpin`
/// also has properties for the `GtkCellRendererSpin:climb`-rate and the number
/// of `GtkCellRendererSpin:digits` to display. Other `GtkSpinButton` properties
/// can be set in a handler for the `GtkCellRenderer::editing`-started signal.
/// 
/// The `GtkCellRendererSpin` cell renderer was added in GTK 2.10.
open class CellRendererSpin: CellRendererText, CellRendererSpinProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererSpin` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCellRendererSpin>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererSpin` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCellRendererSpin>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererSpin` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererSpin` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererSpin` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCellRendererSpin>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererSpin` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCellRendererSpin>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCellRendererSpin`.
    /// i.e., ownership is transferred to the `CellRendererSpin` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCellRendererSpin>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CellRendererSpinProtocol`
    /// Will retain `GtkCellRendererSpin`.
    /// - Parameter other: an instance of a related type that implements `CellRendererSpinProtocol`
    @inlinable public init<T: CellRendererSpinProtocol>(cellRendererSpin other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkCellRendererSpin`.
    @inlinable override public init() {
        let rv = gtk_cell_renderer_spin_new()
        super.init(gpointer: gpointer(rv))
    }


}

public enum CellRendererSpinPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    /// The adjustment that holds the value of the spinbutton.
    /// This must be non-`nil` for the cell renderer to be editable.
    case adjustment = "adjustment"
    case alignSet = "align-set"
    /// Specifies how to align the lines of text with respect to each other.
    /// 
    /// Note that this property describes how to align the lines of text in
    /// case there are several of them. The "xalign" property of `GtkCellRenderer`,
    /// on the other hand, sets the horizontal alignment of the whole text.
    case alignment = "alignment"
    case attributes = "attributes"
    case background = "background"
    /// Background color as a `GdkRGBA`
    case backgroundRgba = "background-rgba"
    case backgroundSet = "background-set"
    case cellBackground = "cell-background"
    /// Cell background as a `GdkRGBA`
    case cellBackgroundRgba = "cell-background-rgba"
    case cellBackgroundSet = "cell-background-set"
    /// The acceleration rate when you hold down a button.
    case climbRate = "climb-rate"
    /// The number of decimal places to display.
    case digits = "digits"
    case editable = "editable"
    case editableSet = "editable-set"
    case editing = "editing"
    /// Specifies the preferred place to ellipsize the string, if the cell renderer
    /// does not have enough room to display the entire string. Setting it to
    /// `PANGO_ELLIPSIZE_NONE` turns off ellipsizing. See the wrap-width property
    /// for another way of making the text fit into a given width.
    case ellipsize = "ellipsize"
    case ellipsizeSet = "ellipsize-set"
    case family = "family"
    case familySet = "family-set"
    case font = "font"
    case fontDesc = "font-desc"
    case foreground = "foreground"
    /// Foreground color as a `GdkRGBA`
    case foregroundRgba = "foreground-rgba"
    case foregroundSet = "foreground-set"
    case height = "height"
    case isExpanded = "is-expanded"
    case isExpander = "is-expander"
    case language = "language"
    case languageSet = "language-set"
    case markup = "markup"
    /// The desired maximum width of the cell, in characters. If this property
    /// is set to -1, the width will be calculated automatically.
    /// 
    /// For cell renderers that ellipsize or wrap text; this property
    /// controls the maximum reported width of the cell. The
    /// cell should not receive any greater allocation unless it is
    /// set to expand in its `GtkCellLayout` and all of the cell's siblings
    /// have received their natural width.
    case maxWidthChars = "max-width-chars"
    case mode = "mode"
    /// The text that will be displayed in the `GtkCellRenderer` if
    /// `GtkCellRendererText:editable` is `true` and the cell is empty.
    case placeholderText = "placeholder-text"
    case rise = "rise"
    case riseSet = "rise-set"
    case scale = "scale"
    case scaleSet = "scale-set"
    case sensitive = "sensitive"
    case singleParagraphMode = "single-paragraph-mode"
    case size = "size"
    case sizePoints = "size-points"
    case sizeSet = "size-set"
    case stretch = "stretch"
    case stretchSet = "stretch-set"
    case strikethrough = "strikethrough"
    case strikethroughSet = "strikethrough-set"
    case style = "style"
    case styleSet = "style-set"
    case text = "text"
    case underline = "underline"
    case underlineSet = "underline-set"
    case variant = "variant"
    case variantSet = "variant-set"
    case visible = "visible"
    case weight = "weight"
    case weightSet = "weight-set"
    case width = "width"
    /// The desired width of the cell, in characters. If this property is set to
    /// -1, the width will be calculated automatically, otherwise the cell will
    /// request either 3 characters or the property value, whichever is greater.
    case widthChars = "width-chars"
    /// Specifies how to break the string into multiple lines, if the cell
    /// renderer does not have enough room to display the entire string.
    /// This property has no effect unless the wrap-width property is set.
    case wrapMode = "wrap-mode"
    /// Specifies the minimum width at which the text is wrapped. The wrap-mode property can
    /// be used to influence at what character positions the line breaks can be placed.
    /// Setting wrap-width to -1 turns wrapping off.
    case wrapWidth = "wrap-width"
    case xalign = "xalign"
    case xpad = "xpad"
    case yalign = "yalign"
    case ypad = "ypad"
}

public extension CellRendererSpinProtocol {
    /// Bind a `CellRendererSpinPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellRendererSpinPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CellRendererSpin property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CellRendererSpinPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CellRendererSpin property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CellRendererSpinPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CellRendererSpinSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// This signal is emitted after `renderer` has been edited.
    /// 
    /// It is the responsibility of the application to update the model
    /// and store `new_text` at the position indicated by `path`.
    case edited = "edited"
    /// This signal gets emitted when the user cancels the process of editing a
    /// cell.  For example, an editable cell renderer could be written to cancel
    /// editing when the user presses Escape.
    /// 
    /// See also: `gtk_cell_renderer_stop_editing()`.
    case editingCanceled = "editing-canceled"
    /// This signal gets emitted when a cell starts to be edited.
    /// The intended use of this signal is to do special setup
    /// on `editable`, e.g. adding a `GtkEntryCompletion` or setting
    /// up additional columns in a `GtkComboBox`.
    /// 
    /// See `gtk_cell_editable_start_editing()` for information on the lifecycle of
    /// the `editable` and a way to do setup that doesn’t depend on the `renderer`.
    /// 
    /// Note that GTK doesn't guarantee that cell renderers will
    /// continue to use the same kind of widget for editing in future
    /// releases, therefore you should check the type of `editable`
    /// before doing any specific setup, as in the following example:
    /// (C Language Example):
    /// ```C
    /// static void
    /// text_editing_started (GtkCellRenderer *cell,
    ///                       GtkCellEditable *editable,
    ///                       const char      *path,
    ///                       gpointer         data)
    /// {
    ///   if (GTK_IS_ENTRY (editable))
    ///     {
    ///       GtkEntry *entry = GTK_ENTRY (editable);
    ///       
    ///       // ... create a GtkEntryCompletion
    ///       
    ///       gtk_entry_set_completion (entry, completion);
    ///     }
    /// }
    /// ```
    /// 
    case editingStarted = "editing-started"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    /// The adjustment that holds the value of the spinbutton.
    /// This must be non-`nil` for the cell renderer to be editable.
    case notifyAdjustment = "notify::adjustment"
    case notifyAlignSet = "notify::align-set"
    /// Specifies how to align the lines of text with respect to each other.
    /// 
    /// Note that this property describes how to align the lines of text in
    /// case there are several of them. The "xalign" property of `GtkCellRenderer`,
    /// on the other hand, sets the horizontal alignment of the whole text.
    case notifyAlignment = "notify::alignment"
    case notifyAttributes = "notify::attributes"
    case notifyBackground = "notify::background"
    /// Background color as a `GdkRGBA`
    case notifyBackgroundRgba = "notify::background-rgba"
    case notifyBackgroundSet = "notify::background-set"
    case notifyCellBackground = "notify::cell-background"
    /// Cell background as a `GdkRGBA`
    case notifyCellBackgroundRgba = "notify::cell-background-rgba"
    case notifyCellBackgroundSet = "notify::cell-background-set"
    /// The acceleration rate when you hold down a button.
    case notifyClimbRate = "notify::climb-rate"
    /// The number of decimal places to display.
    case notifyDigits = "notify::digits"
    case notifyEditable = "notify::editable"
    case notifyEditableSet = "notify::editable-set"
    case notifyEditing = "notify::editing"
    /// Specifies the preferred place to ellipsize the string, if the cell renderer
    /// does not have enough room to display the entire string. Setting it to
    /// `PANGO_ELLIPSIZE_NONE` turns off ellipsizing. See the wrap-width property
    /// for another way of making the text fit into a given width.
    case notifyEllipsize = "notify::ellipsize"
    case notifyEllipsizeSet = "notify::ellipsize-set"
    case notifyFamily = "notify::family"
    case notifyFamilySet = "notify::family-set"
    case notifyFont = "notify::font"
    case notifyFontDesc = "notify::font-desc"
    case notifyForeground = "notify::foreground"
    /// Foreground color as a `GdkRGBA`
    case notifyForegroundRgba = "notify::foreground-rgba"
    case notifyForegroundSet = "notify::foreground-set"
    case notifyHeight = "notify::height"
    case notifyIsExpanded = "notify::is-expanded"
    case notifyIsExpander = "notify::is-expander"
    case notifyLanguage = "notify::language"
    case notifyLanguageSet = "notify::language-set"
    case notifyMarkup = "notify::markup"
    /// The desired maximum width of the cell, in characters. If this property
    /// is set to -1, the width will be calculated automatically.
    /// 
    /// For cell renderers that ellipsize or wrap text; this property
    /// controls the maximum reported width of the cell. The
    /// cell should not receive any greater allocation unless it is
    /// set to expand in its `GtkCellLayout` and all of the cell's siblings
    /// have received their natural width.
    case notifyMaxWidthChars = "notify::max-width-chars"
    case notifyMode = "notify::mode"
    /// The text that will be displayed in the `GtkCellRenderer` if
    /// `GtkCellRendererText:editable` is `true` and the cell is empty.
    case notifyPlaceholderText = "notify::placeholder-text"
    case notifyRise = "notify::rise"
    case notifyRiseSet = "notify::rise-set"
    case notifyScale = "notify::scale"
    case notifyScaleSet = "notify::scale-set"
    case notifySensitive = "notify::sensitive"
    case notifySingleParagraphMode = "notify::single-paragraph-mode"
    case notifySize = "notify::size"
    case notifySizePoints = "notify::size-points"
    case notifySizeSet = "notify::size-set"
    case notifyStretch = "notify::stretch"
    case notifyStretchSet = "notify::stretch-set"
    case notifyStrikethrough = "notify::strikethrough"
    case notifyStrikethroughSet = "notify::strikethrough-set"
    case notifyStyle = "notify::style"
    case notifyStyleSet = "notify::style-set"
    case notifyText = "notify::text"
    case notifyUnderline = "notify::underline"
    case notifyUnderlineSet = "notify::underline-set"
    case notifyVariant = "notify::variant"
    case notifyVariantSet = "notify::variant-set"
    case notifyVisible = "notify::visible"
    case notifyWeight = "notify::weight"
    case notifyWeightSet = "notify::weight-set"
    case notifyWidth = "notify::width"
    /// The desired width of the cell, in characters. If this property is set to
    /// -1, the width will be calculated automatically, otherwise the cell will
    /// request either 3 characters or the property value, whichever is greater.
    case notifyWidthChars = "notify::width-chars"
    /// Specifies how to break the string into multiple lines, if the cell
    /// renderer does not have enough room to display the entire string.
    /// This property has no effect unless the wrap-width property is set.
    case notifyWrapMode = "notify::wrap-mode"
    /// Specifies the minimum width at which the text is wrapped. The wrap-mode property can
    /// be used to influence at what character positions the line breaks can be placed.
    /// Setting wrap-width to -1 turns wrapping off.
    case notifyWrapWidth = "notify::wrap-width"
    case notifyXalign = "notify::xalign"
    case notifyXpad = "notify::xpad"
    case notifyYalign = "notify::yalign"
    case notifyYpad = "notify::ypad"
}

public extension CellRendererSpinProtocol {
    /// Connect a `CellRendererSpinSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @inlinable @discardableResult func connect(signal kind: CellRendererSpinSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> Int {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> Int {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(raw: ptr).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

// MARK: CellRendererSpin Class: CellRendererSpinProtocol extension (methods and fields)
public extension CellRendererSpinProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellRendererSpin` instance.
    @inlinable var cell_renderer_spin_ptr: UnsafeMutablePointer<GtkCellRendererSpin>! { return ptr?.assumingMemoryBound(to: GtkCellRendererSpin.self) }



}



// MARK: - CellRendererSpinner Class

/// The `CellRendererSpinnerProtocol` protocol exposes the methods and properties of an underlying `GtkCellRendererSpinner` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellRendererSpinner`.
/// Alternatively, use `CellRendererSpinnerRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// GtkCellRendererSpinner renders a spinning animation in a cell, very
/// similar to `GtkSpinner`. It can often be used as an alternative
/// to a `GtkCellRendererProgress` for displaying indefinite activity,
/// instead of actual progress.
/// 
/// To start the animation in a cell, set the `GtkCellRendererSpinner:active`
/// property to `true` and increment the `GtkCellRendererSpinner:pulse` property
/// at regular intervals. The usual way to set the cell renderer properties
/// for each cell is to bind them to columns in your tree model using e.g.
/// `gtk_tree_view_column_add_attribute()`.
public protocol CellRendererSpinnerProtocol: CellRendererProtocol {
        /// Untyped pointer to the underlying `GtkCellRendererSpinner` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellRendererSpinner` instance.
    var cell_renderer_spinner_ptr: UnsafeMutablePointer<GtkCellRendererSpinner>! { get }

}

/// The `CellRendererSpinnerRef` type acts as a lightweight Swift reference to an underlying `GtkCellRendererSpinner` instance.
/// It exposes methods that can operate on this data type through `CellRendererSpinnerProtocol` conformance.
/// Use `CellRendererSpinnerRef` only as an `unowned` reference to an existing `GtkCellRendererSpinner` instance.
///
/// GtkCellRendererSpinner renders a spinning animation in a cell, very
/// similar to `GtkSpinner`. It can often be used as an alternative
/// to a `GtkCellRendererProgress` for displaying indefinite activity,
/// instead of actual progress.
/// 
/// To start the animation in a cell, set the `GtkCellRendererSpinner:active`
/// property to `true` and increment the `GtkCellRendererSpinner:pulse` property
/// at regular intervals. The usual way to set the cell renderer properties
/// for each cell is to bind them to columns in your tree model using e.g.
/// `gtk_tree_view_column_add_attribute()`.
public struct CellRendererSpinnerRef: CellRendererSpinnerProtocol {
        /// Untyped pointer to the underlying `GtkCellRendererSpinner` instance.
    /// For type-safe access, use the generated, typed pointer `cell_renderer_spinner_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellRendererSpinnerRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellRendererSpinner>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellRendererSpinner>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellRendererSpinner>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellRendererSpinner>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellRendererSpinnerProtocol`
    @inlinable init<T: CellRendererSpinnerProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Returns a new cell renderer which will show a spinner to indicate
    /// activity.
    @inlinable init() {
        let rv = gtk_cell_renderer_spinner_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `CellRendererSpinner` type acts as a reference-counted owner of an underlying `GtkCellRendererSpinner` instance.
/// It provides the methods that can operate on this data type through `CellRendererSpinnerProtocol` conformance.
/// Use `CellRendererSpinner` as a strong reference or owner of a `GtkCellRendererSpinner` instance.
///
/// GtkCellRendererSpinner renders a spinning animation in a cell, very
/// similar to `GtkSpinner`. It can often be used as an alternative
/// to a `GtkCellRendererProgress` for displaying indefinite activity,
/// instead of actual progress.
/// 
/// To start the animation in a cell, set the `GtkCellRendererSpinner:active`
/// property to `true` and increment the `GtkCellRendererSpinner:pulse` property
/// at regular intervals. The usual way to set the cell renderer properties
/// for each cell is to bind them to columns in your tree model using e.g.
/// `gtk_tree_view_column_add_attribute()`.
open class CellRendererSpinner: CellRenderer, CellRendererSpinnerProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererSpinner` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCellRendererSpinner>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererSpinner` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCellRendererSpinner>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererSpinner` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererSpinner` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererSpinner` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCellRendererSpinner>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererSpinner` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCellRendererSpinner>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCellRendererSpinner`.
    /// i.e., ownership is transferred to the `CellRendererSpinner` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCellRendererSpinner>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CellRendererSpinnerProtocol`
    /// Will retain `GtkCellRendererSpinner`.
    /// - Parameter other: an instance of a related type that implements `CellRendererSpinnerProtocol`
    @inlinable public init<T: CellRendererSpinnerProtocol>(cellRendererSpinner other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Returns a new cell renderer which will show a spinner to indicate
    /// activity.
    @inlinable public init() {
        let rv = gtk_cell_renderer_spinner_new()
        super.init(gpointer: gpointer(rv))
    }


}

public enum CellRendererSpinnerPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case active = "active"
    case cellBackground = "cell-background"
    /// Cell background as a `GdkRGBA`
    case cellBackgroundRgba = "cell-background-rgba"
    case cellBackgroundSet = "cell-background-set"
    case editing = "editing"
    case height = "height"
    case isExpanded = "is-expanded"
    case isExpander = "is-expander"
    case mode = "mode"
    /// Pulse of the spinner. Increment this value to draw the next frame of the
    /// spinner animation. Usually, you would update this value in a timeout.
    /// 
    /// By default, the `GtkSpinner` widget draws one full cycle of the animation,
    /// consisting of 12 frames, in 750 milliseconds.
    case pulse = "pulse"
    case sensitive = "sensitive"
    /// The `GtkIconSize` value that specifies the size of the rendered spinner.
    case size = "size"
    case visible = "visible"
    case width = "width"
    case xalign = "xalign"
    case xpad = "xpad"
    case yalign = "yalign"
    case ypad = "ypad"
}

public extension CellRendererSpinnerProtocol {
    /// Bind a `CellRendererSpinnerPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellRendererSpinnerPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CellRendererSpinner property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CellRendererSpinnerPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CellRendererSpinner property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CellRendererSpinnerPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CellRendererSpinnerSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// This signal gets emitted when the user cancels the process of editing a
    /// cell.  For example, an editable cell renderer could be written to cancel
    /// editing when the user presses Escape.
    /// 
    /// See also: `gtk_cell_renderer_stop_editing()`.
    case editingCanceled = "editing-canceled"
    /// This signal gets emitted when a cell starts to be edited.
    /// The intended use of this signal is to do special setup
    /// on `editable`, e.g. adding a `GtkEntryCompletion` or setting
    /// up additional columns in a `GtkComboBox`.
    /// 
    /// See `gtk_cell_editable_start_editing()` for information on the lifecycle of
    /// the `editable` and a way to do setup that doesn’t depend on the `renderer`.
    /// 
    /// Note that GTK doesn't guarantee that cell renderers will
    /// continue to use the same kind of widget for editing in future
    /// releases, therefore you should check the type of `editable`
    /// before doing any specific setup, as in the following example:
    /// (C Language Example):
    /// ```C
    /// static void
    /// text_editing_started (GtkCellRenderer *cell,
    ///                       GtkCellEditable *editable,
    ///                       const char      *path,
    ///                       gpointer         data)
    /// {
    ///   if (GTK_IS_ENTRY (editable))
    ///     {
    ///       GtkEntry *entry = GTK_ENTRY (editable);
    ///       
    ///       // ... create a GtkEntryCompletion
    ///       
    ///       gtk_entry_set_completion (entry, completion);
    ///     }
    /// }
    /// ```
    /// 
    case editingStarted = "editing-started"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyActive = "notify::active"
    case notifyCellBackground = "notify::cell-background"
    /// Cell background as a `GdkRGBA`
    case notifyCellBackgroundRgba = "notify::cell-background-rgba"
    case notifyCellBackgroundSet = "notify::cell-background-set"
    case notifyEditing = "notify::editing"
    case notifyHeight = "notify::height"
    case notifyIsExpanded = "notify::is-expanded"
    case notifyIsExpander = "notify::is-expander"
    case notifyMode = "notify::mode"
    /// Pulse of the spinner. Increment this value to draw the next frame of the
    /// spinner animation. Usually, you would update this value in a timeout.
    /// 
    /// By default, the `GtkSpinner` widget draws one full cycle of the animation,
    /// consisting of 12 frames, in 750 milliseconds.
    case notifyPulse = "notify::pulse"
    case notifySensitive = "notify::sensitive"
    /// The `GtkIconSize` value that specifies the size of the rendered spinner.
    case notifySize = "notify::size"
    case notifyVisible = "notify::visible"
    case notifyWidth = "notify::width"
    case notifyXalign = "notify::xalign"
    case notifyXpad = "notify::xpad"
    case notifyYalign = "notify::yalign"
    case notifyYpad = "notify::ypad"
}

public extension CellRendererSpinnerProtocol {
    /// Connect a `CellRendererSpinnerSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @inlinable @discardableResult func connect(signal kind: CellRendererSpinnerSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> Int {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> Int {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(raw: ptr).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

// MARK: CellRendererSpinner Class: CellRendererSpinnerProtocol extension (methods and fields)
public extension CellRendererSpinnerProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellRendererSpinner` instance.
    @inlinable var cell_renderer_spinner_ptr: UnsafeMutablePointer<GtkCellRendererSpinner>! { return ptr?.assumingMemoryBound(to: GtkCellRendererSpinner.self) }



}



// MARK: - CellRendererText Class

/// The `CellRendererTextProtocol` protocol exposes the methods and properties of an underlying `GtkCellRendererText` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellRendererText`.
/// Alternatively, use `CellRendererTextRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A `GtkCellRendererText` renders a given text in its cell, using the font, color and
/// style information provided by its properties. The text will be ellipsized if it is
/// too long and the `GtkCellRendererText:ellipsize` property allows it.
/// 
/// If the `GtkCellRenderer:mode` is `GTK_CELL_RENDERER_MODE_EDITABLE`,
/// the `GtkCellRendererText` allows to edit its text using an entry.
public protocol CellRendererTextProtocol: CellRendererProtocol {
        /// Untyped pointer to the underlying `GtkCellRendererText` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellRendererText` instance.
    var cell_renderer_text_ptr: UnsafeMutablePointer<GtkCellRendererText>! { get }

}

/// The `CellRendererTextRef` type acts as a lightweight Swift reference to an underlying `GtkCellRendererText` instance.
/// It exposes methods that can operate on this data type through `CellRendererTextProtocol` conformance.
/// Use `CellRendererTextRef` only as an `unowned` reference to an existing `GtkCellRendererText` instance.
///
/// A `GtkCellRendererText` renders a given text in its cell, using the font, color and
/// style information provided by its properties. The text will be ellipsized if it is
/// too long and the `GtkCellRendererText:ellipsize` property allows it.
/// 
/// If the `GtkCellRenderer:mode` is `GTK_CELL_RENDERER_MODE_EDITABLE`,
/// the `GtkCellRendererText` allows to edit its text using an entry.
public struct CellRendererTextRef: CellRendererTextProtocol {
        /// Untyped pointer to the underlying `GtkCellRendererText` instance.
    /// For type-safe access, use the generated, typed pointer `cell_renderer_text_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellRendererTextRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellRendererText>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellRendererText>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellRendererText>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellRendererText>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellRendererTextProtocol`
    @inlinable init<T: CellRendererTextProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCellRendererText`. Adjust how text is drawn using
    /// object properties. Object properties can be
    /// set globally (with `g_object_set()`). Also, with `GtkTreeViewColumn`,
    /// you can bind a property to a value in a `GtkTreeModel`. For example,
    /// you can bind the “text” property on the cell renderer to a string
    /// value in the model, thus rendering a different string in each row
    /// of the `GtkTreeView`
    @inlinable init() {
        let rv = gtk_cell_renderer_text_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `CellRendererText` type acts as a reference-counted owner of an underlying `GtkCellRendererText` instance.
/// It provides the methods that can operate on this data type through `CellRendererTextProtocol` conformance.
/// Use `CellRendererText` as a strong reference or owner of a `GtkCellRendererText` instance.
///
/// A `GtkCellRendererText` renders a given text in its cell, using the font, color and
/// style information provided by its properties. The text will be ellipsized if it is
/// too long and the `GtkCellRendererText:ellipsize` property allows it.
/// 
/// If the `GtkCellRenderer:mode` is `GTK_CELL_RENDERER_MODE_EDITABLE`,
/// the `GtkCellRendererText` allows to edit its text using an entry.
open class CellRendererText: CellRenderer, CellRendererTextProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererText` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCellRendererText>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererText` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCellRendererText>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererText` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererText` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererText` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCellRendererText>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererText` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCellRendererText>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCellRendererText`.
    /// i.e., ownership is transferred to the `CellRendererText` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCellRendererText>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CellRendererTextProtocol`
    /// Will retain `GtkCellRendererText`.
    /// - Parameter other: an instance of a related type that implements `CellRendererTextProtocol`
    @inlinable public init<T: CellRendererTextProtocol>(cellRendererText other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkCellRendererText`. Adjust how text is drawn using
    /// object properties. Object properties can be
    /// set globally (with `g_object_set()`). Also, with `GtkTreeViewColumn`,
    /// you can bind a property to a value in a `GtkTreeModel`. For example,
    /// you can bind the “text” property on the cell renderer to a string
    /// value in the model, thus rendering a different string in each row
    /// of the `GtkTreeView`
    @inlinable public init() {
        let rv = gtk_cell_renderer_text_new()
        super.init(gpointer: gpointer(rv))
    }


}

public enum CellRendererTextPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case alignSet = "align-set"
    /// Specifies how to align the lines of text with respect to each other.
    /// 
    /// Note that this property describes how to align the lines of text in
    /// case there are several of them. The "xalign" property of `GtkCellRenderer`,
    /// on the other hand, sets the horizontal alignment of the whole text.
    case alignment = "alignment"
    case attributes = "attributes"
    case background = "background"
    /// Background color as a `GdkRGBA`
    case backgroundRgba = "background-rgba"
    case backgroundSet = "background-set"
    case cellBackground = "cell-background"
    /// Cell background as a `GdkRGBA`
    case cellBackgroundRgba = "cell-background-rgba"
    case cellBackgroundSet = "cell-background-set"
    case editable = "editable"
    case editableSet = "editable-set"
    case editing = "editing"
    /// Specifies the preferred place to ellipsize the string, if the cell renderer
    /// does not have enough room to display the entire string. Setting it to
    /// `PANGO_ELLIPSIZE_NONE` turns off ellipsizing. See the wrap-width property
    /// for another way of making the text fit into a given width.
    case ellipsize = "ellipsize"
    case ellipsizeSet = "ellipsize-set"
    case family = "family"
    case familySet = "family-set"
    case font = "font"
    case fontDesc = "font-desc"
    case foreground = "foreground"
    /// Foreground color as a `GdkRGBA`
    case foregroundRgba = "foreground-rgba"
    case foregroundSet = "foreground-set"
    case height = "height"
    case isExpanded = "is-expanded"
    case isExpander = "is-expander"
    case language = "language"
    case languageSet = "language-set"
    case markup = "markup"
    /// The desired maximum width of the cell, in characters. If this property
    /// is set to -1, the width will be calculated automatically.
    /// 
    /// For cell renderers that ellipsize or wrap text; this property
    /// controls the maximum reported width of the cell. The
    /// cell should not receive any greater allocation unless it is
    /// set to expand in its `GtkCellLayout` and all of the cell's siblings
    /// have received their natural width.
    case maxWidthChars = "max-width-chars"
    case mode = "mode"
    /// The text that will be displayed in the `GtkCellRenderer` if
    /// `GtkCellRendererText:editable` is `true` and the cell is empty.
    case placeholderText = "placeholder-text"
    case rise = "rise"
    case riseSet = "rise-set"
    case scale = "scale"
    case scaleSet = "scale-set"
    case sensitive = "sensitive"
    case singleParagraphMode = "single-paragraph-mode"
    case size = "size"
    case sizePoints = "size-points"
    case sizeSet = "size-set"
    case stretch = "stretch"
    case stretchSet = "stretch-set"
    case strikethrough = "strikethrough"
    case strikethroughSet = "strikethrough-set"
    case style = "style"
    case styleSet = "style-set"
    case text = "text"
    case underline = "underline"
    case underlineSet = "underline-set"
    case variant = "variant"
    case variantSet = "variant-set"
    case visible = "visible"
    case weight = "weight"
    case weightSet = "weight-set"
    case width = "width"
    /// The desired width of the cell, in characters. If this property is set to
    /// -1, the width will be calculated automatically, otherwise the cell will
    /// request either 3 characters or the property value, whichever is greater.
    case widthChars = "width-chars"
    /// Specifies how to break the string into multiple lines, if the cell
    /// renderer does not have enough room to display the entire string.
    /// This property has no effect unless the wrap-width property is set.
    case wrapMode = "wrap-mode"
    /// Specifies the minimum width at which the text is wrapped. The wrap-mode property can
    /// be used to influence at what character positions the line breaks can be placed.
    /// Setting wrap-width to -1 turns wrapping off.
    case wrapWidth = "wrap-width"
    case xalign = "xalign"
    case xpad = "xpad"
    case yalign = "yalign"
    case ypad = "ypad"
}

public extension CellRendererTextProtocol {
    /// Bind a `CellRendererTextPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellRendererTextPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CellRendererText property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CellRendererTextPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CellRendererText property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CellRendererTextPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CellRendererTextSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// This signal is emitted after `renderer` has been edited.
    /// 
    /// It is the responsibility of the application to update the model
    /// and store `new_text` at the position indicated by `path`.
    case edited = "edited"
    /// This signal gets emitted when the user cancels the process of editing a
    /// cell.  For example, an editable cell renderer could be written to cancel
    /// editing when the user presses Escape.
    /// 
    /// See also: `gtk_cell_renderer_stop_editing()`.
    case editingCanceled = "editing-canceled"
    /// This signal gets emitted when a cell starts to be edited.
    /// The intended use of this signal is to do special setup
    /// on `editable`, e.g. adding a `GtkEntryCompletion` or setting
    /// up additional columns in a `GtkComboBox`.
    /// 
    /// See `gtk_cell_editable_start_editing()` for information on the lifecycle of
    /// the `editable` and a way to do setup that doesn’t depend on the `renderer`.
    /// 
    /// Note that GTK doesn't guarantee that cell renderers will
    /// continue to use the same kind of widget for editing in future
    /// releases, therefore you should check the type of `editable`
    /// before doing any specific setup, as in the following example:
    /// (C Language Example):
    /// ```C
    /// static void
    /// text_editing_started (GtkCellRenderer *cell,
    ///                       GtkCellEditable *editable,
    ///                       const char      *path,
    ///                       gpointer         data)
    /// {
    ///   if (GTK_IS_ENTRY (editable))
    ///     {
    ///       GtkEntry *entry = GTK_ENTRY (editable);
    ///       
    ///       // ... create a GtkEntryCompletion
    ///       
    ///       gtk_entry_set_completion (entry, completion);
    ///     }
    /// }
    /// ```
    /// 
    case editingStarted = "editing-started"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyAlignSet = "notify::align-set"
    /// Specifies how to align the lines of text with respect to each other.
    /// 
    /// Note that this property describes how to align the lines of text in
    /// case there are several of them. The "xalign" property of `GtkCellRenderer`,
    /// on the other hand, sets the horizontal alignment of the whole text.
    case notifyAlignment = "notify::alignment"
    case notifyAttributes = "notify::attributes"
    case notifyBackground = "notify::background"
    /// Background color as a `GdkRGBA`
    case notifyBackgroundRgba = "notify::background-rgba"
    case notifyBackgroundSet = "notify::background-set"
    case notifyCellBackground = "notify::cell-background"
    /// Cell background as a `GdkRGBA`
    case notifyCellBackgroundRgba = "notify::cell-background-rgba"
    case notifyCellBackgroundSet = "notify::cell-background-set"
    case notifyEditable = "notify::editable"
    case notifyEditableSet = "notify::editable-set"
    case notifyEditing = "notify::editing"
    /// Specifies the preferred place to ellipsize the string, if the cell renderer
    /// does not have enough room to display the entire string. Setting it to
    /// `PANGO_ELLIPSIZE_NONE` turns off ellipsizing. See the wrap-width property
    /// for another way of making the text fit into a given width.
    case notifyEllipsize = "notify::ellipsize"
    case notifyEllipsizeSet = "notify::ellipsize-set"
    case notifyFamily = "notify::family"
    case notifyFamilySet = "notify::family-set"
    case notifyFont = "notify::font"
    case notifyFontDesc = "notify::font-desc"
    case notifyForeground = "notify::foreground"
    /// Foreground color as a `GdkRGBA`
    case notifyForegroundRgba = "notify::foreground-rgba"
    case notifyForegroundSet = "notify::foreground-set"
    case notifyHeight = "notify::height"
    case notifyIsExpanded = "notify::is-expanded"
    case notifyIsExpander = "notify::is-expander"
    case notifyLanguage = "notify::language"
    case notifyLanguageSet = "notify::language-set"
    case notifyMarkup = "notify::markup"
    /// The desired maximum width of the cell, in characters. If this property
    /// is set to -1, the width will be calculated automatically.
    /// 
    /// For cell renderers that ellipsize or wrap text; this property
    /// controls the maximum reported width of the cell. The
    /// cell should not receive any greater allocation unless it is
    /// set to expand in its `GtkCellLayout` and all of the cell's siblings
    /// have received their natural width.
    case notifyMaxWidthChars = "notify::max-width-chars"
    case notifyMode = "notify::mode"
    /// The text that will be displayed in the `GtkCellRenderer` if
    /// `GtkCellRendererText:editable` is `true` and the cell is empty.
    case notifyPlaceholderText = "notify::placeholder-text"
    case notifyRise = "notify::rise"
    case notifyRiseSet = "notify::rise-set"
    case notifyScale = "notify::scale"
    case notifyScaleSet = "notify::scale-set"
    case notifySensitive = "notify::sensitive"
    case notifySingleParagraphMode = "notify::single-paragraph-mode"
    case notifySize = "notify::size"
    case notifySizePoints = "notify::size-points"
    case notifySizeSet = "notify::size-set"
    case notifyStretch = "notify::stretch"
    case notifyStretchSet = "notify::stretch-set"
    case notifyStrikethrough = "notify::strikethrough"
    case notifyStrikethroughSet = "notify::strikethrough-set"
    case notifyStyle = "notify::style"
    case notifyStyleSet = "notify::style-set"
    case notifyText = "notify::text"
    case notifyUnderline = "notify::underline"
    case notifyUnderlineSet = "notify::underline-set"
    case notifyVariant = "notify::variant"
    case notifyVariantSet = "notify::variant-set"
    case notifyVisible = "notify::visible"
    case notifyWeight = "notify::weight"
    case notifyWeightSet = "notify::weight-set"
    case notifyWidth = "notify::width"
    /// The desired width of the cell, in characters. If this property is set to
    /// -1, the width will be calculated automatically, otherwise the cell will
    /// request either 3 characters or the property value, whichever is greater.
    case notifyWidthChars = "notify::width-chars"
    /// Specifies how to break the string into multiple lines, if the cell
    /// renderer does not have enough room to display the entire string.
    /// This property has no effect unless the wrap-width property is set.
    case notifyWrapMode = "notify::wrap-mode"
    /// Specifies the minimum width at which the text is wrapped. The wrap-mode property can
    /// be used to influence at what character positions the line breaks can be placed.
    /// Setting wrap-width to -1 turns wrapping off.
    case notifyWrapWidth = "notify::wrap-width"
    case notifyXalign = "notify::xalign"
    case notifyXpad = "notify::xpad"
    case notifyYalign = "notify::yalign"
    case notifyYpad = "notify::ypad"
}

public extension CellRendererTextProtocol {
    /// Connect a `CellRendererTextSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @inlinable @discardableResult func connect(signal kind: CellRendererTextSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> Int {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> Int {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(raw: ptr).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

// MARK: CellRendererText Class: CellRendererTextProtocol extension (methods and fields)
public extension CellRendererTextProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellRendererText` instance.
    @inlinable var cell_renderer_text_ptr: UnsafeMutablePointer<GtkCellRendererText>! { return ptr?.assumingMemoryBound(to: GtkCellRendererText.self) }

    /// Sets the height of a renderer to explicitly be determined by the “font” and
    /// “y_pad” property set on it.  Further changes in these properties do not
    /// affect the height, so they must be accompanied by a subsequent call to this
    /// function.  Using this function is inflexible, and should really only be used
    /// if calculating the size of a cell is too slow (ie, a massive number of cells
    /// displayed).  If `number_of_rows` is -1, then the fixed height is unset, and
    /// the height is determined by the properties again.
    @inlinable func setFixedHeightFromFont(numberOfRows: Int) {
        gtk_cell_renderer_text_set_fixed_height_from_font(cell_renderer_text_ptr, gint(numberOfRows))
    
    }

    @inlinable var parent: GtkCellRenderer {
        get {
            let rv = cell_renderer_text_ptr.pointee.parent
            return rv
        }
    }

}



// MARK: - CellRendererToggle Class

/// The `CellRendererToggleProtocol` protocol exposes the methods and properties of an underlying `GtkCellRendererToggle` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellRendererToggle`.
/// Alternatively, use `CellRendererToggleRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkCellRendererToggle` renders a toggle button in a cell. The
/// button is drawn as a radio or a checkbutton, depending on the
/// `GtkCellRendererToggle:radio` property.
/// When activated, it emits the `GtkCellRendererToggle::toggled` signal.
public protocol CellRendererToggleProtocol: CellRendererProtocol {
        /// Untyped pointer to the underlying `GtkCellRendererToggle` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellRendererToggle` instance.
    var cell_renderer_toggle_ptr: UnsafeMutablePointer<GtkCellRendererToggle>! { get }

}

/// The `CellRendererToggleRef` type acts as a lightweight Swift reference to an underlying `GtkCellRendererToggle` instance.
/// It exposes methods that can operate on this data type through `CellRendererToggleProtocol` conformance.
/// Use `CellRendererToggleRef` only as an `unowned` reference to an existing `GtkCellRendererToggle` instance.
///
/// `GtkCellRendererToggle` renders a toggle button in a cell. The
/// button is drawn as a radio or a checkbutton, depending on the
/// `GtkCellRendererToggle:radio` property.
/// When activated, it emits the `GtkCellRendererToggle::toggled` signal.
public struct CellRendererToggleRef: CellRendererToggleProtocol {
        /// Untyped pointer to the underlying `GtkCellRendererToggle` instance.
    /// For type-safe access, use the generated, typed pointer `cell_renderer_toggle_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellRendererToggleRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellRendererToggle>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellRendererToggle>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellRendererToggle>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellRendererToggle>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellRendererToggleProtocol`
    @inlinable init<T: CellRendererToggleProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCellRendererToggle`. Adjust rendering
    /// parameters using object properties. Object properties can be set
    /// globally (with `g_object_set()`). Also, with `GtkTreeViewColumn`, you
    /// can bind a property to a value in a `GtkTreeModel`. For example, you
    /// can bind the “active” property on the cell renderer to a boolean value
    /// in the model, thus causing the check button to reflect the state of
    /// the model.
    @inlinable init() {
        let rv = gtk_cell_renderer_toggle_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `CellRendererToggle` type acts as a reference-counted owner of an underlying `GtkCellRendererToggle` instance.
/// It provides the methods that can operate on this data type through `CellRendererToggleProtocol` conformance.
/// Use `CellRendererToggle` as a strong reference or owner of a `GtkCellRendererToggle` instance.
///
/// `GtkCellRendererToggle` renders a toggle button in a cell. The
/// button is drawn as a radio or a checkbutton, depending on the
/// `GtkCellRendererToggle:radio` property.
/// When activated, it emits the `GtkCellRendererToggle::toggled` signal.
open class CellRendererToggle: CellRenderer, CellRendererToggleProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererToggle` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCellRendererToggle>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererToggle` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCellRendererToggle>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererToggle` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererToggle` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererToggle` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCellRendererToggle>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererToggle` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCellRendererToggle>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCellRendererToggle`.
    /// i.e., ownership is transferred to the `CellRendererToggle` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCellRendererToggle>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CellRendererToggleProtocol`
    /// Will retain `GtkCellRendererToggle`.
    /// - Parameter other: an instance of a related type that implements `CellRendererToggleProtocol`
    @inlinable public init<T: CellRendererToggleProtocol>(cellRendererToggle other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkCellRendererToggle`. Adjust rendering
    /// parameters using object properties. Object properties can be set
    /// globally (with `g_object_set()`). Also, with `GtkTreeViewColumn`, you
    /// can bind a property to a value in a `GtkTreeModel`. For example, you
    /// can bind the “active” property on the cell renderer to a boolean value
    /// in the model, thus causing the check button to reflect the state of
    /// the model.
    @inlinable public init() {
        let rv = gtk_cell_renderer_toggle_new()
        super.init(gpointer: gpointer(rv))
    }


}

public enum CellRendererTogglePropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case activatable = "activatable"
    case active = "active"
    case cellBackground = "cell-background"
    /// Cell background as a `GdkRGBA`
    case cellBackgroundRgba = "cell-background-rgba"
    case cellBackgroundSet = "cell-background-set"
    case editing = "editing"
    case height = "height"
    case inconsistent = "inconsistent"
    case isExpanded = "is-expanded"
    case isExpander = "is-expander"
    case mode = "mode"
    case radio = "radio"
    case sensitive = "sensitive"
    case visible = "visible"
    case width = "width"
    case xalign = "xalign"
    case xpad = "xpad"
    case yalign = "yalign"
    case ypad = "ypad"
}

public extension CellRendererToggleProtocol {
    /// Bind a `CellRendererTogglePropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellRendererTogglePropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CellRendererToggle property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CellRendererTogglePropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CellRendererToggle property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CellRendererTogglePropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CellRendererToggleSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// This signal gets emitted when the user cancels the process of editing a
    /// cell.  For example, an editable cell renderer could be written to cancel
    /// editing when the user presses Escape.
    /// 
    /// See also: `gtk_cell_renderer_stop_editing()`.
    case editingCanceled = "editing-canceled"
    /// This signal gets emitted when a cell starts to be edited.
    /// The intended use of this signal is to do special setup
    /// on `editable`, e.g. adding a `GtkEntryCompletion` or setting
    /// up additional columns in a `GtkComboBox`.
    /// 
    /// See `gtk_cell_editable_start_editing()` for information on the lifecycle of
    /// the `editable` and a way to do setup that doesn’t depend on the `renderer`.
    /// 
    /// Note that GTK doesn't guarantee that cell renderers will
    /// continue to use the same kind of widget for editing in future
    /// releases, therefore you should check the type of `editable`
    /// before doing any specific setup, as in the following example:
    /// (C Language Example):
    /// ```C
    /// static void
    /// text_editing_started (GtkCellRenderer *cell,
    ///                       GtkCellEditable *editable,
    ///                       const char      *path,
    ///                       gpointer         data)
    /// {
    ///   if (GTK_IS_ENTRY (editable))
    ///     {
    ///       GtkEntry *entry = GTK_ENTRY (editable);
    ///       
    ///       // ... create a GtkEntryCompletion
    ///       
    ///       gtk_entry_set_completion (entry, completion);
    ///     }
    /// }
    /// ```
    /// 
    case editingStarted = "editing-started"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The `toggled` signal is emitted when the cell is toggled.
    /// 
    /// It is the responsibility of the application to update the model
    /// with the correct value to store at `path`.  Often this is simply the
    /// opposite of the value currently stored at `path`.
    case toggled = "toggled"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyActivatable = "notify::activatable"
    case notifyActive = "notify::active"
    case notifyCellBackground = "notify::cell-background"
    /// Cell background as a `GdkRGBA`
    case notifyCellBackgroundRgba = "notify::cell-background-rgba"
    case notifyCellBackgroundSet = "notify::cell-background-set"
    case notifyEditing = "notify::editing"
    case notifyHeight = "notify::height"
    case notifyInconsistent = "notify::inconsistent"
    case notifyIsExpanded = "notify::is-expanded"
    case notifyIsExpander = "notify::is-expander"
    case notifyMode = "notify::mode"
    case notifyRadio = "notify::radio"
    case notifySensitive = "notify::sensitive"
    case notifyVisible = "notify::visible"
    case notifyWidth = "notify::width"
    case notifyXalign = "notify::xalign"
    case notifyXpad = "notify::xpad"
    case notifyYalign = "notify::yalign"
    case notifyYpad = "notify::ypad"
}

public extension CellRendererToggleProtocol {
    /// Connect a `CellRendererToggleSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @inlinable @discardableResult func connect(signal kind: CellRendererToggleSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> Int {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> Int {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(raw: ptr).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

// MARK: CellRendererToggle Class: CellRendererToggleProtocol extension (methods and fields)
public extension CellRendererToggleProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellRendererToggle` instance.
    @inlinable var cell_renderer_toggle_ptr: UnsafeMutablePointer<GtkCellRendererToggle>! { return ptr?.assumingMemoryBound(to: GtkCellRendererToggle.self) }

    /// Returns whether the cell renderer is activatable. See
    /// `gtk_cell_renderer_toggle_set_activatable()`.
    @inlinable func getActivatable() -> Bool {
        let rv = ((gtk_cell_renderer_toggle_get_activatable(cell_renderer_toggle_ptr)) != 0)
        return rv
    }

    /// Returns whether the cell renderer is active. See
    /// `gtk_cell_renderer_toggle_set_active()`.
    @inlinable func getActive() -> Bool {
        let rv = ((gtk_cell_renderer_toggle_get_active(cell_renderer_toggle_ptr)) != 0)
        return rv
    }

    /// Returns whether we’re rendering radio toggles rather than checkboxes.
    @inlinable func getRadio() -> Bool {
        let rv = ((gtk_cell_renderer_toggle_get_radio(cell_renderer_toggle_ptr)) != 0)
        return rv
    }

    /// Makes the cell renderer activatable.
    @inlinable func setActivatable(setting: Bool) {
        gtk_cell_renderer_toggle_set_activatable(cell_renderer_toggle_ptr, gboolean((setting) ? 1 : 0))
    
    }

    /// Activates or deactivates a cell renderer.
    @inlinable func setActive(setting: Bool) {
        gtk_cell_renderer_toggle_set_active(cell_renderer_toggle_ptr, gboolean((setting) ? 1 : 0))
    
    }

    /// If `radio` is `true`, the cell renderer renders a radio toggle
    /// (i.e. a toggle in a group of mutually-exclusive toggles).
    /// If `false`, it renders a check toggle (a standalone boolean option).
    /// This can be set globally for the cell renderer, or changed just
    /// before rendering each cell in the model (for `GtkTreeView`, you set
    /// up a per-row setting using `GtkTreeViewColumn` to associate model
    /// columns with cell renderer properties).
    @inlinable func set(radio: Bool) {
        gtk_cell_renderer_toggle_set_radio(cell_renderer_toggle_ptr, gboolean((radio) ? 1 : 0))
    
    }
    @inlinable var activatable: Bool {
        /// Returns whether the cell renderer is activatable. See
        /// `gtk_cell_renderer_toggle_set_activatable()`.
        get {
            let rv = ((gtk_cell_renderer_toggle_get_activatable(cell_renderer_toggle_ptr)) != 0)
            return rv
        }
        /// Makes the cell renderer activatable.
        nonmutating set {
            gtk_cell_renderer_toggle_set_activatable(cell_renderer_toggle_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    @inlinable var active: Bool {
        /// Returns whether the cell renderer is active. See
        /// `gtk_cell_renderer_toggle_set_active()`.
        get {
            let rv = ((gtk_cell_renderer_toggle_get_active(cell_renderer_toggle_ptr)) != 0)
            return rv
        }
        /// Activates or deactivates a cell renderer.
        nonmutating set {
            gtk_cell_renderer_toggle_set_active(cell_renderer_toggle_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    @inlinable var radio: Bool {
        /// Returns whether we’re rendering radio toggles rather than checkboxes.
        get {
            let rv = ((gtk_cell_renderer_toggle_get_radio(cell_renderer_toggle_ptr)) != 0)
            return rv
        }
        /// If `radio` is `true`, the cell renderer renders a radio toggle
        /// (i.e. a toggle in a group of mutually-exclusive toggles).
        /// If `false`, it renders a check toggle (a standalone boolean option).
        /// This can be set globally for the cell renderer, or changed just
        /// before rendering each cell in the model (for `GtkTreeView`, you set
        /// up a per-row setting using `GtkTreeViewColumn` to associate model
        /// columns with cell renderer properties).
        nonmutating set {
            gtk_cell_renderer_toggle_set_radio(cell_renderer_toggle_ptr, gboolean((newValue) ? 1 : 0))
        }
    }


}



// MARK: - CellView Class

/// The `CellViewProtocol` protocol exposes the methods and properties of an underlying `GtkCellView` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellView`.
/// Alternatively, use `CellViewRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A `GtkCellView` displays a single row of a `GtkTreeModel` using a `GtkCellArea`
/// and `GtkCellAreaContext`. A `GtkCellAreaContext` can be provided to the
/// `GtkCellView` at construction time in order to keep the cellview in context
/// of a group of cell views, this ensures that the renderers displayed will
/// be properly aligned with each other (like the aligned cells in the menus
/// of `GtkComboBox`).
/// 
/// `GtkCellView` is `GtkOrientable` in order to decide in which orientation
/// the underlying `GtkCellAreaContext` should be allocated. Taking the `GtkComboBox`
/// menu as an example, cellviews should be oriented horizontally if the menus are
/// listed top-to-bottom and thus all share the same width but may have separate
/// individual heights (left-to-right menus should be allocated vertically since
/// they all share the same height but may have variable widths).
/// 
/// # CSS nodes
/// 
/// GtkCellView has a single CSS node with name cellview.
public protocol CellViewProtocol: WidgetProtocol, CellLayoutProtocol, OrientableProtocol {
        /// Untyped pointer to the underlying `GtkCellView` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellView` instance.
    var cell_view_ptr: UnsafeMutablePointer<GtkCellView>! { get }

}

/// The `CellViewRef` type acts as a lightweight Swift reference to an underlying `GtkCellView` instance.
/// It exposes methods that can operate on this data type through `CellViewProtocol` conformance.
/// Use `CellViewRef` only as an `unowned` reference to an existing `GtkCellView` instance.
///
/// A `GtkCellView` displays a single row of a `GtkTreeModel` using a `GtkCellArea`
/// and `GtkCellAreaContext`. A `GtkCellAreaContext` can be provided to the
/// `GtkCellView` at construction time in order to keep the cellview in context
/// of a group of cell views, this ensures that the renderers displayed will
/// be properly aligned with each other (like the aligned cells in the menus
/// of `GtkComboBox`).
/// 
/// `GtkCellView` is `GtkOrientable` in order to decide in which orientation
/// the underlying `GtkCellAreaContext` should be allocated. Taking the `GtkComboBox`
/// menu as an example, cellviews should be oriented horizontally if the menus are
/// listed top-to-bottom and thus all share the same width but may have separate
/// individual heights (left-to-right menus should be allocated vertically since
/// they all share the same height but may have variable widths).
/// 
/// # CSS nodes
/// 
/// GtkCellView has a single CSS node with name cellview.
public struct CellViewRef: CellViewProtocol {
        /// Untyped pointer to the underlying `GtkCellView` instance.
    /// For type-safe access, use the generated, typed pointer `cell_view_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellViewRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellView>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellView>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellView>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellView>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellViewProtocol`
    @inlinable init<T: CellViewProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCellView` widget.
    @inlinable init() {
        let rv = gtk_cell_view_new()
        ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GtkCellView` widget with a specific `GtkCellArea`
    /// to layout cells and a specific `GtkCellAreaContext`.
    /// 
    /// Specifying the same context for a handful of cells lets
    /// the underlying area synchronize the geometry for those cells,
    /// in this way alignments with cellviews for other rows are
    /// possible.
    @inlinable init<CellAreaContextT: CellAreaContextProtocol, CellAreaT: CellAreaProtocol>(context area: CellAreaT, context: CellAreaContextT) {
        let rv = gtk_cell_view_new_with_context(area.cell_area_ptr, context.cell_area_context_ptr)
        ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererText`
    /// to it, and makes it show `markup`. The text can be
    /// marked up with the [Pango text markup language](#PangoMarkupFormat).
    @inlinable init(markup: UnsafePointer<CChar>!) {
        let rv = gtk_cell_view_new_with_markup(markup)
        ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererText`
    /// to it, and makes it show `text`.
    @inlinable init(text: UnsafePointer<CChar>!) {
        let rv = gtk_cell_view_new_with_text(text)
        ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererPixbuf`
    /// to it, and makes it show `texture`.
    @inlinable init(texture: UnsafeMutablePointer<GdkTexture>!) {
        let rv = gtk_cell_view_new_with_texture(texture)
        ptr = UnsafeMutableRawPointer(rv)
    }
    /// Creates a new `GtkCellView` widget with a specific `GtkCellArea`
    /// to layout cells and a specific `GtkCellAreaContext`.
    /// 
    /// Specifying the same context for a handful of cells lets
    /// the underlying area synchronize the geometry for those cells,
    /// in this way alignments with cellviews for other rows are
    /// possible.
    @inlinable static func newWith<CellAreaContextT: CellAreaContextProtocol, CellAreaT: CellAreaProtocol>(context area: CellAreaT, context: CellAreaContextT) -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_cell_view_new_with_context(area.cell_area_ptr, context.cell_area_context_ptr))) else { return nil }
        return rv
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererText`
    /// to it, and makes it show `markup`. The text can be
    /// marked up with the [Pango text markup language](#PangoMarkupFormat).
    @inlinable static func newWith(markup: UnsafePointer<CChar>!) -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_cell_view_new_with_markup(markup))) else { return nil }
        return rv
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererText`
    /// to it, and makes it show `text`.
    @inlinable static func newWith(text: UnsafePointer<CChar>!) -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_cell_view_new_with_text(text))) else { return nil }
        return rv
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererPixbuf`
    /// to it, and makes it show `texture`.
    @inlinable static func newWith(texture: UnsafeMutablePointer<GdkTexture>!) -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_cell_view_new_with_texture(texture))) else { return nil }
        return rv
    }
}

/// The `CellView` type acts as a reference-counted owner of an underlying `GtkCellView` instance.
/// It provides the methods that can operate on this data type through `CellViewProtocol` conformance.
/// Use `CellView` as a strong reference or owner of a `GtkCellView` instance.
///
/// A `GtkCellView` displays a single row of a `GtkTreeModel` using a `GtkCellArea`
/// and `GtkCellAreaContext`. A `GtkCellAreaContext` can be provided to the
/// `GtkCellView` at construction time in order to keep the cellview in context
/// of a group of cell views, this ensures that the renderers displayed will
/// be properly aligned with each other (like the aligned cells in the menus
/// of `GtkComboBox`).
/// 
/// `GtkCellView` is `GtkOrientable` in order to decide in which orientation
/// the underlying `GtkCellAreaContext` should be allocated. Taking the `GtkComboBox`
/// menu as an example, cellviews should be oriented horizontally if the menus are
/// listed top-to-bottom and thus all share the same width but may have separate
/// individual heights (left-to-right menus should be allocated vertically since
/// they all share the same height but may have variable widths).
/// 
/// # CSS nodes
/// 
/// GtkCellView has a single CSS node with name cellview.
open class CellView: Widget, CellViewProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCellView>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCellView>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellView` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCellView>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCellView>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCellView`.
    /// i.e., ownership is transferred to the `CellView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCellView>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CellViewProtocol`
    /// Will retain `GtkCellView`.
    /// - Parameter other: an instance of a related type that implements `CellViewProtocol`
    @inlinable public init<T: CellViewProtocol>(cellView other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkCellView` widget.
    @inlinable public init() {
        let rv = gtk_cell_view_new()
        super.init(gpointer: gpointer(rv))
    }

    /// Creates a new `GtkCellView` widget with a specific `GtkCellArea`
    /// to layout cells and a specific `GtkCellAreaContext`.
    /// 
    /// Specifying the same context for a handful of cells lets
    /// the underlying area synchronize the geometry for those cells,
    /// in this way alignments with cellviews for other rows are
    /// possible.
    @inlinable public init<CellAreaContextT: CellAreaContextProtocol, CellAreaT: CellAreaProtocol>(context area: CellAreaT, context: CellAreaContextT) {
        let rv = gtk_cell_view_new_with_context(area.cell_area_ptr, context.cell_area_context_ptr)
        super.init(gpointer: gpointer(rv))
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererText`
    /// to it, and makes it show `markup`. The text can be
    /// marked up with the [Pango text markup language](#PangoMarkupFormat).
    @inlinable public init(markup: UnsafePointer<CChar>!) {
        let rv = gtk_cell_view_new_with_markup(markup)
        super.init(gpointer: gpointer(rv))
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererText`
    /// to it, and makes it show `text`.
    @inlinable public init(text: UnsafePointer<CChar>!) {
        let rv = gtk_cell_view_new_with_text(text)
        super.init(gpointer: gpointer(rv))
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererPixbuf`
    /// to it, and makes it show `texture`.
    @inlinable public init(texture: UnsafeMutablePointer<GdkTexture>!) {
        let rv = gtk_cell_view_new_with_texture(texture)
        super.init(gpointer: gpointer(rv))
    }

    /// Creates a new `GtkCellView` widget with a specific `GtkCellArea`
    /// to layout cells and a specific `GtkCellAreaContext`.
    /// 
    /// Specifying the same context for a handful of cells lets
    /// the underlying area synchronize the geometry for those cells,
    /// in this way alignments with cellviews for other rows are
    /// possible.
    @inlinable public static func newWith<CellAreaContextT: CellAreaContextProtocol, CellAreaT: CellAreaProtocol>(context area: CellAreaT, context: CellAreaContextT) -> Widget! {
        guard let rv = Widget(gconstpointer: gconstpointer(gtk_cell_view_new_with_context(area.cell_area_ptr, context.cell_area_context_ptr))) else { return nil }
        return rv
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererText`
    /// to it, and makes it show `markup`. The text can be
    /// marked up with the [Pango text markup language](#PangoMarkupFormat).
    @inlinable public static func newWith(markup: UnsafePointer<CChar>!) -> Widget! {
        guard let rv = Widget(gconstpointer: gconstpointer(gtk_cell_view_new_with_markup(markup))) else { return nil }
        return rv
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererText`
    /// to it, and makes it show `text`.
    @inlinable public static func newWith(text: UnsafePointer<CChar>!) -> Widget! {
        guard let rv = Widget(gconstpointer: gconstpointer(gtk_cell_view_new_with_text(text))) else { return nil }
        return rv
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererPixbuf`
    /// to it, and makes it show `texture`.
    @inlinable public static func newWith(texture: UnsafeMutablePointer<GdkTexture>!) -> Widget! {
        guard let rv = Widget(gconstpointer: gconstpointer(gtk_cell_view_new_with_texture(texture))) else { return nil }
        return rv
    }

}

public enum CellViewPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    case canTarget = "can-target"
    /// The `GtkCellArea` rendering cells
    /// 
    /// If no area is specified when creating the cell view with `gtk_cell_view_new_with_context()`
    /// a horizontally oriented `GtkCellAreaBox` will be used.
    /// 
    /// since 3.0
    case cellArea = "cell-area"
    /// The `GtkCellAreaContext` used to compute the geometry of the cell view.
    /// 
    /// A group of cell views can be assigned the same context in order to
    /// ensure the sizes and cell alignments match across all the views with
    /// the same context.
    /// 
    /// `GtkComboBox` menus uses this to assign the same context to all cell views
    /// in the menu items for a single menu (each submenu creates its own
    /// context since the size of each submenu does not depend on parent
    /// or sibling menus).
    /// 
    /// since 3.0
    case cellAreaContext = "cell-area-context"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`. See `gtk_widget_set_cursor()` for details.
    case cursor = "cursor"
    /// Whether all cells should be draw as sensitive for this view regardless
    /// of the actual cell properties (used to make menus with submenus appear
    /// sensitive when the items in submenus might be insensitive).
    /// 
    /// since 3.0
    case drawSensitive = "draw-sensitive"
    /// Whether the view should request enough space to always fit
    /// the size of every row in the model (used by the combo box to
    /// ensure the combo box size doesn't change when different items
    /// are selected).
    /// 
    /// since 3.0
    case fitModel = "fit-model"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    /// The model for cell view
    /// 
    /// since 2.10
    case model = "model"
    case name = "name"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    case parent = "parent"
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget or `nil` if
    /// the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
}

public extension CellViewProtocol {
    /// Bind a `CellViewPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellViewPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CellView property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CellViewPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CellView property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CellViewPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CellViewSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold. May result in finalization of the widget
    /// if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// The `direction`-changed signal is emitted when the text direction
    /// of a widget changes.
    case directionChanged = "direction-changed"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The `hide` signal is emitted when `widget` is hidden, for example with
    /// `gtk_widget_hide()`.
    case hide = "hide"
    /// Gets emitted if keyboard navigation fails.
    /// See `gtk_widget_keynav_failed()` for details.
    case keynavFailed = "keynav-failed"
    /// The `map` signal is emitted when `widget` is going to be mapped, that is
    /// when the widget is visible (which is controlled with
    /// `gtk_widget_set_visible()`) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of `GtkWidget::unmap`.
    case map = "map"
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// Emitted when `GtkWidget:has`-tooltip is `true` and the hover timeout
    /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
    /// focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// The `realize` signal is emitted when `widget` is associated with a
    /// `GdkSurface`, which means that `gtk_widget_realize()` has been called or the
    /// widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// The `show` signal is emitted when `widget` is shown, for example with
    /// `gtk_widget_show()`.
    case show = "show"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The `state`-flags-changed signal is emitted when the widget state
    /// changes, see `gtk_widget_get_state_flags()`.
    case stateFlagsChanged = "state-flags-changed"
    /// The `unmap` signal is emitted when `widget` is going to be unmapped, which
    /// means that either it or any of its parents up to the toplevel widget have
    /// been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer, it can be
    /// used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// The `unrealize` signal is emitted when the `GdkSurface` associated with
    /// `widget` is destroyed, which means that `gtk_widget_unrealize()` has been
    /// called or the widget has been unmapped (that is, it is going to be
    /// hidden).
    case unrealize = "unrealize"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    case notifyCanTarget = "notify::can-target"
    /// The `GtkCellArea` rendering cells
    /// 
    /// If no area is specified when creating the cell view with `gtk_cell_view_new_with_context()`
    /// a horizontally oriented `GtkCellAreaBox` will be used.
    /// 
    /// since 3.0
    case notifyCellArea = "notify::cell-area"
    /// The `GtkCellAreaContext` used to compute the geometry of the cell view.
    /// 
    /// A group of cell views can be assigned the same context in order to
    /// ensure the sizes and cell alignments match across all the views with
    /// the same context.
    /// 
    /// `GtkComboBox` menus uses this to assign the same context to all cell views
    /// in the menu items for a single menu (each submenu creates its own
    /// context since the size of each submenu does not depend on parent
    /// or sibling menus).
    /// 
    /// since 3.0
    case notifyCellAreaContext = "notify::cell-area-context"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`. See `gtk_widget_set_cursor()` for details.
    case notifyCursor = "notify::cursor"
    /// Whether all cells should be draw as sensitive for this view regardless
    /// of the actual cell properties (used to make menus with submenus appear
    /// sensitive when the items in submenus might be insensitive).
    /// 
    /// since 3.0
    case notifyDrawSensitive = "notify::draw-sensitive"
    /// Whether the view should request enough space to always fit
    /// the size of every row in the model (used by the combo box to
    /// ensure the combo box size doesn't change when different items
    /// are selected).
    /// 
    /// since 3.0
    case notifyFitModel = "notify::fit-model"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case notifyHalign = "notify::halign"
    case notifyHasDefault = "notify::has-default"
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginTop = "notify::margin-top"
    /// The model for cell view
    /// 
    /// since 2.10
    case notifyModel = "notify::model"
    case notifyName = "notify::name"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    case notifyParent = "notify::parent"
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget or `nil` if
    /// the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case notifyScaleFactor = "notify::scale-factor"
    case notifySensitive = "notify::sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case notifyValign = "notify::valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case notifyVexpandSet = "notify::vexpand-set"
    case notifyVisible = "notify::visible"
    case notifyWidthRequest = "notify::width-request"
}

public extension CellViewProtocol {
    /// Connect a `CellViewSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @inlinable @discardableResult func connect(signal kind: CellViewSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> Int {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> Int {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(raw: ptr).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

// MARK: CellView Class: CellViewProtocol extension (methods and fields)
public extension CellViewProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellView` instance.
    @inlinable var cell_view_ptr: UnsafeMutablePointer<GtkCellView>! { return ptr?.assumingMemoryBound(to: GtkCellView.self) }

    /// Returns a `GtkTreePath` referring to the currently
    /// displayed row. If no row is currently displayed,
    /// `nil` is returned.
    @inlinable func getDisplayedRow() -> TreePathRef! {
        let rv = TreePathRef(gconstpointer: gconstpointer(gtk_cell_view_get_displayed_row(cell_view_ptr)))
        return rv
    }

    /// Gets whether `cell_view` is configured to draw all of its
    /// cells in a sensitive state.
    @inlinable func getDrawSensitive() -> Bool {
        let rv = ((gtk_cell_view_get_draw_sensitive(cell_view_ptr)) != 0)
        return rv
    }

    /// Gets whether `cell_view` is configured to request space
    /// to fit the entire `GtkTreeModel`.
    @inlinable func getFitModel() -> Bool {
        let rv = ((gtk_cell_view_get_fit_model(cell_view_ptr)) != 0)
        return rv
    }

    /// Returns the model for `cell_view`. If no model is used `nil` is
    /// returned.
    @inlinable func getModel() -> TreeModelRef! {
        let rv = TreeModelRef(gconstpointer: gconstpointer(gtk_cell_view_get_model(cell_view_ptr)))
        return rv
    }

    /// Sets the row of the model that is currently displayed
    /// by the `GtkCellView`. If the path is unset, then the
    /// contents of the cellview “stick” at their last value;
    /// this is not normally a desired result, but may be
    /// a needed intermediate state if say, the model for
    /// the `GtkCellView` becomes temporarily empty.
    @inlinable func setDisplayedRow(path: TreePathRef? = nil) {
        gtk_cell_view_set_displayed_row(cell_view_ptr, path?.tree_path_ptr)
    
    }
    /// Sets the row of the model that is currently displayed
    /// by the `GtkCellView`. If the path is unset, then the
    /// contents of the cellview “stick” at their last value;
    /// this is not normally a desired result, but may be
    /// a needed intermediate state if say, the model for
    /// the `GtkCellView` becomes temporarily empty.
    @inlinable func setDisplayedRow<TreePathT: TreePathProtocol>(path: TreePathT?) {
        gtk_cell_view_set_displayed_row(cell_view_ptr, path?.tree_path_ptr)
    
    }

    /// Sets whether `cell_view` should draw all of its
    /// cells in a sensitive state, this is used by `GtkComboBox` menus
    /// to ensure that rows with insensitive cells that contain
    /// children appear sensitive in the parent menu item.
    @inlinable func set(drawSensitive: Bool) {
        gtk_cell_view_set_draw_sensitive(cell_view_ptr, gboolean((drawSensitive) ? 1 : 0))
    
    }

    /// Sets whether `cell_view` should request space to fit the entire `GtkTreeModel`.
    /// 
    /// This is used by `GtkComboBox` to ensure that the cell view displayed on
    /// the combo box’s button always gets enough space and does not resize
    /// when selection changes.
    @inlinable func set(fitModel: Bool) {
        gtk_cell_view_set_fit_model(cell_view_ptr, gboolean((fitModel) ? 1 : 0))
    
    }

    /// Sets the model for `cell_view`.  If `cell_view` already has a model
    /// set, it will remove it before setting the new model.  If `model` is
    /// `nil`, then it will unset the old model.
    @inlinable func set(model: TreeModelRef? = nil) {
        gtk_cell_view_set_model(cell_view_ptr, model?.tree_model_ptr)
    
    }
    /// Sets the model for `cell_view`.  If `cell_view` already has a model
    /// set, it will remove it before setting the new model.  If `model` is
    /// `nil`, then it will unset the old model.
    @inlinable func set<TreeModelT: TreeModelProtocol>(model: TreeModelT?) {
        gtk_cell_view_set_model(cell_view_ptr, model?.tree_model_ptr)
    
    }
    /// Returns a `GtkTreePath` referring to the currently
    /// displayed row. If no row is currently displayed,
    /// `nil` is returned.
    @inlinable var displayedRow: TreePathRef! {
        /// Returns a `GtkTreePath` referring to the currently
        /// displayed row. If no row is currently displayed,
        /// `nil` is returned.
        get {
            let rv = TreePathRef(gconstpointer: gconstpointer(gtk_cell_view_get_displayed_row(cell_view_ptr)))
            return rv
        }
        /// Sets the row of the model that is currently displayed
        /// by the `GtkCellView`. If the path is unset, then the
        /// contents of the cellview “stick” at their last value;
        /// this is not normally a desired result, but may be
        /// a needed intermediate state if say, the model for
        /// the `GtkCellView` becomes temporarily empty.
        nonmutating set {
            gtk_cell_view_set_displayed_row(cell_view_ptr, UnsafeMutablePointer<GtkTreePath>(newValue?.tree_path_ptr))
        }
    }

    /// Gets whether `cell_view` is configured to draw all of its
    /// cells in a sensitive state.
    @inlinable var drawSensitive: Bool {
        /// Gets whether `cell_view` is configured to draw all of its
        /// cells in a sensitive state.
        get {
            let rv = ((gtk_cell_view_get_draw_sensitive(cell_view_ptr)) != 0)
            return rv
        }
        /// Sets whether `cell_view` should draw all of its
        /// cells in a sensitive state, this is used by `GtkComboBox` menus
        /// to ensure that rows with insensitive cells that contain
        /// children appear sensitive in the parent menu item.
        nonmutating set {
            gtk_cell_view_set_draw_sensitive(cell_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Gets whether `cell_view` is configured to request space
    /// to fit the entire `GtkTreeModel`.
    @inlinable var fitModel: Bool {
        /// Gets whether `cell_view` is configured to request space
        /// to fit the entire `GtkTreeModel`.
        get {
            let rv = ((gtk_cell_view_get_fit_model(cell_view_ptr)) != 0)
            return rv
        }
        /// Sets whether `cell_view` should request space to fit the entire `GtkTreeModel`.
        /// 
        /// This is used by `GtkComboBox` to ensure that the cell view displayed on
        /// the combo box’s button always gets enough space and does not resize
        /// when selection changes.
        nonmutating set {
            gtk_cell_view_set_fit_model(cell_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// The model for cell view
    /// 
    /// since 2.10
    @inlinable var model: TreeModelRef! {
        /// Returns the model for `cell_view`. If no model is used `nil` is
        /// returned.
        get {
            let rv = TreeModelRef(gconstpointer: gconstpointer(gtk_cell_view_get_model(cell_view_ptr)))
            return rv
        }
        /// Sets the model for `cell_view`.  If `cell_view` already has a model
        /// set, it will remove it before setting the new model.  If `model` is
        /// `nil`, then it will unset the old model.
        nonmutating set {
            gtk_cell_view_set_model(cell_view_ptr, UnsafeMutablePointer<GtkTreeModel>(newValue?.tree_model_ptr))
        }
    }


}



// MARK: - CenterBox Class

/// The `CenterBoxProtocol` protocol exposes the methods and properties of an underlying `GtkCenterBox` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CenterBox`.
/// Alternatively, use `CenterBoxRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// The GtkCenterBox widget arranges three children in a horizontal
/// or vertical arrangement, keeping the middle child centered as well
/// as possible.
/// 
/// To add children to GtkCenterBox, use `gtk_center_box_set_start_widget()`,
/// `gtk_center_box_set_center_widget()` and `gtk_center_box_set_end_widget()`.
/// 
/// The sizing and positioning of children can be influenced with the
/// align and expand properties of the children.
/// 
/// # GtkCenterBox as GtkBuildable
/// 
/// The GtkCenterBox implementation of the `GtkBuildable` interface supports
/// placing children in the 3 positions by specifying “start”, “center” or
/// “end” as the “type” attribute of a <child> element.
/// 
/// # CSS nodes
/// 
/// GtkCenterBox uses a single CSS node with the name “box”,
/// 
/// The first child of the `GtkCenterBox` will be allocated depending on the
/// text direction, i.e. in left-to-right layouts it will be allocated on the
/// left and in right-to-left layouts on the right.
/// 
/// In vertical orientation, the nodes of the children are arranged from top to
/// bottom.
/// 
/// # Accessibility
/// 
/// GtkCenterBox uses the `GTK_ACCESSIBLE_ROLE_GROUP` role.
public protocol CenterBoxProtocol: WidgetProtocol, OrientableProtocol {
        /// Untyped pointer to the underlying `GtkCenterBox` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCenterBox` instance.
    var center_box_ptr: UnsafeMutablePointer<GtkCenterBox>! { get }

}

/// The `CenterBoxRef` type acts as a lightweight Swift reference to an underlying `GtkCenterBox` instance.
/// It exposes methods that can operate on this data type through `CenterBoxProtocol` conformance.
/// Use `CenterBoxRef` only as an `unowned` reference to an existing `GtkCenterBox` instance.
///
/// The GtkCenterBox widget arranges three children in a horizontal
/// or vertical arrangement, keeping the middle child centered as well
/// as possible.
/// 
/// To add children to GtkCenterBox, use `gtk_center_box_set_start_widget()`,
/// `gtk_center_box_set_center_widget()` and `gtk_center_box_set_end_widget()`.
/// 
/// The sizing and positioning of children can be influenced with the
/// align and expand properties of the children.
/// 
/// # GtkCenterBox as GtkBuildable
/// 
/// The GtkCenterBox implementation of the `GtkBuildable` interface supports
/// placing children in the 3 positions by specifying “start”, “center” or
/// “end” as the “type” attribute of a <child> element.
/// 
/// # CSS nodes
/// 
/// GtkCenterBox uses a single CSS node with the name “box”,
/// 
/// The first child of the `GtkCenterBox` will be allocated depending on the
/// text direction, i.e. in left-to-right layouts it will be allocated on the
/// left and in right-to-left layouts on the right.
/// 
/// In vertical orientation, the nodes of the children are arranged from top to
/// bottom.
/// 
/// # Accessibility
/// 
/// GtkCenterBox uses the `GTK_ACCESSIBLE_ROLE_GROUP` role.
public struct CenterBoxRef: CenterBoxProtocol {
        /// Untyped pointer to the underlying `GtkCenterBox` instance.
    /// For type-safe access, use the generated, typed pointer `center_box_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CenterBoxRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCenterBox>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCenterBox>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCenterBox>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCenterBox>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CenterBoxProtocol`
    @inlinable init<T: CenterBoxProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCenterBox`.
    @inlinable init() {
        let rv = gtk_center_box_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `CenterBox` type acts as a reference-counted owner of an underlying `GtkCenterBox` instance.
/// It provides the methods that can operate on this data type through `CenterBoxProtocol` conformance.
/// Use `CenterBox` as a strong reference or owner of a `GtkCenterBox` instance.
///
/// The GtkCenterBox widget arranges three children in a horizontal
/// or vertical arrangement, keeping the middle child centered as well
/// as possible.
/// 
/// To add children to GtkCenterBox, use `gtk_center_box_set_start_widget()`,
/// `gtk_center_box_set_center_widget()` and `gtk_center_box_set_end_widget()`.
/// 
/// The sizing and positioning of children can be influenced with the
/// align and expand properties of the children.
/// 
/// # GtkCenterBox as GtkBuildable
/// 
/// The GtkCenterBox implementation of the `GtkBuildable` interface supports
/// placing children in the 3 positions by specifying “start”, “center” or
/// “end” as the “type” attribute of a <child> element.
/// 
/// # CSS nodes
/// 
/// GtkCenterBox uses a single CSS node with the name “box”,
/// 
/// The first child of the `GtkCenterBox` will be allocated depending on the
/// text direction, i.e. in left-to-right layouts it will be allocated on the
/// left and in right-to-left layouts on the right.
/// 
/// In vertical orientation, the nodes of the children are arranged from top to
/// bottom.
/// 
/// # Accessibility
/// 
/// GtkCenterBox uses the `GTK_ACCESSIBLE_ROLE_GROUP` role.
open class CenterBox: Widget, CenterBoxProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CenterBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCenterBox>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CenterBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCenterBox>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CenterBox` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CenterBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CenterBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCenterBox>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CenterBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCenterBox>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCenterBox`.
    /// i.e., ownership is transferred to the `CenterBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCenterBox>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CenterBoxProtocol`
    /// Will retain `GtkCenterBox`.
    /// - Parameter other: an instance of a related type that implements `CenterBoxProtocol`
    @inlinable public init<T: CenterBoxProtocol>(centerBox other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkCenterBox`.
    @inlinable public init() {
        let rv = gtk_center_box_new()
        super.init(gpointer: gpointer(rv))
    }


}

public enum CenterBoxPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case baselinePosition = "baseline-position"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`. See `gtk_widget_set_cursor()` for details.
    case cursor = "cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case name = "name"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    case parent = "parent"
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget or `nil` if
    /// the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
}

public extension CenterBoxProtocol {
    /// Bind a `CenterBoxPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CenterBoxPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CenterBox property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CenterBoxPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CenterBox property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CenterBoxPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CenterBoxSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold. May result in finalization of the widget
    /// if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// The `direction`-changed signal is emitted when the text direction
    /// of a widget changes.
    case directionChanged = "direction-changed"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The `hide` signal is emitted when `widget` is hidden, for example with
    /// `gtk_widget_hide()`.
    case hide = "hide"
    /// Gets emitted if keyboard navigation fails.
    /// See `gtk_widget_keynav_failed()` for details.
    case keynavFailed = "keynav-failed"
    /// The `map` signal is emitted when `widget` is going to be mapped, that is
    /// when the widget is visible (which is controlled with
    /// `gtk_widget_set_visible()`) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of `GtkWidget::unmap`.
    case map = "map"
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// Emitted when `GtkWidget:has`-tooltip is `true` and the hover timeout
    /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
    /// focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// The `realize` signal is emitted when `widget` is associated with a
    /// `GdkSurface`, which means that `gtk_widget_realize()` has been called or the
    /// widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// The `show` signal is emitted when `widget` is shown, for example with
    /// `gtk_widget_show()`.
    case show = "show"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The `state`-flags-changed signal is emitted when the widget state
    /// changes, see `gtk_widget_get_state_flags()`.
    case stateFlagsChanged = "state-flags-changed"
    /// The `unmap` signal is emitted when `widget` is going to be unmapped, which
    /// means that either it or any of its parents up to the toplevel widget have
    /// been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer, it can be
    /// used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// The `unrealize` signal is emitted when the `GdkSurface` associated with
    /// `widget` is destroyed, which means that `gtk_widget_unrealize()` has been
    /// called or the widget has been unmapped (that is, it is going to be
    /// hidden).
    case unrealize = "unrealize"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyBaselinePosition = "notify::baseline-position"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    case notifyCanTarget = "notify::can-target"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`. See `gtk_widget_set_cursor()` for details.
    case notifyCursor = "notify::cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case notifyHalign = "notify::halign"
    case notifyHasDefault = "notify::has-default"
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginTop = "notify::margin-top"
    case notifyName = "notify::name"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    case notifyParent = "notify::parent"
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget or `nil` if
    /// the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case notifyScaleFactor = "notify::scale-factor"
    case notifySensitive = "notify::sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case notifyValign = "notify::valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case notifyVexpandSet = "notify::vexpand-set"
    case notifyVisible = "notify::visible"
    case notifyWidthRequest = "notify::width-request"
}

public extension CenterBoxProtocol {
    /// Connect a `CenterBoxSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @inlinable @discardableResult func connect(signal kind: CenterBoxSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> Int {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> Int {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(raw: ptr).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

// MARK: CenterBox Class: CenterBoxProtocol extension (methods and fields)
public extension CenterBoxProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCenterBox` instance.
    @inlinable var center_box_ptr: UnsafeMutablePointer<GtkCenterBox>! { return ptr?.assumingMemoryBound(to: GtkCenterBox.self) }

    /// Gets the value set by `gtk_center_box_set_baseline_position()`.
    @inlinable func getBaselinePosition() -> GtkBaselinePosition {
        let rv = gtk_center_box_get_baseline_position(center_box_ptr)
        return rv
    }

    /// Gets the center widget, or `nil` if there is none.
    @inlinable func getCenterWidget() -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_center_box_get_center_widget(center_box_ptr))) else { return nil }
        return rv
    }

    /// Gets the end widget, or `nil` if there is none.
    @inlinable func getEndWidget() -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_center_box_get_end_widget(center_box_ptr))) else { return nil }
        return rv
    }

    /// Gets the start widget, or `nil` if there is none.
    @inlinable func getStartWidget() -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_center_box_get_start_widget(center_box_ptr))) else { return nil }
        return rv
    }

    /// Sets the baseline position of a center box.
    /// 
    /// This affects only horizontal boxes with at least one baseline
    /// aligned child. If there is more vertical space available than
    /// requested, and the baseline is not allocated by the parent then
    /// `position` is used to allocate the baseline wrt. the extra space
    /// available.
    @inlinable func setBaseline(position: GtkBaselinePosition) {
        gtk_center_box_set_baseline_position(center_box_ptr, position)
    
    }

    /// Sets the center widget. To remove the existing center widget, pas `nil`.
    @inlinable func setCenterWidget(child: WidgetRef? = nil) {
        gtk_center_box_set_center_widget(center_box_ptr, child?.widget_ptr)
    
    }
    /// Sets the center widget. To remove the existing center widget, pas `nil`.
    @inlinable func setCenterWidget<WidgetT: WidgetProtocol>(child: WidgetT?) {
        gtk_center_box_set_center_widget(center_box_ptr, child?.widget_ptr)
    
    }

    /// Sets the end widget. To remove the existing end widget, pass `nil`.
    @inlinable func setEndWidget(child: WidgetRef? = nil) {
        gtk_center_box_set_end_widget(center_box_ptr, child?.widget_ptr)
    
    }
    /// Sets the end widget. To remove the existing end widget, pass `nil`.
    @inlinable func setEndWidget<WidgetT: WidgetProtocol>(child: WidgetT?) {
        gtk_center_box_set_end_widget(center_box_ptr, child?.widget_ptr)
    
    }

    /// Sets the start widget. To remove the existing start widget, pass `nil`.
    @inlinable func setStartWidget(child: WidgetRef? = nil) {
        gtk_center_box_set_start_widget(center_box_ptr, child?.widget_ptr)
    
    }
    /// Sets the start widget. To remove the existing start widget, pass `nil`.
    @inlinable func setStartWidget<WidgetT: WidgetProtocol>(child: WidgetT?) {
        gtk_center_box_set_start_widget(center_box_ptr, child?.widget_ptr)
    
    }
    /// Gets the value set by `gtk_center_box_set_baseline_position()`.
    @inlinable var baselinePosition: GtkBaselinePosition {
        /// Gets the value set by `gtk_center_box_set_baseline_position()`.
        get {
            let rv = gtk_center_box_get_baseline_position(center_box_ptr)
            return rv
        }
        /// Sets the baseline position of a center box.
        /// 
        /// This affects only horizontal boxes with at least one baseline
        /// aligned child. If there is more vertical space available than
        /// requested, and the baseline is not allocated by the parent then
        /// `position` is used to allocate the baseline wrt. the extra space
        /// available.
        nonmutating set {
            gtk_center_box_set_baseline_position(center_box_ptr, newValue)
        }
    }

    /// Gets the center widget, or `nil` if there is none.
    @inlinable var centerWidget: WidgetRef! {
        /// Gets the center widget, or `nil` if there is none.
        get {
            guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_center_box_get_center_widget(center_box_ptr))) else { return nil }
            return rv
        }
        /// Sets the center widget. To remove the existing center widget, pas `nil`.
        nonmutating set {
            gtk_center_box_set_center_widget(center_box_ptr, UnsafeMutablePointer<GtkWidget>(newValue?.widget_ptr))
        }
    }

    /// Gets the end widget, or `nil` if there is none.
    @inlinable var endWidget: WidgetRef! {
        /// Gets the end widget, or `nil` if there is none.
        get {
            guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_center_box_get_end_widget(center_box_ptr))) else { return nil }
            return rv
        }
        /// Sets the end widget. To remove the existing end widget, pass `nil`.
        nonmutating set {
            gtk_center_box_set_end_widget(center_box_ptr, UnsafeMutablePointer<GtkWidget>(newValue?.widget_ptr))
        }
    }

    /// Gets the start widget, or `nil` if there is none.
    @inlinable var startWidget: WidgetRef! {
        /// Gets the start widget, or `nil` if there is none.
        get {
            guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_center_box_get_start_widget(center_box_ptr))) else { return nil }
            return rv
        }
        /// Sets the start widget. To remove the existing start widget, pass `nil`.
        nonmutating set {
            gtk_center_box_set_start_widget(center_box_ptr, UnsafeMutablePointer<GtkWidget>(newValue?.widget_ptr))
        }
    }


}



// MARK: - CenterLayout Class

/// The `CenterLayoutProtocol` protocol exposes the methods and properties of an underlying `GtkCenterLayout` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CenterLayout`.
/// Alternatively, use `CenterLayoutRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A `GtkCenterLayout` is a layout manager that manages up to three children.
/// The start widget is allocated at the start of the layout (left in LRT
/// layouts and right in RTL ones), and the end widget at the end.
/// 
/// The center widget is centered regarding the full width of the layout's.
public protocol CenterLayoutProtocol: LayoutManagerProtocol {
        /// Untyped pointer to the underlying `GtkCenterLayout` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCenterLayout` instance.
    var center_layout_ptr: UnsafeMutablePointer<GtkCenterLayout>! { get }

}

/// The `CenterLayoutRef` type acts as a lightweight Swift reference to an underlying `GtkCenterLayout` instance.
/// It exposes methods that can operate on this data type through `CenterLayoutProtocol` conformance.
/// Use `CenterLayoutRef` only as an `unowned` reference to an existing `GtkCenterLayout` instance.
///
/// A `GtkCenterLayout` is a layout manager that manages up to three children.
/// The start widget is allocated at the start of the layout (left in LRT
/// layouts and right in RTL ones), and the end widget at the end.
/// 
/// The center widget is centered regarding the full width of the layout's.
public struct CenterLayoutRef: CenterLayoutProtocol {
        /// Untyped pointer to the underlying `GtkCenterLayout` instance.
    /// For type-safe access, use the generated, typed pointer `center_layout_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CenterLayoutRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCenterLayout>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCenterLayout>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCenterLayout>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCenterLayout>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CenterLayoutProtocol`
    @inlinable init<T: CenterLayoutProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCenterLayout`.
    @inlinable init() {
        let rv = gtk_center_layout_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `CenterLayout` type acts as a reference-counted owner of an underlying `GtkCenterLayout` instance.
/// It provides the methods that can operate on this data type through `CenterLayoutProtocol` conformance.
/// Use `CenterLayout` as a strong reference or owner of a `GtkCenterLayout` instance.
///
/// A `GtkCenterLayout` is a layout manager that manages up to three children.
/// The start widget is allocated at the start of the layout (left in LRT
/// layouts and right in RTL ones), and the end widget at the end.
/// 
/// The center widget is centered regarding the full width of the layout's.
open class CenterLayout: LayoutManager, CenterLayoutProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CenterLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCenterLayout>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CenterLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCenterLayout>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CenterLayout` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CenterLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CenterLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCenterLayout>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CenterLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCenterLayout>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCenterLayout`.
    /// i.e., ownership is transferred to the `CenterLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCenterLayout>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CenterLayoutProtocol`
    /// Will retain `GtkCenterLayout`.
    /// - Parameter other: an instance of a related type that implements `CenterLayoutProtocol`
    @inlinable public init<T: CenterLayoutProtocol>(centerLayout other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkCenterLayout`.
    @inlinable public init() {
        let rv = gtk_center_layout_new()
        super.init(gpointer: gpointer(rv))
    }


}

// MARK: no CenterLayout properties

public enum CenterLayoutSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"

}

public extension CenterLayoutProtocol {
    /// Connect a `CenterLayoutSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @inlinable @discardableResult func connect(signal kind: CenterLayoutSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> Int {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> Int {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(raw: ptr).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

// MARK: CenterLayout Class: CenterLayoutProtocol extension (methods and fields)
public extension CenterLayoutProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCenterLayout` instance.
    @inlinable var center_layout_ptr: UnsafeMutablePointer<GtkCenterLayout>! { return ptr?.assumingMemoryBound(to: GtkCenterLayout.self) }

    /// Returns the baseline position of the layout.
    @inlinable func getBaselinePosition() -> GtkBaselinePosition {
        let rv = gtk_center_layout_get_baseline_position(center_layout_ptr)
        return rv
    }

    /// Returns the center widget of the layout.
    @inlinable func getCenterWidget() -> WidgetRef! {
        let rv = WidgetRef(gconstpointer: gconstpointer(gtk_center_layout_get_center_widget(center_layout_ptr)))
        return rv
    }

    /// Returns the end widget of the layout.
    @inlinable func getEndWidget() -> WidgetRef! {
        let rv = WidgetRef(gconstpointer: gconstpointer(gtk_center_layout_get_end_widget(center_layout_ptr)))
        return rv
    }

    /// Gets the current orienration of the layout manager.
    @inlinable func getOrientation() -> GtkOrientation {
        let rv = gtk_center_layout_get_orientation(center_layout_ptr)
        return rv
    }

    /// Returns the start widget fo the layout.
    @inlinable func getStartWidget() -> WidgetRef! {
        let rv = WidgetRef(gconstpointer: gconstpointer(gtk_center_layout_get_start_widget(center_layout_ptr)))
        return rv
    }

    /// Sets the new baseline position of `self`
    @inlinable func set(baselinePosition: GtkBaselinePosition) {
        gtk_center_layout_set_baseline_position(center_layout_ptr, baselinePosition)
    
    }

    /// Sets the new center widget of `self`.
    /// 
    /// To remove the existing center widget, pass `nil`.
    @inlinable func setCenter(widget: WidgetRef? = nil) {
        gtk_center_layout_set_center_widget(center_layout_ptr, widget?.widget_ptr)
    
    }
    /// Sets the new center widget of `self`.
    /// 
    /// To remove the existing center widget, pass `nil`.
    @inlinable func setCenter<WidgetT: WidgetProtocol>(widget: WidgetT?) {
        gtk_center_layout_set_center_widget(center_layout_ptr, widget?.widget_ptr)
    
    }

    /// Sets the new end widget of `self`.
    /// 
    /// To remove the existing center widget, pass `nil`.
    @inlinable func setEnd(widget: WidgetRef? = nil) {
        gtk_center_layout_set_end_widget(center_layout_ptr, widget?.widget_ptr)
    
    }
    /// Sets the new end widget of `self`.
    /// 
    /// To remove the existing center widget, pass `nil`.
    @inlinable func setEnd<WidgetT: WidgetProtocol>(widget: WidgetT?) {
        gtk_center_layout_set_end_widget(center_layout_ptr, widget?.widget_ptr)
    
    }

    /// Sets the orientation of `self`.
    @inlinable func set(orientation: GtkOrientation) {
        gtk_center_layout_set_orientation(center_layout_ptr, orientation)
    
    }

    /// Sets the new start widget of `self`.
    /// 
    /// To remove the existing start widget, pass `nil`.
    @inlinable func setStart(widget: WidgetRef? = nil) {
        gtk_center_layout_set_start_widget(center_layout_ptr, widget?.widget_ptr)
    
    }
    /// Sets the new start widget of `self`.
    /// 
    /// To remove the existing start widget, pass `nil`.
    @inlinable func setStart<WidgetT: WidgetProtocol>(widget: WidgetT?) {
        gtk_center_layout_set_start_widget(center_layout_ptr, widget?.widget_ptr)
    
    }
    /// Returns the baseline position of the layout.
    @inlinable var baselinePosition: GtkBaselinePosition {
        /// Returns the baseline position of the layout.
        get {
            let rv = gtk_center_layout_get_baseline_position(center_layout_ptr)
            return rv
        }
        /// Sets the new baseline position of `self`
        nonmutating set {
            gtk_center_layout_set_baseline_position(center_layout_ptr, newValue)
        }
    }

    /// Returns the center widget of the layout.
    @inlinable var centerWidget: WidgetRef! {
        /// Returns the center widget of the layout.
        get {
            let rv = WidgetRef(gconstpointer: gconstpointer(gtk_center_layout_get_center_widget(center_layout_ptr)))
            return rv
        }
        /// Sets the new center widget of `self`.
        /// 
        /// To remove the existing center widget, pass `nil`.
        nonmutating set {
            gtk_center_layout_set_center_widget(center_layout_ptr, UnsafeMutablePointer<GtkWidget>(newValue?.widget_ptr))
        }
    }

    /// Returns the end widget of the layout.
    @inlinable var endWidget: WidgetRef! {
        /// Returns the end widget of the layout.
        get {
            let rv = WidgetRef(gconstpointer: gconstpointer(gtk_center_layout_get_end_widget(center_layout_ptr)))
            return rv
        }
        /// Sets the new end widget of `self`.
        /// 
        /// To remove the existing center widget, pass `nil`.
        nonmutating set {
            gtk_center_layout_set_end_widget(center_layout_ptr, UnsafeMutablePointer<GtkWidget>(newValue?.widget_ptr))
        }
    }

    /// Gets the current orienration of the layout manager.
    @inlinable var orientation: GtkOrientation {
        /// Gets the current orienration of the layout manager.
        get {
            let rv = gtk_center_layout_get_orientation(center_layout_ptr)
            return rv
        }
        /// Sets the orientation of `self`.
        nonmutating set {
            gtk_center_layout_set_orientation(center_layout_ptr, newValue)
        }
    }

    /// Returns the start widget fo the layout.
    @inlinable var startWidget: WidgetRef! {
        /// Returns the start widget fo the layout.
        get {
            let rv = WidgetRef(gconstpointer: gconstpointer(gtk_center_layout_get_start_widget(center_layout_ptr)))
            return rv
        }
        /// Sets the new start widget of `self`.
        /// 
        /// To remove the existing start widget, pass `nil`.
        nonmutating set {
            gtk_center_layout_set_start_widget(center_layout_ptr, UnsafeMutablePointer<GtkWidget>(newValue?.widget_ptr))
        }
    }


}



// MARK: - CheckButton Class

/// The `CheckButtonProtocol` protocol exposes the methods and properties of an underlying `GtkCheckButton` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CheckButton`.
/// Alternatively, use `CheckButtonRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A `GtkCheckButton` places a label next to an indicator.
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// checkbutton[.text-button]
/// ├── check
/// ╰── [label]
/// ```
/// 
/// A `GtkCheckButton` has a main node with name checkbutton. If the
/// `GtkCheckButton:label` property is set, it contains a label child.
/// The indicator node is named check when no group is set, and radio
/// if the checkbutton is grouped together with other checkbuttons.
/// 
/// # Accessibility
/// 
/// GtkCheckButton uses the `GTK_ACCESSIBLE_ROLE_CHECKBOX` role.
public protocol CheckButtonProtocol: WidgetProtocol, ActionableProtocol {
        /// Untyped pointer to the underlying `GtkCheckButton` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCheckButton` instance.
    var check_button_ptr: UnsafeMutablePointer<GtkCheckButton>! { get }

}

/// The `CheckButtonRef` type acts as a lightweight Swift reference to an underlying `GtkCheckButton` instance.
/// It exposes methods that can operate on this data type through `CheckButtonProtocol` conformance.
/// Use `CheckButtonRef` only as an `unowned` reference to an existing `GtkCheckButton` instance.
///
/// A `GtkCheckButton` places a label next to an indicator.
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// checkbutton[.text-button]
/// ├── check
/// ╰── [label]
/// ```
/// 
/// A `GtkCheckButton` has a main node with name checkbutton. If the
/// `GtkCheckButton:label` property is set, it contains a label child.
/// The indicator node is named check when no group is set, and radio
/// if the checkbutton is grouped together with other checkbuttons.
/// 
/// # Accessibility
/// 
/// GtkCheckButton uses the `GTK_ACCESSIBLE_ROLE_CHECKBOX` role.
public struct CheckButtonRef: CheckButtonProtocol {
        /// Untyped pointer to the underlying `GtkCheckButton` instance.
    /// For type-safe access, use the generated, typed pointer `check_button_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CheckButtonRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCheckButton>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCheckButton>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCheckButton>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCheckButton>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CheckButtonProtocol`
    @inlinable init<T: CheckButtonProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCheckButton`.
    @inlinable init() {
        let rv = gtk_check_button_new()
        ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GtkCheckButton` with a `GtkLabel` next to it, if
    /// `label` is non-`nil`.
    @inlinable init(label: UnsafePointer<CChar>? = nil) {
        let rv = gtk_check_button_new_with_label(label)
        ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GtkCheckButton` containing a label. Underscores
    /// in `label` indicate the mnemonic for the check button.
    @inlinable init(mnemonic label: UnsafePointer<CChar>? = nil) {
        let rv = gtk_check_button_new_with_mnemonic(label)
        ptr = UnsafeMutableRawPointer(rv)
    }
    /// Creates a new `GtkCheckButton` with a `GtkLabel` next to it, if
    /// `label` is non-`nil`.
    @inlinable static func newWith(label: UnsafePointer<CChar>? = nil) -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_check_button_new_with_label(label))) else { return nil }
        return rv
    }

    /// Creates a new `GtkCheckButton` containing a label. Underscores
    /// in `label` indicate the mnemonic for the check button.
    @inlinable static func newWith(mnemonic label: UnsafePointer<CChar>? = nil) -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_check_button_new_with_mnemonic(label))) else { return nil }
        return rv
    }
}

/// The `CheckButton` type acts as a reference-counted owner of an underlying `GtkCheckButton` instance.
/// It provides the methods that can operate on this data type through `CheckButtonProtocol` conformance.
/// Use `CheckButton` as a strong reference or owner of a `GtkCheckButton` instance.
///
/// A `GtkCheckButton` places a label next to an indicator.
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// checkbutton[.text-button]
/// ├── check
/// ╰── [label]
/// ```
/// 
/// A `GtkCheckButton` has a main node with name checkbutton. If the
/// `GtkCheckButton:label` property is set, it contains a label child.
/// The indicator node is named check when no group is set, and radio
/// if the checkbutton is grouped together with other checkbuttons.
/// 
/// # Accessibility
/// 
/// GtkCheckButton uses the `GTK_ACCESSIBLE_ROLE_CHECKBOX` role.
open class CheckButton: Widget, CheckButtonProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CheckButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCheckButton>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CheckButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCheckButton>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CheckButton` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CheckButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CheckButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCheckButton>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CheckButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCheckButton>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCheckButton`.
    /// i.e., ownership is transferred to the `CheckButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCheckButton>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CheckButtonProtocol`
    /// Will retain `GtkCheckButton`.
    /// - Parameter other: an instance of a related type that implements `CheckButtonProtocol`
    @inlinable public init<T: CheckButtonProtocol>(checkButton other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkCheckButton`.
    @inlinable public init() {
        let rv = gtk_check_button_new()
        super.init(gpointer: gpointer(rv))
    }

    /// Creates a new `GtkCheckButton` with a `GtkLabel` next to it, if
    /// `label` is non-`nil`.
    @inlinable public init(label: UnsafePointer<CChar>? = nil) {
        let rv = gtk_check_button_new_with_label(label)
        super.init(gpointer: gpointer(rv))
    }

    /// Creates a new `GtkCheckButton` containing a label. Underscores
    /// in `label` indicate the mnemonic for the check button.
    @inlinable public init(mnemonic label: UnsafePointer<CChar>? = nil) {
        let rv = gtk_check_button_new_with_mnemonic(label)
        super.init(gpointer: gpointer(rv))
    }

    /// Creates a new `GtkCheckButton` with a `GtkLabel` next to it, if
    /// `label` is non-`nil`.
    @inlinable public static func newWith(label: UnsafePointer<CChar>? = nil) -> Widget! {
        guard let rv = Widget(gconstpointer: gconstpointer(gtk_check_button_new_with_label(label))) else { return nil }
        return rv
    }

    /// Creates a new `GtkCheckButton` containing a label. Underscores
    /// in `label` indicate the mnemonic for the check button.
    @inlinable public static func newWith(mnemonic label: UnsafePointer<CChar>? = nil) -> Widget! {
        guard let rv = Widget(gconstpointer: gconstpointer(gtk_check_button_new_with_mnemonic(label))) else { return nil }
        return rv
    }

}

public enum CheckButtonPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case active = "active"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`. See `gtk_widget_set_cursor()` for details.
    case cursor = "cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    case group = "group"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    case inconsistent = "inconsistent"
    case label = "label"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case name = "name"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    case parent = "parent"
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget or `nil` if
    /// the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    case useUnderline = "use-underline"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
}

public extension CheckButtonProtocol {
    /// Bind a `CheckButtonPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CheckButtonPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CheckButton property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CheckButtonPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CheckButton property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CheckButtonPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CheckButtonSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold. May result in finalization of the widget
    /// if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// The `direction`-changed signal is emitted when the text direction
    /// of a widget changes.
    case directionChanged = "direction-changed"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The `hide` signal is emitted when `widget` is hidden, for example with
    /// `gtk_widget_hide()`.
    case hide = "hide"
    /// Gets emitted if keyboard navigation fails.
    /// See `gtk_widget_keynav_failed()` for details.
    case keynavFailed = "keynav-failed"
    /// The `map` signal is emitted when `widget` is going to be mapped, that is
    /// when the widget is visible (which is controlled with
    /// `gtk_widget_set_visible()`) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of `GtkWidget::unmap`.
    case map = "map"
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// Emitted when `GtkWidget:has`-tooltip is `true` and the hover timeout
    /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
    /// focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// The `realize` signal is emitted when `widget` is associated with a
    /// `GdkSurface`, which means that `gtk_widget_realize()` has been called or the
    /// widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// The `show` signal is emitted when `widget` is shown, for example with
    /// `gtk_widget_show()`.
    case show = "show"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The `state`-flags-changed signal is emitted when the widget state
    /// changes, see `gtk_widget_get_state_flags()`.
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted when the buttons's `GtkCheckButton:active` flag changes.
    case toggled = "toggled"
    /// The `unmap` signal is emitted when `widget` is going to be unmapped, which
    /// means that either it or any of its parents up to the toplevel widget have
    /// been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer, it can be
    /// used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// The `unrealize` signal is emitted when the `GdkSurface` associated with
    /// `widget` is destroyed, which means that `gtk_widget_unrealize()` has been
    /// called or the widget has been unmapped (that is, it is going to be
    /// hidden).
    case unrealize = "unrealize"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyActive = "notify::active"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    case notifyCanTarget = "notify::can-target"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`. See `gtk_widget_set_cursor()` for details.
    case notifyCursor = "notify::cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    case notifyGroup = "notify::group"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case notifyHalign = "notify::halign"
    case notifyHasDefault = "notify::has-default"
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case notifyHexpandSet = "notify::hexpand-set"
    case notifyInconsistent = "notify::inconsistent"
    case notifyLabel = "notify::label"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginTop = "notify::margin-top"
    case notifyName = "notify::name"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    case notifyParent = "notify::parent"
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget or `nil` if
    /// the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case notifyScaleFactor = "notify::scale-factor"
    case notifySensitive = "notify::sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    case notifyUseUnderline = "notify::use-underline"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case notifyValign = "notify::valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case notifyVexpandSet = "notify::vexpand-set"
    case notifyVisible = "notify::visible"
    case notifyWidthRequest = "notify::width-request"
}

public extension CheckButtonProtocol {
    /// Connect a `CheckButtonSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @inlinable @discardableResult func connect(signal kind: CheckButtonSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> Int {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> Int {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(raw: ptr).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

// MARK: CheckButton Class: CheckButtonProtocol extension (methods and fields)
public extension CheckButtonProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCheckButton` instance.
    @inlinable var check_button_ptr: UnsafeMutablePointer<GtkCheckButton>! { return ptr?.assumingMemoryBound(to: GtkCheckButton.self) }

    /// Returns the current value of the `GtkCheckButton:active` property.
    @inlinable func getActive() -> Bool {
        let rv = ((gtk_check_button_get_active(check_button_ptr)) != 0)
        return rv
    }

    /// Returns whether the check button is in an inconsistent state.
    @inlinable func getInconsistent() -> Bool {
        let rv = ((gtk_check_button_get_inconsistent(check_button_ptr)) != 0)
        return rv
    }

    /// Returns the label of the checkbutton.
    @inlinable func getLabel() -> String! {
        let rv = gtk_check_button_get_label(check_button_ptr).map({ String(cString: $0) })
        return rv
    }

    /// Returns the current value of the `GtkCheckButton:use`-underline property.
    @inlinable func getUseUnderline() -> Bool {
        let rv = ((gtk_check_button_get_use_underline(check_button_ptr)) != 0)
        return rv
    }

    /// Sets the new value of the `GtkCheckButton:active` property.
    /// See also `gtk_check_button_get_active()`.
    /// 
    /// Setting `GtkCheckButton:active` to `true` will add the `:checked:` state to
    /// both the checkbutton and the indicator CSS node.
    @inlinable func setActive(setting: Bool) {
        gtk_check_button_set_active(check_button_ptr, gboolean((setting) ? 1 : 0))
    
    }

    /// Adds `self` to the group of `group`. In a group of multiple check buttons,
    /// only one button can be active at a time.
    /// 
    /// Setting the group of a check button also changes the css name of the
    /// indicator widget's CSS node to 'radio'.
    /// 
    /// The behavior of a checkbutton in a group is also commonly known as
    /// a 'radio button'.
    /// 
    /// Note that the same effect can be achieved via the `GtkActionable`
    /// api, by using the same action with parameter type and state type 's'
    /// for all buttons in the group, and giving each button its own target
    /// value.
    @inlinable func set(group: CheckButtonRef? = nil) {
        gtk_check_button_set_group(check_button_ptr, group?.check_button_ptr)
    
    }
    /// Adds `self` to the group of `group`. In a group of multiple check buttons,
    /// only one button can be active at a time.
    /// 
    /// Setting the group of a check button also changes the css name of the
    /// indicator widget's CSS node to 'radio'.
    /// 
    /// The behavior of a checkbutton in a group is also commonly known as
    /// a 'radio button'.
    /// 
    /// Note that the same effect can be achieved via the `GtkActionable`
    /// api, by using the same action with parameter type and state type 's'
    /// for all buttons in the group, and giving each button its own target
    /// value.
    @inlinable func set<CheckButtonT: CheckButtonProtocol>(group: CheckButtonT?) {
        gtk_check_button_set_group(check_button_ptr, group?.check_button_ptr)
    
    }

    /// If the user has selected a range of elements (such as some text or
    /// spreadsheet cells) that are affected by a check button, and the
    /// current values in that range are inconsistent, you may want to
    /// display the toggle in an "in between" state. Normally you would
    /// turn off the inconsistent state again if the user checks the
    /// check button. This has to be done manually,
    /// gtk_check_button_set_inconsistent only affects visual appearance,
    /// not the semantics of the button.
    @inlinable func set(inconsistent: Bool) {
        gtk_check_button_set_inconsistent(check_button_ptr, gboolean((inconsistent) ? 1 : 0))
    
    }

    /// Sets the text of `self`. If `GtkCheckButton:use`-underline is `true`,
    /// the underscore in `label` is interpreted as mnemonic indicator,
    /// see `gtk_check_button_set_use_underline()` for details on this behavior.
    @inlinable func set(label: UnsafePointer<CChar>? = nil) {
        gtk_check_button_set_label(check_button_ptr, label)
    
    }

    /// Sets the new value of the `GtkCheckButton:use`-underline property.
    /// See also `gtk_check_button_get_use_underline()`.
    /// 
    /// If `setting` is `true`, an underscore character in `self`'s label indicates
    /// a mnemonic accelerator key. This behavior is similar to `GtkLabel:use`-underline.
    @inlinable func setUseUnderline(setting: Bool) {
        gtk_check_button_set_use_underline(check_button_ptr, gboolean((setting) ? 1 : 0))
    
    }
    @inlinable var active: Bool {
        /// Returns the current value of the `GtkCheckButton:active` property.
        get {
            let rv = ((gtk_check_button_get_active(check_button_ptr)) != 0)
            return rv
        }
        /// Sets the new value of the `GtkCheckButton:active` property.
        /// See also `gtk_check_button_get_active()`.
        /// 
        /// Setting `GtkCheckButton:active` to `true` will add the `:checked:` state to
        /// both the checkbutton and the indicator CSS node.
        nonmutating set {
            gtk_check_button_set_active(check_button_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    @inlinable var inconsistent: Bool {
        /// Returns whether the check button is in an inconsistent state.
        get {
            let rv = ((gtk_check_button_get_inconsistent(check_button_ptr)) != 0)
            return rv
        }
        /// If the user has selected a range of elements (such as some text or
        /// spreadsheet cells) that are affected by a check button, and the
        /// current values in that range are inconsistent, you may want to
        /// display the toggle in an "in between" state. Normally you would
        /// turn off the inconsistent state again if the user checks the
        /// check button. This has to be done manually,
        /// gtk_check_button_set_inconsistent only affects visual appearance,
        /// not the semantics of the button.
        nonmutating set {
            gtk_check_button_set_inconsistent(check_button_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    @inlinable var label: String! {
        /// Returns the label of the checkbutton.
        get {
            let rv = gtk_check_button_get_label(check_button_ptr).map({ String(cString: $0) })
            return rv
        }
        /// Sets the text of `self`. If `GtkCheckButton:use`-underline is `true`,
        /// the underscore in `label` is interpreted as mnemonic indicator,
        /// see `gtk_check_button_set_use_underline()` for details on this behavior.
        nonmutating set {
            gtk_check_button_set_label(check_button_ptr, newValue)
        }
    }

    /// Returns the current value of the `GtkCheckButton:use`-underline property.
    @inlinable var useUnderline: Bool {
        /// Returns the current value of the `GtkCheckButton:use`-underline property.
        get {
            let rv = ((gtk_check_button_get_use_underline(check_button_ptr)) != 0)
            return rv
        }
        /// Sets the new value of the `GtkCheckButton:use`-underline property.
        /// See also `gtk_check_button_get_use_underline()`.
        /// 
        /// If `setting` is `true`, an underscore character in `self`'s label indicates
        /// a mnemonic accelerator key. This behavior is similar to `GtkLabel:use`-underline.
        nonmutating set {
            gtk_check_button_set_use_underline(check_button_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    @inlinable var parentInstance: GtkWidget {
        get {
            let rv = check_button_ptr.pointee.parent_instance
            return rv
        }
    }

}



// MARK: - ClosureExpression Class

/// The `ClosureExpressionProtocol` protocol exposes the methods and properties of an underlying `GtkClosureExpression` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ClosureExpression`.
/// Alternatively, use `ClosureExpressionRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///

public protocol ClosureExpressionProtocol: ExpressionProtocol {
        /// Untyped pointer to the underlying `GtkClosureExpression` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkClosureExpression` instance.
    var closure_expression_ptr: UnsafeMutablePointer<GtkClosureExpression>! { get }

}

/// The `ClosureExpressionRef` type acts as a lightweight Swift reference to an underlying `GtkClosureExpression` instance.
/// It exposes methods that can operate on this data type through `ClosureExpressionProtocol` conformance.
/// Use `ClosureExpressionRef` only as an `unowned` reference to an existing `GtkClosureExpression` instance.
///

public struct ClosureExpressionRef: ClosureExpressionProtocol {
        /// Untyped pointer to the underlying `GtkClosureExpression` instance.
    /// For type-safe access, use the generated, typed pointer `closure_expression_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ClosureExpressionRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkClosureExpression>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkClosureExpression>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkClosureExpression>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkClosureExpression>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ClosureExpressionProtocol`
    @inlinable init<T: ClosureExpressionProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClosureExpressionProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClosureExpressionProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClosureExpressionProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClosureExpressionProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClosureExpressionProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a GtkExpression that calls `closure` when it is evaluated.
    /// `closure` is called with the `this` object and the results of evaluating
    /// the `params` expressions.
    @inlinable init<ClosureT: GLibObject.ClosureProtocol>( valueType: GType, closure: ClosureT, nParams: Int, params: UnsafeMutablePointer<UnsafeMutablePointer<GtkExpression>?>! = nil) {
        let rv = gtk_closure_expression_new(valueType, closure.closure_ptr, guint(nParams), params)
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `ClosureExpression` type acts as a reference-counted owner of an underlying `GtkClosureExpression` instance.
/// It provides the methods that can operate on this data type through `ClosureExpressionProtocol` conformance.
/// Use `ClosureExpression` as a strong reference or owner of a `GtkClosureExpression` instance.
///

open class ClosureExpression: Expression, ClosureExpressionProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ClosureExpression` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkClosureExpression>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ClosureExpression` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkClosureExpression>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ClosureExpression` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ClosureExpression` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ClosureExpression` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkClosureExpression>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ClosureExpression` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkClosureExpression>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkClosureExpression`.
    /// i.e., ownership is transferred to the `ClosureExpression` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkClosureExpression>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ClosureExpressionProtocol`
    /// Will retain `GtkClosureExpression`.
    /// - Parameter other: an instance of a related type that implements `ClosureExpressionProtocol`
    @inlinable public init<T: ClosureExpressionProtocol>(closureExpression other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClosureExpressionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClosureExpressionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClosureExpressionProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClosureExpressionProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClosureExpressionProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClosureExpressionProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClosureExpressionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClosureExpressionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a GtkExpression that calls `closure` when it is evaluated.
    /// `closure` is called with the `this` object and the results of evaluating
    /// the `params` expressions.
    @inlinable public init<ClosureT: GLibObject.ClosureProtocol>( valueType: GType, closure: ClosureT, nParams: Int, params: UnsafeMutablePointer<UnsafeMutablePointer<GtkExpression>?>! = nil) {
        let rv = gtk_closure_expression_new(valueType, closure.closure_ptr, guint(nParams), params)
        super.init(gpointer: gpointer(rv))
    }


}

// MARK: no ClosureExpression properties

// MARK: no ClosureExpression signals


// MARK: ClosureExpression Class: ClosureExpressionProtocol extension (methods and fields)
public extension ClosureExpressionProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkClosureExpression` instance.
    @inlinable var closure_expression_ptr: UnsafeMutablePointer<GtkClosureExpression>! { return ptr?.assumingMemoryBound(to: GtkClosureExpression.self) }



}



// MARK: - ColorButton Class

/// The `ColorButtonProtocol` protocol exposes the methods and properties of an underlying `GtkColorButton` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ColorButton`.
/// Alternatively, use `ColorButtonRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// The `GtkColorButton` is a button which displays the currently selected
/// color and allows to open a color selection dialog to change the color.
/// It is suitable widget for selecting a color in a preference dialog.
/// 
/// # CSS nodes
/// 
/// GtkColorButton has a single CSS node with name button. To differentiate
/// it from a plain `GtkButton`, it gets the .color style class.
public protocol ColorButtonProtocol: WidgetProtocol, ColorChooserProtocol {
        /// Untyped pointer to the underlying `GtkColorButton` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkColorButton` instance.
    var color_button_ptr: UnsafeMutablePointer<GtkColorButton>! { get }

}

/// The `ColorButtonRef` type acts as a lightweight Swift reference to an underlying `GtkColorButton` instance.
/// It exposes methods that can operate on this data type through `ColorButtonProtocol` conformance.
/// Use `ColorButtonRef` only as an `unowned` reference to an existing `GtkColorButton` instance.
///
/// The `GtkColorButton` is a button which displays the currently selected
/// color and allows to open a color selection dialog to change the color.
/// It is suitable widget for selecting a color in a preference dialog.
/// 
/// # CSS nodes
/// 
/// GtkColorButton has a single CSS node with name button. To differentiate
/// it from a plain `GtkButton`, it gets the .color style class.
public struct ColorButtonRef: ColorButtonProtocol {
        /// Untyped pointer to the underlying `GtkColorButton` instance.
    /// For type-safe access, use the generated, typed pointer `color_button_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ColorButtonRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkColorButton>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkColorButton>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkColorButton>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkColorButton>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ColorButtonProtocol`
    @inlinable init<T: ColorButtonProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new color button.
    /// 
    /// This returns a widget in the form of a small button containing
    /// a swatch representing the current selected color. When the button
    /// is clicked, a color-selection dialog will open, allowing the user
    /// to select a color. The swatch will be updated to reflect the new
    /// color when the user finishes.
    @inlinable init() {
        let rv = gtk_color_button_new()
        ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new color button.
    @inlinable init<RGBAT: Gdk.RGBAProtocol>(rgba: RGBAT) {
        let rv = gtk_color_button_new_with_rgba(rgba.rgba_ptr)
        ptr = UnsafeMutableRawPointer(rv)
    }
    /// Creates a new color button.
    @inlinable static func newWith<RGBAT: Gdk.RGBAProtocol>(rgba: RGBAT) -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_color_button_new_with_rgba(rgba.rgba_ptr))) else { return nil }
        return rv
    }
}

/// The `ColorButton` type acts as a reference-counted owner of an underlying `GtkColorButton` instance.
/// It provides the methods that can operate on this data type through `ColorButtonProtocol` conformance.
/// Use `ColorButton` as a strong reference or owner of a `GtkColorButton` instance.
///
/// The `GtkColorButton` is a button which displays the currently selected
/// color and allows to open a color selection dialog to change the color.
/// It is suitable widget for selecting a color in a preference dialog.
/// 
/// # CSS nodes
/// 
/// GtkColorButton has a single CSS node with name button. To differentiate
/// it from a plain `GtkButton`, it gets the .color style class.
open class ColorButton: Widget, ColorButtonProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkColorButton>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkColorButton>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorButton` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkColorButton>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkColorButton>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkColorButton`.
    /// i.e., ownership is transferred to the `ColorButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkColorButton>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ColorButtonProtocol`
    /// Will retain `GtkColorButton`.
    /// - Parameter other: an instance of a related type that implements `ColorButtonProtocol`
    @inlinable public init<T: ColorButtonProtocol>(colorButton other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new color button.
    /// 
    /// This returns a widget in the form of a small button containing
    /// a swatch representing the current selected color. When the button
    /// is clicked, a color-selection dialog will open, allowing the user
    /// to select a color. The swatch will be updated to reflect the new
    /// color when the user finishes.
    @inlinable public init() {
        let rv = gtk_color_button_new()
        super.init(gpointer: gpointer(rv))
    }

    /// Creates a new color button.
    @inlinable public init<RGBAT: Gdk.RGBAProtocol>(rgba: RGBAT) {
        let rv = gtk_color_button_new_with_rgba(rgba.rgba_ptr)
        super.init(gpointer: gpointer(rv))
    }

    /// Creates a new color button.
    @inlinable public static func newWith<RGBAT: Gdk.RGBAProtocol>(rgba: RGBAT) -> Widget! {
        guard let rv = Widget(gconstpointer: gconstpointer(gtk_color_button_new_with_rgba(rgba.rgba_ptr))) else { return nil }
        return rv
    }

}

public enum ColorButtonPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`. See `gtk_widget_set_cursor()` for details.
    case cursor = "cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case modal = "modal"
    case name = "name"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    case parent = "parent"
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget or `nil` if
    /// the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    /// Set this property to `true` to skip the palette
    /// in the dialog and go directly to the color editor.
    /// 
    /// This property should be used in cases where the palette
    /// in the editor would be redundant, such as when the color
    /// button is already part of a palette.
    case showEditor = "show-editor"
    /// The title of the color selection dialog
    case title = "title"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
}

public extension ColorButtonProtocol {
    /// Bind a `ColorButtonPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ColorButtonPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ColorButton property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ColorButtonPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ColorButton property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ColorButtonPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ColorButtonSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// The `color`-set signal is emitted when the user selects a color.
    /// When handling this signal, use `gtk_color_chooser_get_rgba()` to
    /// find out which color was just selected.
    /// 
    /// Note that this signal is only emitted when the user
    /// changes the color. If you need to react to programmatic color changes
    /// as well, use the notify`color` signal.
    case colorSet = "color-set"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold. May result in finalization of the widget
    /// if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// The `direction`-changed signal is emitted when the text direction
    /// of a widget changes.
    case directionChanged = "direction-changed"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The `hide` signal is emitted when `widget` is hidden, for example with
    /// `gtk_widget_hide()`.
    case hide = "hide"
    /// Gets emitted if keyboard navigation fails.
    /// See `gtk_widget_keynav_failed()` for details.
    case keynavFailed = "keynav-failed"
    /// The `map` signal is emitted when `widget` is going to be mapped, that is
    /// when the widget is visible (which is controlled with
    /// `gtk_widget_set_visible()`) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of `GtkWidget::unmap`.
    case map = "map"
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// Emitted when `GtkWidget:has`-tooltip is `true` and the hover timeout
    /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
    /// focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// The `realize` signal is emitted when `widget` is associated with a
    /// `GdkSurface`, which means that `gtk_widget_realize()` has been called or the
    /// widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// The `show` signal is emitted when `widget` is shown, for example with
    /// `gtk_widget_show()`.
    case show = "show"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The `state`-flags-changed signal is emitted when the widget state
    /// changes, see `gtk_widget_get_state_flags()`.
    case stateFlagsChanged = "state-flags-changed"
    /// The `unmap` signal is emitted when `widget` is going to be unmapped, which
    /// means that either it or any of its parents up to the toplevel widget have
    /// been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer, it can be
    /// used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// The `unrealize` signal is emitted when the `GdkSurface` associated with
    /// `widget` is destroyed, which means that `gtk_widget_unrealize()` has been
    /// called or the widget has been unmapped (that is, it is going to be
    /// hidden).
    case unrealize = "unrealize"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    case notifyCanTarget = "notify::can-target"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`. See `gtk_widget_set_cursor()` for details.
    case notifyCursor = "notify::cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case notifyHalign = "notify::halign"
    case notifyHasDefault = "notify::has-default"
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginTop = "notify::margin-top"
    case notifyModal = "notify::modal"
    case notifyName = "notify::name"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    case notifyParent = "notify::parent"
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget or `nil` if
    /// the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case notifyScaleFactor = "notify::scale-factor"
    case notifySensitive = "notify::sensitive"
    /// Set this property to `true` to skip the palette
    /// in the dialog and go directly to the color editor.
    /// 
    /// This property should be used in cases where the palette
    /// in the editor would be redundant, such as when the color
    /// button is already part of a palette.
    case notifyShowEditor = "notify::show-editor"
    /// The title of the color selection dialog
    case notifyTitle = "notify::title"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case notifyValign = "notify::valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case notifyVexpandSet = "notify::vexpand-set"
    case notifyVisible = "notify::visible"
    case notifyWidthRequest = "notify::width-request"
}

public extension ColorButtonProtocol {
    /// Connect a `ColorButtonSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @inlinable @discardableResult func connect(signal kind: ColorButtonSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> Int {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> Int {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(raw: ptr).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

// MARK: ColorButton Class: ColorButtonProtocol extension (methods and fields)
public extension ColorButtonProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkColorButton` instance.
    @inlinable var color_button_ptr: UnsafeMutablePointer<GtkColorButton>! { return ptr?.assumingMemoryBound(to: GtkColorButton.self) }

    /// Gets whether the dialog is modal.
    @inlinable func getModal() -> Bool {
        let rv = ((gtk_color_button_get_modal(color_button_ptr)) != 0)
        return rv
    }

    /// Gets the title of the color selection dialog.
    @inlinable func getTitle() -> String! {
        let rv = gtk_color_button_get_title(color_button_ptr).map({ String(cString: $0) })
        return rv
    }

    /// Sets whether the dialog should be modal.
    @inlinable func set(modal: Bool) {
        gtk_color_button_set_modal(color_button_ptr, gboolean((modal) ? 1 : 0))
    
    }

    /// Sets the title for the color selection dialog.
    @inlinable func set(title: UnsafePointer<CChar>!) {
        gtk_color_button_set_title(color_button_ptr, title)
    
    }
    @inlinable var modal: Bool {
        /// Gets whether the dialog is modal.
        get {
            let rv = ((gtk_color_button_get_modal(color_button_ptr)) != 0)
            return rv
        }
        /// Sets whether the dialog should be modal.
        nonmutating set {
            gtk_color_button_set_modal(color_button_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// The title of the color selection dialog
    @inlinable var title: String! {
        /// Gets the title of the color selection dialog.
        get {
            let rv = gtk_color_button_get_title(color_button_ptr).map({ String(cString: $0) })
            return rv
        }
        /// Sets the title for the color selection dialog.
        nonmutating set {
            gtk_color_button_set_title(color_button_ptr, newValue)
        }
    }


}



// MARK: - ColorChooserDialog Class

/// The `ColorChooserDialogProtocol` protocol exposes the methods and properties of an underlying `GtkColorChooserDialog` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ColorChooserDialog`.
/// Alternatively, use `ColorChooserDialogRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// The `GtkColorChooserDialog` widget is a dialog for choosing
/// a color. It implements the `GtkColorChooser` interface.
public protocol ColorChooserDialogProtocol: DialogProtocol, ColorChooserProtocol {
        /// Untyped pointer to the underlying `GtkColorChooserDialog` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkColorChooserDialog` instance.
    var color_chooser_dialog_ptr: UnsafeMutablePointer<GtkColorChooserDialog>! { get }

}

/// The `ColorChooserDialogRef` type acts as a lightweight Swift reference to an underlying `GtkColorChooserDialog` instance.
/// It exposes methods that can operate on this data type through `ColorChooserDialogProtocol` conformance.
/// Use `ColorChooserDialogRef` only as an `unowned` reference to an existing `GtkColorChooserDialog` instance.
///
/// The `GtkColorChooserDialog` widget is a dialog for choosing
/// a color. It implements the `GtkColorChooser` interface.
public struct ColorChooserDialogRef: ColorChooserDialogProtocol {
        /// Untyped pointer to the underlying `GtkColorChooserDialog` instance.
    /// For type-safe access, use the generated, typed pointer `color_chooser_dialog_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ColorChooserDialogRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkColorChooserDialog>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkColorChooserDialog>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkColorChooserDialog>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkColorChooserDialog>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ColorChooserDialogProtocol`
    @inlinable init<T: ColorChooserDialogProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkColorChooserDialog`.
    @inlinable init<WindowT: WindowProtocol>( title: UnsafePointer<CChar>? = nil, parent: WindowT?) {
        let rv = gtk_color_chooser_dialog_new(title, parent?.window_ptr)
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `ColorChooserDialog` type acts as a reference-counted owner of an underlying `GtkColorChooserDialog` instance.
/// It provides the methods that can operate on this data type through `ColorChooserDialogProtocol` conformance.
/// Use `ColorChooserDialog` as a strong reference or owner of a `GtkColorChooserDialog` instance.
///
/// The `GtkColorChooserDialog` widget is a dialog for choosing
/// a color. It implements the `GtkColorChooser` interface.
open class ColorChooserDialog: Dialog, ColorChooserDialogProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorChooserDialog` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkColorChooserDialog>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorChooserDialog` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkColorChooserDialog>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorChooserDialog` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorChooserDialog` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorChooserDialog` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkColorChooserDialog>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorChooserDialog` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkColorChooserDialog>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkColorChooserDialog`.
    /// i.e., ownership is transferred to the `ColorChooserDialog` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkColorChooserDialog>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ColorChooserDialogProtocol`
    /// Will retain `GtkColorChooserDialog`.
    /// - Parameter other: an instance of a related type that implements `ColorChooserDialogProtocol`
    @inlinable public init<T: ColorChooserDialogProtocol>(colorChooserDialog other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkColorChooserDialog`.
    @inlinable public init<WindowT: WindowProtocol>( title: UnsafePointer<CChar>? = nil, parent: WindowT?) {
        let rv = gtk_color_chooser_dialog_new(title, parent?.window_ptr)
        super.init(gpointer: gpointer(rv))
    }


}

public enum ColorChooserDialogPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    /// The `GtkApplication` associated with the window.
    /// 
    /// The application will be kept alive for at least as long as it
    /// has any windows associated with it (see `g_application_hold()`
    /// for a way to keep it alive without windows).
    /// 
    /// Normally, the connection between the application and the window
    /// will remain until the window is destroyed, but you can explicitly
    /// remove it by setting the :application property to `nil`.
    case application = "application"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    case canTarget = "can-target"
    case child = "child"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`. See `gtk_widget_set_cursor()` for details.
    case cursor = "cursor"
    /// Whether the window should be decorated by the window manager.
    case decorated = "decorated"
    case defaultHeight = "default-height"
    case defaultWidget = "default-widget"
    case defaultWidth = "default-width"
    /// Whether the window frame should have a close button.
    case deletable = "deletable"
    case destroyWithParent = "destroy-with-parent"
    case display = "display"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether 'focus rectangles' are currently visible in this window.
    /// 
    /// This property is maintained by GTK based on user input
    /// and should not be set by applications.
    case focusVisible = "focus-visible"
    case focusWidget = "focus-widget"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// Whether the window is fullscreen.
    /// 
    /// Setting this property is the equivalent of calling `gtk_window_fullscreen()`
    /// and `gtk_window_unfullscreen()`; either operation is asynchronous, which
    /// means you will need to connect to the `GObject::notify` signal in order to
    /// know whether the operation was successful.
    case fullscreened = "fullscreened"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    case hideOnClose = "hide-on-close"
    /// The :icon-name property specifies the name of the themed icon to
    /// use as the window icon. See `GtkIconTheme` for more details.
    case iconName = "icon-name"
    case isActive = "is-active"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    /// Whether the window is maximized.
    /// 
    /// Setting this property is the equivalent of calling `gtk_window_maximize()`
    /// and `gtk_window_unmaximize()`; either operation is asynchronous, which
    /// means you will need to connect to the `GObject::notify` signal in order to
    /// know whether the operation was successful.
    case maximized = "maximized"
    /// Whether mnemonics are currently visible in this window.
    /// 
    /// This property is maintained by GTK based on user input,
    /// and should not be set by applications.
    case mnemonicsVisible = "mnemonics-visible"
    case modal = "modal"
    case name = "name"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    case parent = "parent"
    case receivesDefault = "receives-default"
    case resizable = "resizable"
    /// The `GtkRoot` widget of the widget tree containing this widget or `nil` if
    /// the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    case showEditor = "show-editor"
    /// The :startup-id is a write-only property for setting window's
    /// startup notification identifier. See `gtk_window_set_startup_id()`
    /// for more details.
    case startupId = "startup-id"
    case title = "title"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// The transient parent of the window. See `gtk_window_set_transient_for()` for
    /// more details about transient windows.
    case transientFor = "transient-for"
    /// `true` if the dialog uses a `GtkHeaderBar` for action buttons
    /// instead of the action-area.
    /// 
    /// For technical reasons, this property is declared as an integer
    /// property, but you should only set it to `true` or `false`.
    case useHeaderBar = "use-header-bar"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
}

public extension ColorChooserDialogProtocol {
    /// Bind a `ColorChooserDialogPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ColorChooserDialogPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ColorChooserDialog property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ColorChooserDialogPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ColorChooserDialog property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ColorChooserDialogPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ColorChooserDialogSignalName: String, SignalNameProtocol {
    /// The `activate`-default signal is a
    /// [keybinding signal](#GtkSignalAction)
    /// which gets emitted when the user activates the default widget
    /// of `window`.
    case activateDefault = "activate-default"
    /// The `activate`-focus signal is a
    /// [keybinding signal](#GtkSignalAction)
    /// which gets emitted when the user activates the currently
    /// focused widget of `window`.
    case activateFocus = "activate-focus"
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// The `close` signal is a
    /// [keybinding signal](#GtkSignalAction)
    /// which gets emitted when the user uses a keybinding to close
    /// the dialog.
    /// 
    /// The default binding for this signal is the Escape key.
    case close = "close"
    /// The `close`-request signal is emitted when the user clicks on the close
    /// button of the window.
    case closeRequest = "close-request"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold. May result in finalization of the widget
    /// if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// The `direction`-changed signal is emitted when the text direction
    /// of a widget changes.
    case directionChanged = "direction-changed"
    /// The `enable`-debugging signal is a [keybinding signal](#GtkSignalAction)
    /// which gets emitted when the user enables or disables interactive
    /// debugging. When `toggle` is `true`, interactive debugging is toggled
    /// on or off, when it is `false`, the debugger will be pointed at the
    /// widget under the pointer.
    /// 
    /// The default bindings for this signal are Ctrl-Shift-I
    /// and Ctrl-Shift-D.
    case enableDebugging = "enable-debugging"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The `hide` signal is emitted when `widget` is hidden, for example with
    /// `gtk_widget_hide()`.
    case hide = "hide"
    /// Gets emitted if keyboard navigation fails.
    /// See `gtk_widget_keynav_failed()` for details.
    case keynavFailed = "keynav-failed"
    /// The `keys`-changed signal gets emitted when the set of accelerators
    /// or mnemonics that are associated with `window` changes.
    case keysChanged = "keys-changed"
    /// The `map` signal is emitted when `widget` is going to be mapped, that is
    /// when the widget is visible (which is controlled with
    /// `gtk_widget_set_visible()`) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of `GtkWidget::unmap`.
    case map = "map"
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// Emitted when `GtkWidget:has`-tooltip is `true` and the hover timeout
    /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
    /// focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// The `realize` signal is emitted when `widget` is associated with a
    /// `GdkSurface`, which means that `gtk_widget_realize()` has been called or the
    /// widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when an action widget is clicked, the dialog receives a
    /// delete event, or the application programmer calls `gtk_dialog_response()`.
    /// On a delete event, the response ID is `GTK_RESPONSE_DELETE_EVENT`.
    /// Otherwise, it depends on which action widget was clicked.
    case response = "response"
    /// The `show` signal is emitted when `widget` is shown, for example with
    /// `gtk_widget_show()`.
    case show = "show"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The `state`-flags-changed signal is emitted when the widget state
    /// changes, see `gtk_widget_get_state_flags()`.
    case stateFlagsChanged = "state-flags-changed"
    /// The `unmap` signal is emitted when `widget` is going to be unmapped, which
    /// means that either it or any of its parents up to the toplevel widget have
    /// been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer, it can be
    /// used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// The `unrealize` signal is emitted when the `GdkSurface` associated with
    /// `widget` is destroyed, which means that `gtk_widget_unrealize()` has been
    /// called or the widget has been unmapped (that is, it is going to be
    /// hidden).
    case unrealize = "unrealize"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    /// The `GtkApplication` associated with the window.
    /// 
    /// The application will be kept alive for at least as long as it
    /// has any windows associated with it (see `g_application_hold()`
    /// for a way to keep it alive without windows).
    /// 
    /// Normally, the connection between the application and the window
    /// will remain until the window is destroyed, but you can explicitly
    /// remove it by setting the :application property to `nil`.
    case notifyApplication = "notify::application"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    case notifyCanTarget = "notify::can-target"
    case notifyChild = "notify::child"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`. See `gtk_widget_set_cursor()` for details.
    case notifyCursor = "notify::cursor"
    /// Whether the window should be decorated by the window manager.
    case notifyDecorated = "notify::decorated"
    case notifyDefaultHeight = "notify::default-height"
    case notifyDefaultWidget = "notify::default-widget"
    case notifyDefaultWidth = "notify::default-width"
    /// Whether the window frame should have a close button.
    case notifyDeletable = "notify::deletable"
    case notifyDestroyWithParent = "notify::destroy-with-parent"
    case notifyDisplay = "notify::display"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether 'focus rectangles' are currently visible in this window.
    /// 
    /// This property is maintained by GTK based on user input
    /// and should not be set by applications.
    case notifyFocusVisible = "notify::focus-visible"
    case notifyFocusWidget = "notify::focus-widget"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// Whether the window is fullscreen.
    /// 
    /// Setting this property is the equivalent of calling `gtk_window_fullscreen()`
    /// and `gtk_window_unfullscreen()`; either operation is asynchronous, which
    /// means you will need to connect to the `GObject::notify` signal in order to
    /// know whether the operation was successful.
    case notifyFullscreened = "notify::fullscreened"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case notifyHalign = "notify::halign"
    case notifyHasDefault = "notify::has-default"
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case notifyHexpandSet = "notify::hexpand-set"
    case notifyHideOnClose = "notify::hide-on-close"
    /// The :icon-name property specifies the name of the themed icon to
    /// use as the window icon. See `GtkIconTheme` for more details.
    case notifyIconName = "notify::icon-name"
    case notifyIsActive = "notify::is-active"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginTop = "notify::margin-top"
    /// Whether the window is maximized.
    /// 
    /// Setting this property is the equivalent of calling `gtk_window_maximize()`
    /// and `gtk_window_unmaximize()`; either operation is asynchronous, which
    /// means you will need to connect to the `GObject::notify` signal in order to
    /// know whether the operation was successful.
    case notifyMaximized = "notify::maximized"
    /// Whether mnemonics are currently visible in this window.
    /// 
    /// This property is maintained by GTK based on user input,
    /// and should not be set by applications.
    case notifyMnemonicsVisible = "notify::mnemonics-visible"
    case notifyModal = "notify::modal"
    case notifyName = "notify::name"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    case notifyParent = "notify::parent"
    case notifyReceivesDefault = "notify::receives-default"
    case notifyResizable = "notify::resizable"
    /// The `GtkRoot` widget of the widget tree containing this widget or `nil` if
    /// the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case notifyScaleFactor = "notify::scale-factor"
    case notifySensitive = "notify::sensitive"
    case notifyShowEditor = "notify::show-editor"
    /// The :startup-id is a write-only property for setting window's
    /// startup notification identifier. See `gtk_window_set_startup_id()`
    /// for more details.
    case notifyStartupId = "notify::startup-id"
    case notifyTitle = "notify::title"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// The transient parent of the window. See `gtk_window_set_transient_for()` for
    /// more details about transient windows.
    case notifyTransientFor = "notify::transient-for"
    /// `true` if the dialog uses a `GtkHeaderBar` for action buttons
    /// instead of the action-area.
    /// 
    /// For technical reasons, this property is declared as an integer
    /// property, but you should only set it to `true` or `false`.
    case notifyUseHeaderBar = "notify::use-header-bar"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case notifyValign = "notify::valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case notifyVexpandSet = "notify::vexpand-set"
    case notifyVisible = "notify::visible"
    case notifyWidthRequest = "notify::width-request"
}

public extension ColorChooserDialogProtocol {
    /// Connect a `ColorChooserDialogSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @inlinable @discardableResult func connect(signal kind: ColorChooserDialogSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> Int {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> Int {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(raw: ptr).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

// MARK: ColorChooserDialog Class: ColorChooserDialogProtocol extension (methods and fields)
public extension ColorChooserDialogProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkColorChooserDialog` instance.
    @inlinable var color_chooser_dialog_ptr: UnsafeMutablePointer<GtkColorChooserDialog>! { return ptr?.assumingMemoryBound(to: GtkColorChooserDialog.self) }



}



// MARK: - ColorChooserWidget Class

/// The `ColorChooserWidgetProtocol` protocol exposes the methods and properties of an underlying `GtkColorChooserWidget` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ColorChooserWidget`.
/// Alternatively, use `ColorChooserWidgetRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// The `GtkColorChooserWidget` widget lets the user select a
/// color. By default, the chooser presents a predefined palette
/// of colors, plus a small number of settable custom colors.
/// It is also possible to select a different color with the
/// single-color editor. To enter the single-color editing mode,
/// use the context menu of any color of the palette, or use the
/// '+' button to add a new custom color.
/// 
/// The chooser automatically remembers the last selection, as well
/// as custom colors.
/// 
/// To change the initially selected color, use `gtk_color_chooser_set_rgba()`.
/// To get the selected color use `gtk_color_chooser_get_rgba()`.
/// 
/// The `GtkColorChooserWidget` is used in the `GtkColorChooserDialog`
/// to provide a dialog for selecting colors.
/// 
/// # CSS names
/// 
/// GtkColorChooserWidget has a single CSS node with name colorchooser.
public protocol ColorChooserWidgetProtocol: WidgetProtocol, ColorChooserProtocol {
        /// Untyped pointer to the underlying `GtkColorChooserWidget` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkColorChooserWidget` instance.
    var color_chooser_widget_ptr: UnsafeMutablePointer<GtkColorChooserWidget>! { get }

}

/// The `ColorChooserWidgetRef` type acts as a lightweight Swift reference to an underlying `GtkColorChooserWidget` instance.
/// It exposes methods that can operate on this data type through `ColorChooserWidgetProtocol` conformance.
/// Use `ColorChooserWidgetRef` only as an `unowned` reference to an existing `GtkColorChooserWidget` instance.
///
/// The `GtkColorChooserWidget` widget lets the user select a
/// color. By default, the chooser presents a predefined palette
/// of colors, plus a small number of settable custom colors.
/// It is also possible to select a different color with the
/// single-color editor. To enter the single-color editing mode,
/// use the context menu of any color of the palette, or use the
/// '+' button to add a new custom color.
/// 
/// The chooser automatically remembers the last selection, as well
/// as custom colors.
/// 
/// To change the initially selected color, use `gtk_color_chooser_set_rgba()`.
/// To get the selected color use `gtk_color_chooser_get_rgba()`.
/// 
/// The `GtkColorChooserWidget` is used in the `GtkColorChooserDialog`
/// to provide a dialog for selecting colors.
/// 
/// # CSS names
/// 
/// GtkColorChooserWidget has a single CSS node with name colorchooser.
public struct ColorChooserWidgetRef: ColorChooserWidgetProtocol {
        /// Untyped pointer to the underlying `GtkColorChooserWidget` instance.
    /// For type-safe access, use the generated, typed pointer `color_chooser_widget_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ColorChooserWidgetRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkColorChooserWidget>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkColorChooserWidget>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkColorChooserWidget>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkColorChooserWidget>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ColorChooserWidgetProtocol`
    @inlinable init<T: ColorChooserWidgetProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkColorChooserWidget`.
    @inlinable init() {
        let rv = gtk_color_chooser_widget_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `ColorChooserWidget` type acts as a reference-counted owner of an underlying `GtkColorChooserWidget` instance.
/// It provides the methods that can operate on this data type through `ColorChooserWidgetProtocol` conformance.
/// Use `ColorChooserWidget` as a strong reference or owner of a `GtkColorChooserWidget` instance.
///
/// The `GtkColorChooserWidget` widget lets the user select a
/// color. By default, the chooser presents a predefined palette
/// of colors, plus a small number of settable custom colors.
/// It is also possible to select a different color with the
/// single-color editor. To enter the single-color editing mode,
/// use the context menu of any color of the palette, or use the
/// '+' button to add a new custom color.
/// 
/// The chooser automatically remembers the last selection, as well
/// as custom colors.
/// 
/// To change the initially selected color, use `gtk_color_chooser_set_rgba()`.
/// To get the selected color use `gtk_color_chooser_get_rgba()`.
/// 
/// The `GtkColorChooserWidget` is used in the `GtkColorChooserDialog`
/// to provide a dialog for selecting colors.
/// 
/// # CSS names
/// 
/// GtkColorChooserWidget has a single CSS node with name colorchooser.
open class ColorChooserWidget: Widget, ColorChooserWidgetProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorChooserWidget` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkColorChooserWidget>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorChooserWidget` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkColorChooserWidget>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorChooserWidget` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorChooserWidget` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorChooserWidget` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkColorChooserWidget>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorChooserWidget` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkColorChooserWidget>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkColorChooserWidget`.
    /// i.e., ownership is transferred to the `ColorChooserWidget` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkColorChooserWidget>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ColorChooserWidgetProtocol`
    /// Will retain `GtkColorChooserWidget`.
    /// - Parameter other: an instance of a related type that implements `ColorChooserWidgetProtocol`
    @inlinable public init<T: ColorChooserWidgetProtocol>(colorChooserWidget other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkColorChooserWidget`.
    @inlinable public init() {
        let rv = gtk_color_chooser_widget_new()
        super.init(gpointer: gpointer(rv))
    }


}

public enum ColorChooserWidgetPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`. See `gtk_widget_set_cursor()` for details.
    case cursor = "cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case name = "name"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    case parent = "parent"
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget or `nil` if
    /// the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    /// The `show`-editor property is `true` when the color chooser
    /// is showing the single-color editor. It can be set to switch
    /// the color chooser into single-color editing mode.
    case showEditor = "show-editor"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
}

public extension ColorChooserWidgetProtocol {
    /// Bind a `ColorChooserWidgetPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ColorChooserWidgetPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ColorChooserWidget property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ColorChooserWidgetPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ColorChooserWidget property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ColorChooserWidgetPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ColorChooserWidgetSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold. May result in finalization of the widget
    /// if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// The `direction`-changed signal is emitted when the text direction
    /// of a widget changes.
    case directionChanged = "direction-changed"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The `hide` signal is emitted when `widget` is hidden, for example with
    /// `gtk_widget_hide()`.
    case hide = "hide"
    /// Gets emitted if keyboard navigation fails.
    /// See `gtk_widget_keynav_failed()` for details.
    case keynavFailed = "keynav-failed"
    /// The `map` signal is emitted when `widget` is going to be mapped, that is
    /// when the widget is visible (which is controlled with
    /// `gtk_widget_set_visible()`) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of `GtkWidget::unmap`.
    case map = "map"
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// Emitted when `GtkWidget:has`-tooltip is `true` and the hover timeout
    /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
    /// focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// The `realize` signal is emitted when `widget` is associated with a
    /// `GdkSurface`, which means that `gtk_widget_realize()` has been called or the
    /// widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// The `show` signal is emitted when `widget` is shown, for example with
    /// `gtk_widget_show()`.
    case show = "show"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The `state`-flags-changed signal is emitted when the widget state
    /// changes, see `gtk_widget_get_state_flags()`.
    case stateFlagsChanged = "state-flags-changed"
    /// The `unmap` signal is emitted when `widget` is going to be unmapped, which
    /// means that either it or any of its parents up to the toplevel widget have
    /// been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer, it can be
    /// used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// The `unrealize` signal is emitted when the `GdkSurface` associated with
    /// `widget` is destroyed, which means that `gtk_widget_unrealize()` has been
    /// called or the widget has been unmapped (that is, it is going to be
    /// hidden).
    case unrealize = "unrealize"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    case notifyCanTarget = "notify::can-target"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`. See `gtk_widget_set_cursor()` for details.
    case notifyCursor = "notify::cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case notifyHalign = "notify::halign"
    case notifyHasDefault = "notify::has-default"
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginTop = "notify::margin-top"
    case notifyName = "notify::name"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    case notifyParent = "notify::parent"
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget or `nil` if
    /// the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case notifyScaleFactor = "notify::scale-factor"
    case notifySensitive = "notify::sensitive"
    /// The `show`-editor property is `true` when the color chooser
    /// is showing the single-color editor. It can be set to switch
    /// the color chooser into single-color editing mode.
    case notifyShowEditor = "notify::show-editor"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case notifyValign = "notify::valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case notifyVexpandSet = "notify::vexpand-set"
    case notifyVisible = "notify::visible"
    case notifyWidthRequest = "notify::width-request"
}

public extension ColorChooserWidgetProtocol {
    /// Connect a `ColorChooserWidgetSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @inlinable @discardableResult func connect(signal kind: ColorChooserWidgetSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> Int {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> Int {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(raw: ptr).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

// MARK: ColorChooserWidget Class: ColorChooserWidgetProtocol extension (methods and fields)
public extension ColorChooserWidgetProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkColorChooserWidget` instance.
    @inlinable var color_chooser_widget_ptr: UnsafeMutablePointer<GtkColorChooserWidget>! { return ptr?.assumingMemoryBound(to: GtkColorChooserWidget.self) }



}



// MARK: - ColumnView Class

/// The `ColumnViewProtocol` protocol exposes the methods and properties of an underlying `GtkColumnView` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ColumnView`.
/// Alternatively, use `ColumnViewRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// GtkColumnView is a widget to present a view into a large dynamic list of items
/// using multiple columns with headers.
/// 
/// GtkColumnView uses the factories of its columns to generate a cell widget for
/// each column, for each visible item and displays them together as the row for
/// this item. The `GtkColumnView:show`-row-separators and
/// `GtkColumnView:show`-column-separators properties offer a simple way to display
/// separators between the rows or columns.
/// 
/// GtkColumnView allows the user to select items according to the selection
/// characteristics of the model. For models that allow multiple selected items,
/// it is possible to turn on *rubberband selection*, using
/// `GtkColumnView:enable`-rubberband.
/// 
/// The column view supports sorting that can be customized by the user by
/// clicking on column headers. To set this up, the `GtkSorter` returned by
/// `gtk_column_view_get_sorter()` must be attached to a sort model for the data
/// that the view is showing, and the columns must have sorters attached to them
/// by calling `gtk_column_view_column_set_sorter()`. The initial sort order can be
/// set with `gtk_column_view_sort_by_column()`.
/// 
/// The column view also supports interactive resizing and reordering of
/// columns, via Drag-and-Drop of the column headers. This can be enabled or
/// disabled with the `GtkColumnView:reorderable` and `GtkColumnViewColumn:resizable`
/// properties.
/// 
/// To learn more about the list widget framework, see the [overview](`ListWidget`).
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// columnview[.column-separators][.rich-list][.navigation-sidebar][.data-table]
/// ├── header
/// │   ├── <column header>
/// ┊   ┊
/// │   ╰── <column header>
/// │
/// ├── listview
/// │
/// ┊
/// ╰── [rubberband]
/// 
/// ```
/// 
/// GtkColumnView uses a single CSS node named columnview. It may carry the
/// .column-separators style class, when `GtkColumnView:show`-column-separators
/// property is set. Header widets appear below a node with name header.
/// The rows are contained in a GtkListView widget, so there is a listview
/// node with the same structure as for a standalone GtkListView widget. If
/// `GtkColumnView:show`-row-separators is set, it will be passed on to the
/// list view, causing its CSS node to carry the .separators style class.
/// For rubberband selection, a node with name rubberband is used.
/// 
/// The main columnview node may also carry style classes to select
/// the style of [list presentation](ListContainers.html`list`-styles):
/// .rich-list, .navigation-sidebar or .data-table.
/// 
/// # Accessibility
/// 
/// GtkColumnView uses the `GTK_ACCESSIBLE_ROLE_TREE_GRID` role, header title
/// widgets are using the `GTK_ACCESSIBLE_ROLE_COLUMN_HEADER` role. The row widgets
/// are using the `GTK_ACCESSIBLE_ROLE_ROW` role, and individual cells are using
/// the `GTK_ACCESSIBLE_ROLE_GRID_CELL` role
public protocol ColumnViewProtocol: WidgetProtocol, ScrollableProtocol {
        /// Untyped pointer to the underlying `GtkColumnView` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkColumnView` instance.
    var column_view_ptr: UnsafeMutablePointer<GtkColumnView>! { get }

}

/// The `ColumnViewRef` type acts as a lightweight Swift reference to an underlying `GtkColumnView` instance.
/// It exposes methods that can operate on this data type through `ColumnViewProtocol` conformance.
/// Use `ColumnViewRef` only as an `unowned` reference to an existing `GtkColumnView` instance.
///
/// GtkColumnView is a widget to present a view into a large dynamic list of items
/// using multiple columns with headers.
/// 
/// GtkColumnView uses the factories of its columns to generate a cell widget for
/// each column, for each visible item and displays them together as the row for
/// this item. The `GtkColumnView:show`-row-separators and
/// `GtkColumnView:show`-column-separators properties offer a simple way to display
/// separators between the rows or columns.
/// 
/// GtkColumnView allows the user to select items according to the selection
/// characteristics of the model. For models that allow multiple selected items,
/// it is possible to turn on *rubberband selection*, using
/// `GtkColumnView:enable`-rubberband.
/// 
/// The column view supports sorting that can be customized by the user by
/// clicking on column headers. To set this up, the `GtkSorter` returned by
/// `gtk_column_view_get_sorter()` must be attached to a sort model for the data
/// that the view is showing, and the columns must have sorters attached to them
/// by calling `gtk_column_view_column_set_sorter()`. The initial sort order can be
/// set with `gtk_column_view_sort_by_column()`.
/// 
/// The column view also supports interactive resizing and reordering of
/// columns, via Drag-and-Drop of the column headers. This can be enabled or
/// disabled with the `GtkColumnView:reorderable` and `GtkColumnViewColumn:resizable`
/// properties.
/// 
/// To learn more about the list widget framework, see the [overview](`ListWidget`).
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// columnview[.column-separators][.rich-list][.navigation-sidebar][.data-table]
/// ├── header
/// │   ├── <column header>
/// ┊   ┊
/// │   ╰── <column header>
/// │
/// ├── listview
/// │
/// ┊
/// ╰── [rubberband]
/// 
/// ```
/// 
/// GtkColumnView uses a single CSS node named columnview. It may carry the
/// .column-separators style class, when `GtkColumnView:show`-column-separators
/// property is set. Header widets appear below a node with name header.
/// The rows are contained in a GtkListView widget, so there is a listview
/// node with the same structure as for a standalone GtkListView widget. If
/// `GtkColumnView:show`-row-separators is set, it will be passed on to the
/// list view, causing its CSS node to carry the .separators style class.
/// For rubberband selection, a node with name rubberband is used.
/// 
/// The main columnview node may also carry style classes to select
/// the style of [list presentation](ListContainers.html`list`-styles):
/// .rich-list, .navigation-sidebar or .data-table.
/// 
/// # Accessibility
/// 
/// GtkColumnView uses the `GTK_ACCESSIBLE_ROLE_TREE_GRID` role, header title
/// widgets are using the `GTK_ACCESSIBLE_ROLE_COLUMN_HEADER` role. The row widgets
/// are using the `GTK_ACCESSIBLE_ROLE_ROW` role, and individual cells are using
/// the `GTK_ACCESSIBLE_ROLE_GRID_CELL` role
public struct ColumnViewRef: ColumnViewProtocol {
        /// Untyped pointer to the underlying `GtkColumnView` instance.
    /// For type-safe access, use the generated, typed pointer `column_view_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ColumnViewRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkColumnView>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkColumnView>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkColumnView>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkColumnView>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ColumnViewProtocol`
    @inlinable init<T: ColumnViewProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkColumnView`.
    /// 
    /// You most likely want to call `gtk_column_view_append_column()` to
    /// add columns next.
    @inlinable init<SelectionModelT: SelectionModelProtocol>( model: SelectionModelT?) {
        let rv = gtk_column_view_new(model?.selection_model_ptr)
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `ColumnView` type acts as a reference-counted owner of an underlying `GtkColumnView` instance.
/// It provides the methods that can operate on this data type through `ColumnViewProtocol` conformance.
/// Use `ColumnView` as a strong reference or owner of a `GtkColumnView` instance.
///
/// GtkColumnView is a widget to present a view into a large dynamic list of items
/// using multiple columns with headers.
/// 
/// GtkColumnView uses the factories of its columns to generate a cell widget for
/// each column, for each visible item and displays them together as the row for
/// this item. The `GtkColumnView:show`-row-separators and
/// `GtkColumnView:show`-column-separators properties offer a simple way to display
/// separators between the rows or columns.
/// 
/// GtkColumnView allows the user to select items according to the selection
/// characteristics of the model. For models that allow multiple selected items,
/// it is possible to turn on *rubberband selection*, using
/// `GtkColumnView:enable`-rubberband.
/// 
/// The column view supports sorting that can be customized by the user by
/// clicking on column headers. To set this up, the `GtkSorter` returned by
/// `gtk_column_view_get_sorter()` must be attached to a sort model for the data
/// that the view is showing, and the columns must have sorters attached to them
/// by calling `gtk_column_view_column_set_sorter()`. The initial sort order can be
/// set with `gtk_column_view_sort_by_column()`.
/// 
/// The column view also supports interactive resizing and reordering of
/// columns, via Drag-and-Drop of the column headers. This can be enabled or
/// disabled with the `GtkColumnView:reorderable` and `GtkColumnViewColumn:resizable`
/// properties.
/// 
/// To learn more about the list widget framework, see the [overview](`ListWidget`).
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// columnview[.column-separators][.rich-list][.navigation-sidebar][.data-table]
/// ├── header
/// │   ├── <column header>
/// ┊   ┊
/// │   ╰── <column header>
/// │
/// ├── listview
/// │
/// ┊
/// ╰── [rubberband]
/// 
/// ```
/// 
/// GtkColumnView uses a single CSS node named columnview. It may carry the
/// .column-separators style class, when `GtkColumnView:show`-column-separators
/// property is set. Header widets appear below a node with name header.
/// The rows are contained in a GtkListView widget, so there is a listview
/// node with the same structure as for a standalone GtkListView widget. If
/// `GtkColumnView:show`-row-separators is set, it will be passed on to the
/// list view, causing its CSS node to carry the .separators style class.
/// For rubberband selection, a node with name rubberband is used.
/// 
/// The main columnview node may also carry style classes to select
/// the style of [list presentation](ListContainers.html`list`-styles):
/// .rich-list, .navigation-sidebar or .data-table.
/// 
/// # Accessibility
/// 
/// GtkColumnView uses the `GTK_ACCESSIBLE_ROLE_TREE_GRID` role, header title
/// widgets are using the `GTK_ACCESSIBLE_ROLE_COLUMN_HEADER` role. The row widgets
/// are using the `GTK_ACCESSIBLE_ROLE_ROW` role, and individual cells are using
/// the `GTK_ACCESSIBLE_ROLE_GRID_CELL` role
open class ColumnView: Widget, ColumnViewProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColumnView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkColumnView>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColumnView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkColumnView>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColumnView` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColumnView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColumnView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkColumnView>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColumnView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkColumnView>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkColumnView`.
    /// i.e., ownership is transferred to the `ColumnView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkColumnView>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ColumnViewProtocol`
    /// Will retain `GtkColumnView`.
    /// - Parameter other: an instance of a related type that implements `ColumnViewProtocol`
    @inlinable public init<T: ColumnViewProtocol>(columnView other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkColumnView`.
    /// 
    /// You most likely want to call `gtk_column_view_append_column()` to
    /// add columns next.
    @inlinable public init<SelectionModelT: SelectionModelProtocol>( model: SelectionModelT?) {
        let rv = gtk_column_view_new(model?.selection_model_ptr)
        super.init(gpointer: gpointer(rv))
    }


}

public enum ColumnViewPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    case canTarget = "can-target"
    /// The list of columns
    case columns = "columns"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`. See `gtk_widget_set_cursor()` for details.
    case cursor = "cursor"
    /// Allow rubberband selection
    case enableRubberband = "enable-rubberband"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    /// Model for the items displayed
    case model = "model"
    case name = "name"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    case parent = "parent"
    case receivesDefault = "receives-default"
    /// Whether columns are reorderable
    case reorderable = "reorderable"
    /// The `GtkRoot` widget of the widget tree containing this widget or `nil` if
    /// the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    /// Show separators between columns
    case showColumnSeparators = "show-column-separators"
    /// Show separators between rows
    case showRowSeparators = "show-row-separators"
    /// Activate rows on single click and select them on hover
    case singleClickActivate = "single-click-activate"
    /// Sorter with the sorting choices of the user
    case sorter = "sorter"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
}

public extension ColumnViewProtocol {
    /// Bind a `ColumnViewPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ColumnViewPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ColumnView property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ColumnViewPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ColumnView property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ColumnViewPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ColumnViewSignalName: String, SignalNameProtocol {
    /// The `activate` signal is emitted when a row has been activated by the user,
    /// usually via activating the GtkListBase|list.activate-item action.
    /// 
    /// This allows for a convenient way to handle activation in a columnview.
    /// See `gtk_list_item_set_activatable()` for details on how to use this signal.
    case activate = "activate"
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold. May result in finalization of the widget
    /// if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// The `direction`-changed signal is emitted when the text direction
    /// of a widget changes.
    case directionChanged = "direction-changed"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The `hide` signal is emitted when `widget` is hidden, for example with
    /// `gtk_widget_hide()`.
    case hide = "hide"
    /// Gets emitted if keyboard navigation fails.
    /// See `gtk_widget_keynav_failed()` for details.
    case keynavFailed = "keynav-failed"
    /// The `map` signal is emitted when `widget` is going to be mapped, that is
    /// when the widget is visible (which is controlled with
    /// `gtk_widget_set_visible()`) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of `GtkWidget::unmap`.
    case map = "map"
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// Emitted when `GtkWidget:has`-tooltip is `true` and the hover timeout
    /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
    /// focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// The `realize` signal is emitted when `widget` is associated with a
    /// `GdkSurface`, which means that `gtk_widget_realize()` has been called or the
    /// widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// The `show` signal is emitted when `widget` is shown, for example with
    /// `gtk_widget_show()`.
    case show = "show"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The `state`-flags-changed signal is emitted when the widget state
    /// changes, see `gtk_widget_get_state_flags()`.
    case stateFlagsChanged = "state-flags-changed"
    /// The `unmap` signal is emitted when `widget` is going to be unmapped, which
    /// means that either it or any of its parents up to the toplevel widget have
    /// been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer, it can be
    /// used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// The `unrealize` signal is emitted when the `GdkSurface` associated with
    /// `widget` is destroyed, which means that `gtk_widget_unrealize()` has been
    /// called or the widget has been unmapped (that is, it is going to be
    /// hidden).
    case unrealize = "unrealize"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    case notifyCanTarget = "notify::can-target"
    /// The list of columns
    case notifyColumns = "notify::columns"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`. See `gtk_widget_set_cursor()` for details.
    case notifyCursor = "notify::cursor"
    /// Allow rubberband selection
    case notifyEnableRubberband = "notify::enable-rubberband"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case notifyHalign = "notify::halign"
    case notifyHasDefault = "notify::has-default"
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginTop = "notify::margin-top"
    /// Model for the items displayed
    case notifyModel = "notify::model"
    case notifyName = "notify::name"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    case notifyParent = "notify::parent"
    case notifyReceivesDefault = "notify::receives-default"
    /// Whether columns are reorderable
    case notifyReorderable = "notify::reorderable"
    /// The `GtkRoot` widget of the widget tree containing this widget or `nil` if
    /// the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case notifyScaleFactor = "notify::scale-factor"
    case notifySensitive = "notify::sensitive"
    /// Show separators between columns
    case notifyShowColumnSeparators = "notify::show-column-separators"
    /// Show separators between rows
    case notifyShowRowSeparators = "notify::show-row-separators"
    /// Activate rows on single click and select them on hover
    case notifySingleClickActivate = "notify::single-click-activate"
    /// Sorter with the sorting choices of the user
    case notifySorter = "notify::sorter"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case notifyValign = "notify::valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case notifyVexpandSet = "notify::vexpand-set"
    case notifyVisible = "notify::visible"
    case notifyWidthRequest = "notify::width-request"
}

public extension ColumnViewProtocol {
    /// Connect a `ColumnViewSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @inlinable @discardableResult func connect(signal kind: ColumnViewSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> Int {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> Int {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(raw: ptr).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

// MARK: ColumnView Class: ColumnViewProtocol extension (methods and fields)
public extension ColumnViewProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkColumnView` instance.
    @inlinable var column_view_ptr: UnsafeMutablePointer<GtkColumnView>! { return ptr?.assumingMemoryBound(to: GtkColumnView.self) }

    /// Appends the `column` to the end of the columns in `self`.
    @inlinable func append<ColumnViewColumnT: ColumnViewColumnProtocol>(column: ColumnViewColumnT) {
        gtk_column_view_append_column(column_view_ptr, column.column_view_column_ptr)
    
    }

    /// Gets the list of columns in this column view. This list is constant over
    /// the lifetime of `self` and can be used to monitor changes to the columns
    /// of `self` by connecting to the `GListModel:items`-changed signal.
    @inlinable func getColumns() -> GIO.ListModelRef! {
        let rv = GIO.ListModelRef(gtk_column_view_get_columns(column_view_ptr))
        return rv
    }

    /// Returns whether rows can be selected by dragging with the mouse.
    @inlinable func getEnableRubberband() -> Bool {
        let rv = ((gtk_column_view_get_enable_rubberband(column_view_ptr)) != 0)
        return rv
    }

    /// Gets the model that's currently used to read the items displayed.
    @inlinable func getModel() -> SelectionModelRef! {
        let rv = SelectionModelRef(gconstpointer: gconstpointer(gtk_column_view_get_model(column_view_ptr)))
        return rv
    }

    /// Returns whether columns are reorderable.
    @inlinable func getReorderable() -> Bool {
        let rv = ((gtk_column_view_get_reorderable(column_view_ptr)) != 0)
        return rv
    }

    /// Returns whether the list should show separators
    /// between columns.
    @inlinable func getShowColumnSeparators() -> Bool {
        let rv = ((gtk_column_view_get_show_column_separators(column_view_ptr)) != 0)
        return rv
    }

    /// Returns whether the list should show separators
    /// between rows.
    @inlinable func getShowRowSeparators() -> Bool {
        let rv = ((gtk_column_view_get_show_row_separators(column_view_ptr)) != 0)
        return rv
    }

    /// Returns whether rows will be activated on single click and
    /// selected on hover.
    @inlinable func getSingleClickActivate() -> Bool {
        let rv = ((gtk_column_view_get_single_click_activate(column_view_ptr)) != 0)
        return rv
    }

    /// Returns a special sorter that reflects the users sorting
    /// choices in the column view.
    /// 
    /// To allow users to customizable sorting by clicking on column
    /// headers, this sorter needs to be set on the sort model underneath
    /// the model that is displayed by the view.
    /// 
    /// See `gtk_column_view_column_set_sorter()` for setting up
    /// per-column sorting.
    /// 
    /// Here is an example:
    /// ```
    ///   gtk_column_view_column_set_sorter (column, sorter);
    ///   gtk_column_view_append_column (view, column);
    ///   sorter = g_object_ref (gtk_column_view_get_sorter (view)));
    ///   model = gtk_sort_list_model_new (store, sorter);
    ///   selection = gtk_no_selection_new (model);
    ///   gtk_column_view_set_model (view, selection);
    /// ```
    /// 
    @inlinable func getSorter() -> SorterRef! {
        let rv = SorterRef(gconstpointer: gconstpointer(gtk_column_view_get_sorter(column_view_ptr)))
        return rv
    }

    /// Inserts a column at the given position in the columns of `self`.
    /// 
    /// If `column` is already a column of `self`, it will be repositioned.
    @inlinable func insertColumn<ColumnViewColumnT: ColumnViewColumnProtocol>(position: Int, column: ColumnViewColumnT) {
        gtk_column_view_insert_column(column_view_ptr, guint(position), column.column_view_column_ptr)
    
    }

    /// Removes the `column` from the list of columns of `self`.
    @inlinable func remove<ColumnViewColumnT: ColumnViewColumnProtocol>(column: ColumnViewColumnT) {
        gtk_column_view_remove_column(column_view_ptr, column.column_view_column_ptr)
    
    }

    /// Sets whether selections can be changed by dragging with the mouse.
    @inlinable func set(enableRubberband: Bool) {
        gtk_column_view_set_enable_rubberband(column_view_ptr, gboolean((enableRubberband) ? 1 : 0))
    
    }

    /// Sets the `GtkSelectionModel` to use.
    @inlinable func set(model: SelectionModelRef? = nil) {
        gtk_column_view_set_model(column_view_ptr, model?.selection_model_ptr)
    
    }
    /// Sets the `GtkSelectionModel` to use.
    @inlinable func set<SelectionModelT: SelectionModelProtocol>(model: SelectionModelT?) {
        gtk_column_view_set_model(column_view_ptr, model?.selection_model_ptr)
    
    }

    /// Sets whether columns should be reorderable by dragging.
    @inlinable func set(reorderable: Bool) {
        gtk_column_view_set_reorderable(column_view_ptr, gboolean((reorderable) ? 1 : 0))
    
    }

    /// Sets whether the list should show separators
    /// between columns.
    @inlinable func set(showColumnSeparators: Bool) {
        gtk_column_view_set_show_column_separators(column_view_ptr, gboolean((showColumnSeparators) ? 1 : 0))
    
    }

    /// Sets whether the list should show separators
    /// between rows.
    @inlinable func set(showRowSeparators: Bool) {
        gtk_column_view_set_show_row_separators(column_view_ptr, gboolean((showRowSeparators) ? 1 : 0))
    
    }

    /// Sets whether rows should be activated on single click and
    /// selected on hover.
    @inlinable func set(singleClickActivate: Bool) {
        gtk_column_view_set_single_click_activate(column_view_ptr, gboolean((singleClickActivate) ? 1 : 0))
    
    }

    /// Sets the sorting of the view.
    /// 
    /// This function should be used to set up the initial sorting. At runtime,
    /// users can change the sorting of a column view by clicking on the list headers.
    /// 
    /// This call only has an effect if the sorter returned by `gtk_column_view_get_sorter()`
    /// is set on a sort model, and `gtk_column_view_column_set_sorter()` has been called
    /// on `column` to associate a sorter with the column.
    /// 
    /// If `column` is `nil`, the view will be unsorted.
    @inlinable func sortBy(column: ColumnViewColumnRef? = nil, direction: GtkSortType) {
        gtk_column_view_sort_by_column(column_view_ptr, column?.column_view_column_ptr, direction)
    
    }
    /// Sets the sorting of the view.
    /// 
    /// This function should be used to set up the initial sorting. At runtime,
    /// users can change the sorting of a column view by clicking on the list headers.
    /// 
    /// This call only has an effect if the sorter returned by `gtk_column_view_get_sorter()`
    /// is set on a sort model, and `gtk_column_view_column_set_sorter()` has been called
    /// on `column` to associate a sorter with the column.
    /// 
    /// If `column` is `nil`, the view will be unsorted.
    @inlinable func sortBy<ColumnViewColumnT: ColumnViewColumnProtocol>(column: ColumnViewColumnT?, direction: GtkSortType) {
        gtk_column_view_sort_by_column(column_view_ptr, column?.column_view_column_ptr, direction)
    
    }
    /// The list of columns
    @inlinable var columns: GIO.ListModelRef! {
        /// Gets the list of columns in this column view. This list is constant over
        /// the lifetime of `self` and can be used to monitor changes to the columns
        /// of `self` by connecting to the `GListModel:items`-changed signal.
        get {
            let rv = GIO.ListModelRef(gtk_column_view_get_columns(column_view_ptr))
            return rv
        }
    }

    /// Returns whether rows can be selected by dragging with the mouse.
    @inlinable var enableRubberband: Bool {
        /// Returns whether rows can be selected by dragging with the mouse.
        get {
            let rv = ((gtk_column_view_get_enable_rubberband(column_view_ptr)) != 0)
            return rv
        }
        /// Sets whether selections can be changed by dragging with the mouse.
        nonmutating set {
            gtk_column_view_set_enable_rubberband(column_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Model for the items displayed
    @inlinable var model: SelectionModelRef! {
        /// Gets the model that's currently used to read the items displayed.
        get {
            let rv = SelectionModelRef(gconstpointer: gconstpointer(gtk_column_view_get_model(column_view_ptr)))
            return rv
        }
        /// Sets the `GtkSelectionModel` to use.
        nonmutating set {
            gtk_column_view_set_model(column_view_ptr, UnsafeMutablePointer<GtkSelectionModel>(newValue?.selection_model_ptr))
        }
    }

    /// Whether columns are reorderable
    @inlinable var reorderable: Bool {
        /// Returns whether columns are reorderable.
        get {
            let rv = ((gtk_column_view_get_reorderable(column_view_ptr)) != 0)
            return rv
        }
        /// Sets whether columns should be reorderable by dragging.
        nonmutating set {
            gtk_column_view_set_reorderable(column_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns whether the list should show separators
    /// between columns.
    @inlinable var showColumnSeparators: Bool {
        /// Returns whether the list should show separators
        /// between columns.
        get {
            let rv = ((gtk_column_view_get_show_column_separators(column_view_ptr)) != 0)
            return rv
        }
        /// Sets whether the list should show separators
        /// between columns.
        nonmutating set {
            gtk_column_view_set_show_column_separators(column_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns whether the list should show separators
    /// between rows.
    @inlinable var showRowSeparators: Bool {
        /// Returns whether the list should show separators
        /// between rows.
        get {
            let rv = ((gtk_column_view_get_show_row_separators(column_view_ptr)) != 0)
            return rv
        }
        /// Sets whether the list should show separators
        /// between rows.
        nonmutating set {
            gtk_column_view_set_show_row_separators(column_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns whether rows will be activated on single click and
    /// selected on hover.
    @inlinable var singleClickActivate: Bool {
        /// Returns whether rows will be activated on single click and
        /// selected on hover.
        get {
            let rv = ((gtk_column_view_get_single_click_activate(column_view_ptr)) != 0)
            return rv
        }
        /// Sets whether rows should be activated on single click and
        /// selected on hover.
        nonmutating set {
            gtk_column_view_set_single_click_activate(column_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Sorter with the sorting choices of the user
    @inlinable var sorter: SorterRef! {
        /// Returns a special sorter that reflects the users sorting
        /// choices in the column view.
        /// 
        /// To allow users to customizable sorting by clicking on column
        /// headers, this sorter needs to be set on the sort model underneath
        /// the model that is displayed by the view.
        /// 
        /// See `gtk_column_view_column_set_sorter()` for setting up
        /// per-column sorting.
        /// 
        /// Here is an example:
        /// ```
        ///   gtk_column_view_column_set_sorter (column, sorter);
        ///   gtk_column_view_append_column (view, column);
        ///   sorter = g_object_ref (gtk_column_view_get_sorter (view)));
        ///   model = gtk_sort_list_model_new (store, sorter);
        ///   selection = gtk_no_selection_new (model);
        ///   gtk_column_view_set_model (view, selection);
        /// ```
        /// 
        get {
            let rv = SorterRef(gconstpointer: gconstpointer(gtk_column_view_get_sorter(column_view_ptr)))
            return rv
        }
    }


}



// MARK: - ColumnViewColumn Class

/// The `ColumnViewColumnProtocol` protocol exposes the methods and properties of an underlying `GtkColumnViewColumn` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ColumnViewColumn`.
/// Alternatively, use `ColumnViewColumnRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// GtkColumnViewColumn represents the columns being added to `GtkColumnView`.
/// 
/// Columns have a title, and can optionally have a header menu set
/// with `gtk_column_view_column_set_header_menu()`.
/// 
/// A sorter can be associated with a column using
/// `gtk_column_view_column_set_sorter()`, to let users influence sorting by
/// clicking on the column header.
public protocol ColumnViewColumnProtocol: GLibObject.ObjectProtocol {
        /// Untyped pointer to the underlying `GtkColumnViewColumn` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkColumnViewColumn` instance.
    var column_view_column_ptr: UnsafeMutablePointer<GtkColumnViewColumn>! { get }

}

/// The `ColumnViewColumnRef` type acts as a lightweight Swift reference to an underlying `GtkColumnViewColumn` instance.
/// It exposes methods that can operate on this data type through `ColumnViewColumnProtocol` conformance.
/// Use `ColumnViewColumnRef` only as an `unowned` reference to an existing `GtkColumnViewColumn` instance.
///
/// GtkColumnViewColumn represents the columns being added to `GtkColumnView`.
/// 
/// Columns have a title, and can optionally have a header menu set
/// with `gtk_column_view_column_set_header_menu()`.
/// 
/// A sorter can be associated with a column using
/// `gtk_column_view_column_set_sorter()`, to let users influence sorting by
/// clicking on the column header.
public struct ColumnViewColumnRef: ColumnViewColumnProtocol {
        /// Untyped pointer to the underlying `GtkColumnViewColumn` instance.
    /// For type-safe access, use the generated, typed pointer `column_view_column_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ColumnViewColumnRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkColumnViewColumn>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkColumnViewColumn>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkColumnViewColumn>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkColumnViewColumn>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ColumnViewColumnProtocol`
    @inlinable init<T: ColumnViewColumnProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkColumnViewColumn` that uses the given `factory` for
    /// mapping items to widgets.
    /// 
    /// You most likely want to call `gtk_column_add_column()` next.
    /// 
    /// The function takes ownership of the
    /// argument, so you can write code like
    /// ```
    ///   column = gtk_column_view_column_new (`_("Name")`,
    ///     gtk_builder_list_item_factory_new_from_resource ("/name.ui"));
    /// ```
    @inlinable init<ListItemFactoryT: ListItemFactoryProtocol>( title: UnsafePointer<CChar>? = nil, factory: ListItemFactoryT?) {
        let rv = gtk_column_view_column_new(title, factory?.list_item_factory_ptr)
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `ColumnViewColumn` type acts as a reference-counted owner of an underlying `GtkColumnViewColumn` instance.
/// It provides the methods that can operate on this data type through `ColumnViewColumnProtocol` conformance.
/// Use `ColumnViewColumn` as a strong reference or owner of a `GtkColumnViewColumn` instance.
///
/// GtkColumnViewColumn represents the columns being added to `GtkColumnView`.
/// 
/// Columns have a title, and can optionally have a header menu set
/// with `gtk_column_view_column_set_header_menu()`.
/// 
/// A sorter can be associated with a column using
/// `gtk_column_view_column_set_sorter()`, to let users influence sorting by
/// clicking on the column header.
open class ColumnViewColumn: GLibObject.Object, ColumnViewColumnProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColumnViewColumn` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkColumnViewColumn>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColumnViewColumn` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkColumnViewColumn>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColumnViewColumn` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColumnViewColumn` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColumnViewColumn` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkColumnViewColumn>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColumnViewColumn` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkColumnViewColumn>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkColumnViewColumn`.
    /// i.e., ownership is transferred to the `ColumnViewColumn` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkColumnViewColumn>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ColumnViewColumnProtocol`
    /// Will retain `GtkColumnViewColumn`.
    /// - Parameter other: an instance of a related type that implements `ColumnViewColumnProtocol`
    @inlinable public init<T: ColumnViewColumnProtocol>(columnViewColumn other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkColumnViewColumn` that uses the given `factory` for
    /// mapping items to widgets.
    /// 
    /// You most likely want to call `gtk_column_add_column()` next.
    /// 
    /// The function takes ownership of the
    /// argument, so you can write code like
    /// ```
    ///   column = gtk_column_view_column_new (`_("Name")`,
    ///     gtk_builder_list_item_factory_new_from_resource ("/name.ui"));
    /// ```
    @inlinable public init<ListItemFactoryT: ListItemFactoryProtocol>( title: UnsafePointer<CChar>? = nil, factory: ListItemFactoryT?) {
        let rv = gtk_column_view_column_new(title, factory?.list_item_factory_ptr)
        super.init(gpointer: gpointer(rv))
    }


}

public enum ColumnViewColumnPropertyName: String, PropertyNameProtocol {
    /// `GtkColumnView` this column is a part of
    case columnView = "column-view"
    /// Column gets share of extra width allocated to the view
    case expand = "expand"
    /// Factory for populating list items
    case factory = "factory"
    /// If not -1, this is the width that the column is allocated,
    /// regardless of the size of its content.
    case fixedWidth = "fixed-width"
    /// Menu model used to create the context menu for the column header.
    case headerMenu = "header-menu"
    /// Whether this column is resizable
    case resizable = "resizable"
    /// Sorter for sorting items according to this column
    case sorter = "sorter"
    /// Title displayed in the header
    case title = "title"
    /// Whether this column is visible
    case visible = "visible"
}

public extension ColumnViewColumnProtocol {
    /// Bind a `ColumnViewColumnPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ColumnViewColumnPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ColumnViewColumn property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ColumnViewColumnPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ColumnViewColumn property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ColumnViewColumnPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ColumnViewColumnSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// `GtkColumnView` this column is a part of
    case notifyColumnView = "notify::column-view"
    /// Column gets share of extra width allocated to the view
    case notifyExpand = "notify::expand"
    /// Factory for populating list items
    case notifyFactory = "notify::factory"
    /// If not -1, this is the width that the column is allocated,
    /// regardless of the size of its content.
    case notifyFixedWidth = "notify::fixed-width"
    /// Menu model used to create the context menu for the column header.
    case notifyHeaderMenu = "notify::header-menu"
    /// Whether this column is resizable
    case notifyResizable = "notify::resizable"
    /// Sorter for sorting items according to this column
    case notifySorter = "notify::sorter"
    /// Title displayed in the header
    case notifyTitle = "notify::title"
    /// Whether this column is visible
    case notifyVisible = "notify::visible"
}

public extension ColumnViewColumnProtocol {
    /// Connect a `ColumnViewColumnSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @inlinable @discardableResult func connect(signal kind: ColumnViewColumnSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> Int {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> Int {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(raw: ptr).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

// MARK: ColumnViewColumn Class: ColumnViewColumnProtocol extension (methods and fields)
public extension ColumnViewColumnProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkColumnViewColumn` instance.
    @inlinable var column_view_column_ptr: UnsafeMutablePointer<GtkColumnViewColumn>! { return ptr?.assumingMemoryBound(to: GtkColumnViewColumn.self) }

    /// Gets the column view that's currently displaying this column.
    /// 
    /// If `self` has not been added to a column view yet, `nil` is returned.
    @inlinable func getColumnView() -> ColumnViewRef! {
        let rv = ColumnViewRef(gconstpointer: gconstpointer(gtk_column_view_column_get_column_view(column_view_column_ptr)))
        return rv
    }

    /// Returns whether this column should expand.
    @inlinable func getExpand() -> Bool {
        let rv = ((gtk_column_view_column_get_expand(column_view_column_ptr)) != 0)
        return rv
    }

    /// Gets the factory that's currently used to populate list items for
    /// this column.
    @inlinable func getFactory() -> ListItemFactoryRef! {
        let rv = ListItemFactoryRef(gconstpointer: gconstpointer(gtk_column_view_column_get_factory(column_view_column_ptr)))
        return rv
    }

    /// Gets the fixed width of the column.
    @inlinable func getFixedWidth() -> Int {
        let rv = Int(gtk_column_view_column_get_fixed_width(column_view_column_ptr))
        return rv
    }

    /// Gets the menu model that is used to create the context menu
    /// for the column header.
    @inlinable func getHeaderMenu() -> GIO.MenuModelRef! {
        let rv = GIO.MenuModelRef(gtk_column_view_column_get_header_menu(column_view_column_ptr))
        return rv
    }

    /// Returns whether this column is resizable.
    @inlinable func getResizable() -> Bool {
        let rv = ((gtk_column_view_column_get_resizable(column_view_column_ptr)) != 0)
        return rv
    }

    /// Returns the sorter that is associated with the column.
    @inlinable func getSorter() -> SorterRef! {
        let rv = SorterRef(gconstpointer: gconstpointer(gtk_column_view_column_get_sorter(column_view_column_ptr)))
        return rv
    }

    /// Returns the title set with `gtk_column_view_column_set_title()`.
    @inlinable func getTitle() -> String! {
        let rv = gtk_column_view_column_get_title(column_view_column_ptr).map({ String(cString: $0) })
        return rv
    }

    /// Returns whether this column is visible.
    @inlinable func getVisible() -> Bool {
        let rv = ((gtk_column_view_column_get_visible(column_view_column_ptr)) != 0)
        return rv
    }

    /// Sets the column to take available extra space.
    /// 
    /// The extra space is shared equally amongst all columns that
    /// have the expand set to `true`.
    @inlinable func set(expand: Bool) {
        gtk_column_view_column_set_expand(column_view_column_ptr, gboolean((expand) ? 1 : 0))
    
    }

    /// Sets the `GtkListItemFactory` to use for populating list items for this
    /// column.
    @inlinable func set(factory: ListItemFactoryRef? = nil) {
        gtk_column_view_column_set_factory(column_view_column_ptr, factory?.list_item_factory_ptr)
    
    }
    /// Sets the `GtkListItemFactory` to use for populating list items for this
    /// column.
    @inlinable func set<ListItemFactoryT: ListItemFactoryProtocol>(factory: ListItemFactoryT?) {
        gtk_column_view_column_set_factory(column_view_column_ptr, factory?.list_item_factory_ptr)
    
    }

    /// If `fixed_width` is not -1, sets the fixed width of `column`;
    /// otherwise unsets it.
    /// 
    /// Setting a fixed width overrides the automatically calculated
    /// width. Interactive resizing also sets the “fixed-width” property.
    @inlinable func set(fixedWidth: Int) {
        gtk_column_view_column_set_fixed_width(column_view_column_ptr, gint(fixedWidth))
    
    }

    /// Sets the menu model that is used to create the context menu
    /// for the column header.
    @inlinable func setHeader(menu: GIO.MenuModelRef? = nil) {
        gtk_column_view_column_set_header_menu(column_view_column_ptr, menu?.menu_model_ptr)
    
    }
    /// Sets the menu model that is used to create the context menu
    /// for the column header.
    @inlinable func setHeader<MenuModelT: GIO.MenuModelProtocol>(menu: MenuModelT?) {
        gtk_column_view_column_set_header_menu(column_view_column_ptr, menu?.menu_model_ptr)
    
    }

    /// Sets whether this column should be resizable by dragging.
    @inlinable func set(resizable: Bool) {
        gtk_column_view_column_set_resizable(column_view_column_ptr, gboolean((resizable) ? 1 : 0))
    
    }

    /// Associates a sorter with the column.
    /// 
    /// If `sorter` is `nil`, the column will not let users change
    /// the sorting by clicking on its header.
    /// 
    /// This sorter can be made active by clicking on the column
    /// header, or by calling `gtk_column_view_sort_by_column()`.
    /// 
    /// See `gtk_column_view_get_sorter()` for the necessary steps
    /// for setting up customizable sorting for `GtkColumnView`.
    @inlinable func set(sorter: SorterRef? = nil) {
        gtk_column_view_column_set_sorter(column_view_column_ptr, sorter?.sorter_ptr)
    
    }
    /// Associates a sorter with the column.
    /// 
    /// If `sorter` is `nil`, the column will not let users change
    /// the sorting by clicking on its header.
    /// 
    /// This sorter can be made active by clicking on the column
    /// header, or by calling `gtk_column_view_sort_by_column()`.
    /// 
    /// See `gtk_column_view_get_sorter()` for the necessary steps
    /// for setting up customizable sorting for `GtkColumnView`.
    @inlinable func set<SorterT: SorterProtocol>(sorter: SorterT?) {
        gtk_column_view_column_set_sorter(column_view_column_ptr, sorter?.sorter_ptr)
    
    }

    /// Sets the title of this column. The title is displayed in the header of a
    /// `GtkColumnView` for this column and is therefore user-facing text that should
    /// be translated.
    @inlinable func set(title: UnsafePointer<CChar>? = nil) {
        gtk_column_view_column_set_title(column_view_column_ptr, title)
    
    }

    /// Sets whether this column should be visible in views.
    @inlinable func set(visible: Bool) {
        gtk_column_view_column_set_visible(column_view_column_ptr, gboolean((visible) ? 1 : 0))
    
    }
    /// Gets the column view that's currently displaying this column.
    /// 
    /// If `self` has not been added to a column view yet, `nil` is returned.
    @inlinable var columnView: ColumnViewRef! {
        /// Gets the column view that's currently displaying this column.
        /// 
        /// If `self` has not been added to a column view yet, `nil` is returned.
        get {
            let rv = ColumnViewRef(gconstpointer: gconstpointer(gtk_column_view_column_get_column_view(column_view_column_ptr)))
            return rv
        }
    }

    /// Column gets share of extra width allocated to the view
    @inlinable var expand: Bool {
        /// Returns whether this column should expand.
        get {
            let rv = ((gtk_column_view_column_get_expand(column_view_column_ptr)) != 0)
            return rv
        }
        /// Sets the column to take available extra space.
        /// 
        /// The extra space is shared equally amongst all columns that
        /// have the expand set to `true`.
        nonmutating set {
            gtk_column_view_column_set_expand(column_view_column_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Factory for populating list items
    @inlinable var factory: ListItemFactoryRef! {
        /// Gets the factory that's currently used to populate list items for
        /// this column.
        get {
            let rv = ListItemFactoryRef(gconstpointer: gconstpointer(gtk_column_view_column_get_factory(column_view_column_ptr)))
            return rv
        }
        /// Sets the `GtkListItemFactory` to use for populating list items for this
        /// column.
        nonmutating set {
            gtk_column_view_column_set_factory(column_view_column_ptr, UnsafeMutablePointer<GtkListItemFactory>(newValue?.list_item_factory_ptr))
        }
    }

    /// Gets the fixed width of the column.
    @inlinable var fixedWidth: Int {
        /// Gets the fixed width of the column.
        get {
            let rv = Int(gtk_column_view_column_get_fixed_width(column_view_column_ptr))
            return rv
        }
        /// If `fixed_width` is not -1, sets the fixed width of `column`;
        /// otherwise unsets it.
        /// 
        /// Setting a fixed width overrides the automatically calculated
        /// width. Interactive resizing also sets the “fixed-width” property.
        nonmutating set {
            gtk_column_view_column_set_fixed_width(column_view_column_ptr, gint(newValue))
        }
    }

    /// Gets the menu model that is used to create the context menu
    /// for the column header.
    @inlinable var headerMenu: GIO.MenuModelRef! {
        /// Gets the menu model that is used to create the context menu
        /// for the column header.
        get {
            let rv = GIO.MenuModelRef(gtk_column_view_column_get_header_menu(column_view_column_ptr))
            return rv
        }
        /// Sets the menu model that is used to create the context menu
        /// for the column header.
        nonmutating set {
            gtk_column_view_column_set_header_menu(column_view_column_ptr, UnsafeMutablePointer<GMenuModel>(newValue?.menu_model_ptr))
        }
    }

    /// Whether this column is resizable
    @inlinable var resizable: Bool {
        /// Returns whether this column is resizable.
        get {
            let rv = ((gtk_column_view_column_get_resizable(column_view_column_ptr)) != 0)
            return rv
        }
        /// Sets whether this column should be resizable by dragging.
        nonmutating set {
            gtk_column_view_column_set_resizable(column_view_column_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Sorter for sorting items according to this column
    @inlinable var sorter: SorterRef! {
        /// Returns the sorter that is associated with the column.
        get {
            let rv = SorterRef(gconstpointer: gconstpointer(gtk_column_view_column_get_sorter(column_view_column_ptr)))
            return rv
        }
        /// Associates a sorter with the column.
        /// 
        /// If `sorter` is `nil`, the column will not let users change
        /// the sorting by clicking on its header.
        /// 
        /// This sorter can be made active by clicking on the column
        /// header, or by calling `gtk_column_view_sort_by_column()`.
        /// 
        /// See `gtk_column_view_get_sorter()` for the necessary steps
        /// for setting up customizable sorting for `GtkColumnView`.
        nonmutating set {
            gtk_column_view_column_set_sorter(column_view_column_ptr, UnsafeMutablePointer<GtkSorter>(newValue?.sorter_ptr))
        }
    }

    /// Title displayed in the header
    @inlinable var title: String! {
        /// Returns the title set with `gtk_column_view_column_set_title()`.
        get {
            let rv = gtk_column_view_column_get_title(column_view_column_ptr).map({ String(cString: $0) })
            return rv
        }
        /// Sets the title of this column. The title is displayed in the header of a
        /// `GtkColumnView` for this column and is therefore user-facing text that should
        /// be translated.
        nonmutating set {
            gtk_column_view_column_set_title(column_view_column_ptr, newValue)
        }
    }

    /// Whether this column is visible
    @inlinable var visible: Bool {
        /// Returns whether this column is visible.
        get {
            let rv = ((gtk_column_view_column_get_visible(column_view_column_ptr)) != 0)
            return rv
        }
        /// Sets whether this column should be visible in views.
        nonmutating set {
            gtk_column_view_column_set_visible(column_view_column_ptr, gboolean((newValue) ? 1 : 0))
        }
    }


}



// MARK: - ComboBox Class

/// The `ComboBoxProtocol` protocol exposes the methods and properties of an underlying `GtkComboBox` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ComboBox`.
/// Alternatively, use `ComboBoxRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A GtkComboBox is a widget that allows the user to choose from a list of
/// valid choices. The GtkComboBox displays the selected choice. When
/// activated, the GtkComboBox displays a popup which allows the user to
/// make a new choice. The style in which the selected value is displayed,
/// and the style of the popup is determined by the current theme. It may
/// be similar to a Windows-style combo box.
/// 
/// The GtkComboBox uses the model-view pattern; the list of valid choices
/// is specified in the form of a tree model, and the display of the choices
/// can be adapted to the data in the model by using cell renderers, as you
/// would in a tree view. This is possible since GtkComboBox implements the
/// `GtkCellLayout` interface. The tree model holding the valid choices is
/// not restricted to a flat list, it can be a real tree, and the popup will
/// reflect the tree structure.
/// 
/// To allow the user to enter values not in the model, the “has-entry”
/// property allows the GtkComboBox to contain a `GtkEntry`. This entry
/// can be accessed by calling `gtk_combo_box_get_child()` on the combo box.
/// 
/// For a simple list of textual choices, the model-view API of GtkComboBox
/// can be a bit overwhelming. In this case, `GtkComboBoxText` offers a
/// simple alternative. Both GtkComboBox and `GtkComboBoxText` can contain
/// an entry.
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// combobox
/// ├── box.linked
/// │   ╰── button.combo
/// │       ╰── box
/// │           ├── cellview
/// │           ╰── arrow
/// ╰── window.popup
/// ```
/// 
/// A normal combobox contains a box with the .linked class, a button
/// with the .combo class and inside those buttons, there are a cellview and
/// an arrow.
/// 
/// (plain Language Example):
/// ```plain
/// combobox
/// ├── box.linked
/// │   ├── entry.combo
/// │   ╰── button.combo
/// │       ╰── box
/// │           ╰── arrow
/// ╰── window.popup
/// ```
/// 
/// A GtkComboBox with an entry has a single CSS node with name combobox. It
/// contains a box with the .linked class. That box contains an entry and a
/// button, both with the .combo class added.
/// The button also contains another node with name arrow.
/// 
/// # Accessibility
/// 
/// GtkComboBox uses the `GTK_ACCESSIBLE_ROLE_COMBO_BOX` role.
public protocol ComboBoxProtocol: WidgetProtocol, CellEditableProtocol, CellLayoutProtocol {
        /// Untyped pointer to the underlying `GtkComboBox` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkComboBox` instance.
    var combo_box_ptr: UnsafeMutablePointer<GtkComboBox>! { get }

}

/// The `ComboBoxRef` type acts as a lightweight Swift reference to an underlying `GtkComboBox` instance.
/// It exposes methods that can operate on this data type through `ComboBoxProtocol` conformance.
/// Use `ComboBoxRef` only as an `unowned` reference to an existing `GtkComboBox` instance.
///
/// A GtkComboBox is a widget that allows the user to choose from a list of
/// valid choices. The GtkComboBox displays the selected choice. When
/// activated, the GtkComboBox displays a popup which allows the user to
/// make a new choice. The style in which the selected value is displayed,
/// and the style of the popup is determined by the current theme. It may
/// be similar to a Windows-style combo box.
/// 
/// The GtkComboBox uses the model-view pattern; the list of valid choices
/// is specified in the form of a tree model, and the display of the choices
/// can be adapted to the data in the model by using cell renderers, as you
/// would in a tree view. This is possible since GtkComboBox implements the
/// `GtkCellLayout` interface. The tree model holding the valid choices is
/// not restricted to a flat list, it can be a real tree, and the popup will
/// reflect the tree structure.
/// 
/// To allow the user to enter values not in the model, the “has-entry”
/// property allows the GtkComboBox to contain a `GtkEntry`. This entry
/// can be accessed by calling `gtk_combo_box_get_child()` on the combo box.
/// 
/// For a simple list of textual choices, the model-view API of GtkComboBox
/// can be a bit overwhelming. In this case, `GtkComboBoxText` offers a
/// simple alternative. Both GtkComboBox and `GtkComboBoxText` can contain
/// an entry.
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// combobox
/// ├── box.linked
/// │   ╰── button.combo
/// │       ╰── box
/// │           ├── cellview
/// │           ╰── arrow
/// ╰── window.popup
/// ```
/// 
/// A normal combobox contains a box with the .linked class, a button
/// with the .combo class and inside those buttons, there are a cellview and
/// an arrow.
/// 
/// (plain Language Example):
/// ```plain
/// combobox
/// ├── box.linked
/// │   ├── entry.combo
/// │   ╰── button.combo
/// │       ╰── box
/// │           ╰── arrow
/// ╰── window.popup
/// ```
/// 
/// A GtkComboBox with an entry has a single CSS node with name combobox. It
/// contains a box with the .linked class. That box contains an entry and a
/// button, both with the .combo class added.
/// The button also contains another node with name arrow.
/// 
/// # Accessibility
/// 
/// GtkComboBox uses the `GTK_ACCESSIBLE_ROLE_COMBO_BOX` role.
public struct ComboBoxRef: ComboBoxProtocol {
        /// Untyped pointer to the underlying `GtkComboBox` instance.
    /// For type-safe access, use the generated, typed pointer `combo_box_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ComboBoxRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkComboBox>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkComboBox>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkComboBox>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkComboBox>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ComboBoxProtocol`
    @inlinable init<T: ComboBoxProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new empty `GtkComboBox`.
    @inlinable init() {
        let rv = gtk_combo_box_new()
        ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GtkComboBox` with the model initialized to `model`.
    @inlinable init<TreeModelT: TreeModelProtocol>(model: TreeModelT) {
        let rv = gtk_combo_box_new_with_model(model.tree_model_ptr)
        ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new empty `GtkComboBox` with an entry
    /// and with the model initialized to `model`.
    @inlinable init<TreeModelT: TreeModelProtocol>(modelAndEntry model: TreeModelT) {
        let rv = gtk_combo_box_new_with_model_and_entry(model.tree_model_ptr)
        ptr = UnsafeMutableRawPointer(rv)
    }
    /// Creates a new empty `GtkComboBox` with an entry.
    @inlinable static func newWithEntry() -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_combo_box_new_with_entry())) else { return nil }
        return rv
    }

    /// Creates a new `GtkComboBox` with the model initialized to `model`.
    @inlinable static func newWith<TreeModelT: TreeModelProtocol>(model: TreeModelT) -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_combo_box_new_with_model(model.tree_model_ptr))) else { return nil }
        return rv
    }

    /// Creates a new empty `GtkComboBox` with an entry
    /// and with the model initialized to `model`.
    @inlinable static func newWith<TreeModelT: TreeModelProtocol>(modelAndEntry model: TreeModelT) -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_combo_box_new_with_model_and_entry(model.tree_model_ptr))) else { return nil }
        return rv
    }
}

/// The `ComboBox` type acts as a reference-counted owner of an underlying `GtkComboBox` instance.
/// It provides the methods that can operate on this data type through `ComboBoxProtocol` conformance.
/// Use `ComboBox` as a strong reference or owner of a `GtkComboBox` instance.
///
/// A GtkComboBox is a widget that allows the user to choose from a list of
/// valid choices. The GtkComboBox displays the selected choice. When
/// activated, the GtkComboBox displays a popup which allows the user to
/// make a new choice. The style in which the selected value is displayed,
/// and the style of the popup is determined by the current theme. It may
/// be similar to a Windows-style combo box.
/// 
/// The GtkComboBox uses the model-view pattern; the list of valid choices
/// is specified in the form of a tree model, and the display of the choices
/// can be adapted to the data in the model by using cell renderers, as you
/// would in a tree view. This is possible since GtkComboBox implements the
/// `GtkCellLayout` interface. The tree model holding the valid choices is
/// not restricted to a flat list, it can be a real tree, and the popup will
/// reflect the tree structure.
/// 
/// To allow the user to enter values not in the model, the “has-entry”
/// property allows the GtkComboBox to contain a `GtkEntry`. This entry
/// can be accessed by calling `gtk_combo_box_get_child()` on the combo box.
/// 
/// For a simple list of textual choices, the model-view API of GtkComboBox
/// can be a bit overwhelming. In this case, `GtkComboBoxText` offers a
/// simple alternative. Both GtkComboBox and `GtkComboBoxText` can contain
/// an entry.
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// combobox
/// ├── box.linked
/// │   ╰── button.combo
/// │       ╰── box
/// │           ├── cellview
/// │           ╰── arrow
/// ╰── window.popup
/// ```
/// 
/// A normal combobox contains a box with the .linked class, a button
/// with the .combo class and inside those buttons, there are a cellview and
/// an arrow.
/// 
/// (plain Language Example):
/// ```plain
/// combobox
/// ├── box.linked
/// │   ├── entry.combo
/// │   ╰── button.combo
/// │       ╰── box
/// │           ╰── arrow
/// ╰── window.popup
/// ```
/// 
/// A GtkComboBox with an entry has a single CSS node with name combobox. It
/// contains a box with the .linked class. That box contains an entry and a
/// button, both with the .combo class added.
/// The button also contains another node with name arrow.
/// 
/// # Accessibility
/// 
/// GtkComboBox uses the `GTK_ACCESSIBLE_ROLE_COMBO_BOX` role.
open class ComboBox: Widget, ComboBoxProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ComboBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkComboBox>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ComboBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkComboBox>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ComboBox` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ComboBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ComboBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkComboBox>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ComboBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkComboBox>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkComboBox`.
    /// i.e., ownership is transferred to the `ComboBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkComboBox>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ComboBoxProtocol`
    /// Will retain `GtkComboBox`.
    /// - Parameter other: an instance of a related type that implements `ComboBoxProtocol`
    @inlinable public init<T: ComboBoxProtocol>(comboBox other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new empty `GtkComboBox`.
    @inlinable public init() {
        let rv = gtk_combo_box_new()
        super.init(gpointer: gpointer(rv))
    }

    /// Creates a new `GtkComboBox` with the model initialized to `model`.
    @inlinable public init<TreeModelT: TreeModelProtocol>(model: TreeModelT) {
        let rv = gtk_combo_box_new_with_model(model.tree_model_ptr)
        super.init(gpointer: gpointer(rv))
    }

    /// Creates a new empty `GtkComboBox` with an entry
    /// and with the model initialized to `model`.
    @inlinable public init<TreeModelT: TreeModelProtocol>(modelAndEntry model: TreeModelT) {
        let rv = gtk_combo_box_new_with_model_and_entry(model.tree_model_ptr)
        super.init(gpointer: gpointer(rv))
    }

    /// Creates a new empty `GtkComboBox` with an entry.
    @inlinable public static func newWithEntry() -> Widget! {
        guard let rv = Widget(gconstpointer: gconstpointer(gtk_combo_box_new_with_entry())) else { return nil }
        return rv
    }

    /// Creates a new `GtkComboBox` with the model initialized to `model`.
    @inlinable public static func newWith<TreeModelT: TreeModelProtocol>(model: TreeModelT) -> Widget! {
        guard let rv = Widget(gconstpointer: gconstpointer(gtk_combo_box_new_with_model(model.tree_model_ptr))) else { return nil }
        return rv
    }

    /// Creates a new empty `GtkComboBox` with an entry
    /// and with the model initialized to `model`.
    @inlinable public static func newWith<TreeModelT: TreeModelProtocol>(modelAndEntry model: TreeModelT) -> Widget! {
        guard let rv = Widget(gconstpointer: gconstpointer(gtk_combo_box_new_with_model_and_entry(model.tree_model_ptr))) else { return nil }
        return rv
    }

}

public enum ComboBoxPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    /// The item which is currently active. If the model is a non-flat treemodel,
    /// and the active item is not an immediate child of the root of the tree,
    /// this property has the value
    /// `gtk_tree_path_get_indices (path)[0]`,
    /// where `path` is the `GtkTreePath` of the active item.
    case active = "active"
    /// The value of the ID column of the active row.
    case activeId = "active-id"
    /// Whether the dropdown button is sensitive when
    /// the model is empty.
    case buttonSensitivity = "button-sensitivity"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    case canTarget = "can-target"
    case child = "child"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`. See `gtk_widget_set_cursor()` for details.
    case cursor = "cursor"
    /// The column in the combo box's model to associate with strings from the entry
    /// if the combo was created with `GtkComboBox:has`-entry = `true`.
    case entryTextColumn = "entry-text-column"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    /// Whether the combo box has an entry.
    case hasEntry = "has-entry"
    case hasFocus = "has-focus"
    /// The has-frame property controls whether a frame
    /// is drawn around the entry.
    case hasFrame = "has-frame"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    /// The column in the combo box's model that provides string
    /// IDs for the values in the model, if != -1.
    case idColumn = "id-column"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    /// The model from which the combo box takes the values shown
    /// in the list.
    case model = "model"
    case name = "name"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    case parent = "parent"
    /// Whether the popup's width should be a fixed width matching the
    /// allocated width of the combo box.
    case popupFixedWidth = "popup-fixed-width"
    /// Whether the combo boxes dropdown is popped up.
    /// Note that this property is mainly useful, because
    /// it allows you to connect to notify`popup`-shown.
    case popupShown = "popup-shown"
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget or `nil` if
    /// the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
}

public extension ComboBoxProtocol {
    /// Bind a `ComboBoxPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ComboBoxPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ComboBox property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ComboBoxPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ComboBox property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ComboBoxPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ComboBoxSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The changed signal is emitted when the active
    /// item is changed. The can be due to the user selecting
    /// a different item from the list, or due to a
    /// call to `gtk_combo_box_set_active_iter()`.
    /// It will also be emitted while typing into the entry of a combo box
    /// with an entry.
    case changed = "changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold. May result in finalization of the widget
    /// if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// The `direction`-changed signal is emitted when the text direction
    /// of a widget changes.
    case directionChanged = "direction-changed"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// For combo boxes that are created with an entry (See GtkComboBox:has-entry).
    /// 
    /// A signal which allows you to change how the text displayed in a combo box's
    /// entry is displayed.
    /// 
    /// Connect a signal handler which returns an allocated string representing
    /// `path`. That string will then be used to set the text in the combo box's entry.
    /// The default signal handler uses the text from the GtkComboBox`entry`-text-column
    /// model column.
    /// 
    /// Here's an example signal handler which fetches data from the model and
    /// displays it in the entry.
    /// (C Language Example):
    /// ```C
    /// static char *
    /// format_entry_text_callback (GtkComboBox *combo,
    ///                             const char *path,
    ///                             gpointer     user_data)
    /// {
    ///   GtkTreeIter iter;
    ///   GtkTreeModel model;
    ///   double       value;
    /// 
    ///   model = gtk_combo_box_get_model (combo);
    /// 
    ///   gtk_tree_model_get_iter_from_string (model, &iter, path);
    ///   gtk_tree_model_get (model, &iter,
    ///                       THE_DOUBLE_VALUE_COLUMN, &value,
    ///                       -1);
    /// 
    ///   return g_strdup_printf ("%g", value);
    /// }
    /// ```
    /// 
    case formatEntryText = "format-entry-text"
    /// The `hide` signal is emitted when `widget` is hidden, for example with
    /// `gtk_widget_hide()`.
    case hide = "hide"
    /// Gets emitted if keyboard navigation fails.
    /// See `gtk_widget_keynav_failed()` for details.
    case keynavFailed = "keynav-failed"
    /// The `map` signal is emitted when `widget` is going to be mapped, that is
    /// when the widget is visible (which is controlled with
    /// `gtk_widget_set_visible()`) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of `GtkWidget::unmap`.
    case map = "map"
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// The `move`-active signal is a
    /// [keybinding signal](#GtkSignalAction)
    /// which gets emitted to move the active selection.
    case moveActive = "move-active"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The `popdown` signal is a
    /// [keybinding signal](#GtkSignalAction)
    /// which gets emitted to popdown the combo box list.
    /// 
    /// The default bindings for this signal are Alt+Up and Escape.
    case popdown = "popdown"
    /// The `popup` signal is a
    /// [keybinding signal](#GtkSignalAction)
    /// which gets emitted to popup the combo box list.
    /// 
    /// The default binding for this signal is Alt+Down.
    case popup = "popup"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// Emitted when `GtkWidget:has`-tooltip is `true` and the hover timeout
    /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
    /// focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// The `realize` signal is emitted when `widget` is associated with a
    /// `GdkSurface`, which means that `gtk_widget_realize()` has been called or the
    /// widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// The `show` signal is emitted when `widget` is shown, for example with
    /// `gtk_widget_show()`.
    case show = "show"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The `state`-flags-changed signal is emitted when the widget state
    /// changes, see `gtk_widget_get_state_flags()`.
    case stateFlagsChanged = "state-flags-changed"
    /// The `unmap` signal is emitted when `widget` is going to be unmapped, which
    /// means that either it or any of its parents up to the toplevel widget have
    /// been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer, it can be
    /// used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// The `unrealize` signal is emitted when the `GdkSurface` associated with
    /// `widget` is destroyed, which means that `gtk_widget_unrealize()` has been
    /// called or the widget has been unmapped (that is, it is going to be
    /// hidden).
    case unrealize = "unrealize"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    /// The item which is currently active. If the model is a non-flat treemodel,
    /// and the active item is not an immediate child of the root of the tree,
    /// this property has the value
    /// `gtk_tree_path_get_indices (path)[0]`,
    /// where `path` is the `GtkTreePath` of the active item.
    case notifyActive = "notify::active"
    /// The value of the ID column of the active row.
    case notifyActiveId = "notify::active-id"
    /// Whether the dropdown button is sensitive when
    /// the model is empty.
    case notifyButtonSensitivity = "notify::button-sensitivity"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    case notifyCanTarget = "notify::can-target"
    case notifyChild = "notify::child"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`. See `gtk_widget_set_cursor()` for details.
    case notifyCursor = "notify::cursor"
    /// The column in the combo box's model to associate with strings from the entry
    /// if the combo was created with `GtkComboBox:has`-entry = `true`.
    case notifyEntryTextColumn = "notify::entry-text-column"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case notifyHalign = "notify::halign"
    case notifyHasDefault = "notify::has-default"
    /// Whether the combo box has an entry.
    case notifyHasEntry = "notify::has-entry"
    case notifyHasFocus = "notify::has-focus"
    /// The has-frame property controls whether a frame
    /// is drawn around the entry.
    case notifyHasFrame = "notify::has-frame"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The column in the combo box's model that provides string
    /// IDs for the values in the model, if != -1.
    case notifyIdColumn = "notify::id-column"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginTop = "notify::margin-top"
    /// The model from which the combo box takes the values shown
    /// in the list.
    case notifyModel = "notify::model"
    case notifyName = "notify::name"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    case notifyParent = "notify::parent"
    /// Whether the popup's width should be a fixed width matching the
    /// allocated width of the combo box.
    case notifyPopupFixedWidth = "notify::popup-fixed-width"
    /// Whether the combo boxes dropdown is popped up.
    /// Note that this property is mainly useful, because
    /// it allows you to connect to notify`popup`-shown.
    case notifyPopupShown = "notify::popup-shown"
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget or `nil` if
    /// the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case notifyScaleFactor = "notify::scale-factor"
    case notifySensitive = "notify::sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case notifyValign = "notify::valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case notifyVexpandSet = "notify::vexpand-set"
    case notifyVisible = "notify::visible"
    case notifyWidthRequest = "notify::width-request"
}

public extension ComboBoxProtocol {
    /// Connect a `ComboBoxSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @inlinable @discardableResult func connect(signal kind: ComboBoxSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> Int {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> Int {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(raw: ptr).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

// MARK: ComboBox Class: ComboBoxProtocol extension (methods and fields)
public extension ComboBoxProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkComboBox` instance.
    @inlinable var combo_box_ptr: UnsafeMutablePointer<GtkComboBox>! { return ptr?.assumingMemoryBound(to: GtkComboBox.self) }

    /// Returns the index of the currently active item, or -1 if there’s no
    /// active item. If the model is a non-flat treemodel, and the active item
    /// is not an immediate child of the root of the tree, this function returns
    /// `gtk_tree_path_get_indices (path)[0]`, where
    /// `path` is the `GtkTreePath` of the active item.
    @inlinable func getActive() -> Int {
        let rv = Int(gtk_combo_box_get_active(combo_box_ptr))
        return rv
    }

    /// Returns the ID of the active row of `combo_box`.  This value is taken
    /// from the active row and the column specified by the `GtkComboBox:id`-column
    /// property of `combo_box` (see `gtk_combo_box_set_id_column()`).
    /// 
    /// The returned value is an interned string which means that you can
    /// compare the pointer by value to other interned strings and that you
    /// must not free it.
    /// 
    /// If the `GtkComboBox:id`-column property of `combo_box` is not set, or if
    /// no row is active, or if the active row has a `nil` ID value, then `nil`
    /// is returned.
    @inlinable func getActiveId() -> String! {
        let rv = gtk_combo_box_get_active_id(combo_box_ptr).map({ String(cString: $0) })
        return rv
    }

    /// Sets `iter` to point to the currently active item, if any item is active.
    /// Otherwise, `iter` is left unchanged.
    @inlinable func getActive<TreeIterT: TreeIterProtocol>(iter: TreeIterT) -> Bool {
        let rv = ((gtk_combo_box_get_active_iter(combo_box_ptr, iter.tree_iter_ptr)) != 0)
        return rv
    }

    /// Returns whether the combo box sets the dropdown button
    /// sensitive or not when there are no items in the model.
    @inlinable func getButtonSensitivity() -> GtkSensitivityType {
        let rv = gtk_combo_box_get_button_sensitivity(combo_box_ptr)
        return rv
    }

    /// Gets the child widget of `combo_box`.
    @inlinable func getChild() -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_combo_box_get_child(combo_box_ptr))) else { return nil }
        return rv
    }

    /// Returns the column which `combo_box` is using to get the strings
    /// from to display in the internal entry.
    @inlinable func getEntryTextColumn() -> Int {
        let rv = Int(gtk_combo_box_get_entry_text_column(combo_box_ptr))
        return rv
    }

    /// Returns whether the combo box has an entry.
    @inlinable func getHasEntry() -> Bool {
        let rv = ((gtk_combo_box_get_has_entry(combo_box_ptr)) != 0)
        return rv
    }

    /// Returns the column which `combo_box` is using to get string IDs
    /// for values from.
    @inlinable func getIdColumn() -> Int {
        let rv = Int(gtk_combo_box_get_id_column(combo_box_ptr))
        return rv
    }

    /// Returns the `GtkTreeModel` which is acting as data source for `combo_box`.
    @inlinable func getModel() -> TreeModelRef! {
        let rv = TreeModelRef(gconstpointer: gconstpointer(gtk_combo_box_get_model(combo_box_ptr)))
        return rv
    }

    /// Gets whether the popup uses a fixed width matching
    /// the allocated width of the combo box.
    @inlinable func getPopupFixedWidth() -> Bool {
        let rv = ((gtk_combo_box_get_popup_fixed_width(combo_box_ptr)) != 0)
        return rv
    }

    /// Returns the current row separator function.
    @inlinable func getRowSeparatorFunc() -> GtkTreeViewRowSeparatorFunc! {
        let rv = gtk_combo_box_get_row_separator_func(combo_box_ptr)
        return rv
    }

    /// Hides the menu or dropdown list of `combo_box`.
    /// 
    /// This function is mostly intended for use by accessibility technologies;
    /// applications should have little use for it.
    @inlinable func popdown() {
        gtk_combo_box_popdown(combo_box_ptr)
    
    }

    /// Pops up the menu or dropdown list of `combo_box`.
    /// 
    /// This function is mostly intended for use by accessibility technologies;
    /// applications should have little use for it.
    /// 
    /// Before calling this, `combo_box` must be mapped, or nothing will happen.
    @inlinable func popup() {
        gtk_combo_box_popup(combo_box_ptr)
    
    }

    /// Pops up the menu of `combo_box`. Note that currently this does not do anything
    /// with the device, as it was previously only used for list-mode combo boxes,
    /// and those were removed in GTK 4. However, it is retained in case similar
    /// functionality is added back later.
    @inlinable func popupFor<DeviceT: Gdk.DeviceProtocol>(device: DeviceT) {
        gtk_combo_box_popup_for_device(combo_box_ptr, device.device_ptr)
    
    }

    /// Sets the active item of `combo_box` to be the item at `index`.
    @inlinable func setActive(index_: Int) {
        gtk_combo_box_set_active(combo_box_ptr, gint(index_))
    
    }

    /// Changes the active row of `combo_box` to the one that has an ID equal to
    /// `active_id`, or unsets the active row if `active_id` is `nil`.  Rows having
    /// a `nil` ID string cannot be made active by this function.
    /// 
    /// If the `GtkComboBox:id`-column property of `combo_box` is unset or if no
    /// row has the given ID then the function does nothing and returns `false`.
    @inlinable func set(activeId: UnsafePointer<CChar>? = nil) -> Bool {
        let rv = ((gtk_combo_box_set_active_id(combo_box_ptr, activeId)) != 0)
        return rv
    }

    /// Sets the current active item to be the one referenced by `iter`, or
    /// unsets the active item if `iter` is `nil`.
    @inlinable func setActive(iter: TreeIterRef? = nil) {
        gtk_combo_box_set_active_iter(combo_box_ptr, iter?.tree_iter_ptr)
    
    }
    /// Sets the current active item to be the one referenced by `iter`, or
    /// unsets the active item if `iter` is `nil`.
    @inlinable func setActive<TreeIterT: TreeIterProtocol>(iter: TreeIterT?) {
        gtk_combo_box_set_active_iter(combo_box_ptr, iter?.tree_iter_ptr)
    
    }

    /// Sets whether the dropdown button of the combo box should be
    /// always sensitive (`GTK_SENSITIVITY_ON`), never sensitive (`GTK_SENSITIVITY_OFF`)
    /// or only if there is at least one item to display (`GTK_SENSITIVITY_AUTO`).
    @inlinable func setButton(sensitivity: GtkSensitivityType) {
        gtk_combo_box_set_button_sensitivity(combo_box_ptr, sensitivity)
    
    }

    /// Sets the child widget of `combo_box`.
    @inlinable func set(child: WidgetRef? = nil) {
        gtk_combo_box_set_child(combo_box_ptr, child?.widget_ptr)
    
    }
    /// Sets the child widget of `combo_box`.
    @inlinable func set<WidgetT: WidgetProtocol>(child: WidgetT?) {
        gtk_combo_box_set_child(combo_box_ptr, child?.widget_ptr)
    
    }

    /// Sets the model column which `combo_box` should use to get strings from
    /// to be `text_column`. The column `text_column` in the model of `combo_box`
    /// must be of type `G_TYPE_STRING`.
    /// 
    /// This is only relevant if `combo_box` has been created with
    /// `GtkComboBox:has`-entry as `true`.
    @inlinable func setEntry(textColumn: Int) {
        gtk_combo_box_set_entry_text_column(combo_box_ptr, gint(textColumn))
    
    }

    /// Sets the model column which `combo_box` should use to get string IDs
    /// for values from. The column `id_column` in the model of `combo_box`
    /// must be of type `G_TYPE_STRING`.
    @inlinable func set(idColumn: Int) {
        gtk_combo_box_set_id_column(combo_box_ptr, gint(idColumn))
    
    }

    /// Sets the model used by `combo_box` to be `model`. Will unset a previously set
    /// model (if applicable). If model is `nil`, then it will unset the model.
    /// 
    /// Note that this function does not clear the cell renderers, you have to
    /// call `gtk_cell_layout_clear()` yourself if you need to set up different
    /// cell renderers for the new model.
    @inlinable func set(model: TreeModelRef? = nil) {
        gtk_combo_box_set_model(combo_box_ptr, model?.tree_model_ptr)
    
    }
    /// Sets the model used by `combo_box` to be `model`. Will unset a previously set
    /// model (if applicable). If model is `nil`, then it will unset the model.
    /// 
    /// Note that this function does not clear the cell renderers, you have to
    /// call `gtk_cell_layout_clear()` yourself if you need to set up different
    /// cell renderers for the new model.
    @inlinable func set<TreeModelT: TreeModelProtocol>(model: TreeModelT?) {
        gtk_combo_box_set_model(combo_box_ptr, model?.tree_model_ptr)
    
    }

    /// Specifies whether the popup’s width should be a fixed width
    /// matching the allocated width of the combo box.
    @inlinable func setPopupFixedWidth(fixed: Bool) {
        gtk_combo_box_set_popup_fixed_width(combo_box_ptr, gboolean((fixed) ? 1 : 0))
    
    }

    /// Sets the row separator function, which is used to determine
    /// whether a row should be drawn as a separator. If the row separator
    /// function is `nil`, no separators are drawn. This is the default value.
    @inlinable func setRowSeparatorFunc(`func`: GtkTreeViewRowSeparatorFunc? = nil, data: gpointer! = nil, destroy: GDestroyNotify? = nil) {
        gtk_combo_box_set_row_separator_func(combo_box_ptr, `func`, data, destroy)
    
    }
    /// The item which is currently active. If the model is a non-flat treemodel,
    /// and the active item is not an immediate child of the root of the tree,
    /// this property has the value
    /// `gtk_tree_path_get_indices (path)[0]`,
    /// where `path` is the `GtkTreePath` of the active item.
    @inlinable var active: Int {
        /// Returns the index of the currently active item, or -1 if there’s no
        /// active item. If the model is a non-flat treemodel, and the active item
        /// is not an immediate child of the root of the tree, this function returns
        /// `gtk_tree_path_get_indices (path)[0]`, where
        /// `path` is the `GtkTreePath` of the active item.
        get {
            let rv = Int(gtk_combo_box_get_active(combo_box_ptr))
            return rv
        }
        /// Sets the active item of `combo_box` to be the item at `index`.
        nonmutating set {
            gtk_combo_box_set_active(combo_box_ptr, gint(newValue))
        }
    }

    /// Returns the ID of the active row of `combo_box`.  This value is taken
    /// from the active row and the column specified by the `GtkComboBox:id`-column
    /// property of `combo_box` (see `gtk_combo_box_set_id_column()`).
    /// 
    /// The returned value is an interned string which means that you can
    /// compare the pointer by value to other interned strings and that you
    /// must not free it.
    /// 
    /// If the `GtkComboBox:id`-column property of `combo_box` is not set, or if
    /// no row is active, or if the active row has a `nil` ID value, then `nil`
    /// is returned.
    @inlinable var activeId: String! {
        /// Returns the ID of the active row of `combo_box`.  This value is taken
        /// from the active row and the column specified by the `GtkComboBox:id`-column
        /// property of `combo_box` (see `gtk_combo_box_set_id_column()`).
        /// 
        /// The returned value is an interned string which means that you can
        /// compare the pointer by value to other interned strings and that you
        /// must not free it.
        /// 
        /// If the `GtkComboBox:id`-column property of `combo_box` is not set, or if
        /// no row is active, or if the active row has a `nil` ID value, then `nil`
        /// is returned.
        get {
            let rv = gtk_combo_box_get_active_id(combo_box_ptr).map({ String(cString: $0) })
            return rv
        }
        /// Changes the active row of `combo_box` to the one that has an ID equal to
        /// `active_id`, or unsets the active row if `active_id` is `nil`.  Rows having
        /// a `nil` ID string cannot be made active by this function.
        /// 
        /// If the `GtkComboBox:id`-column property of `combo_box` is unset or if no
        /// row has the given ID then the function does nothing and returns `false`.
        nonmutating set {
            _ = gtk_combo_box_set_active_id(combo_box_ptr, newValue)
        }
    }

    /// Returns whether the combo box sets the dropdown button
    /// sensitive or not when there are no items in the model.
    @inlinable var buttonSensitivity: GtkSensitivityType {
        /// Returns whether the combo box sets the dropdown button
        /// sensitive or not when there are no items in the model.
        get {
            let rv = gtk_combo_box_get_button_sensitivity(combo_box_ptr)
            return rv
        }
        /// Sets whether the dropdown button of the combo box should be
        /// always sensitive (`GTK_SENSITIVITY_ON`), never sensitive (`GTK_SENSITIVITY_OFF`)
        /// or only if there is at least one item to display (`GTK_SENSITIVITY_AUTO`).
        nonmutating set {
            gtk_combo_box_set_button_sensitivity(combo_box_ptr, newValue)
        }
    }

    @inlinable var child: WidgetRef! {
        /// Gets the child widget of `combo_box`.
        get {
            guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_combo_box_get_child(combo_box_ptr))) else { return nil }
            return rv
        }
        /// Sets the child widget of `combo_box`.
        nonmutating set {
            gtk_combo_box_set_child(combo_box_ptr, UnsafeMutablePointer<GtkWidget>(newValue?.widget_ptr))
        }
    }

    /// Returns the column which `combo_box` is using to get the strings
    /// from to display in the internal entry.
    @inlinable var entryTextColumn: Int {
        /// Returns the column which `combo_box` is using to get the strings
        /// from to display in the internal entry.
        get {
            let rv = Int(gtk_combo_box_get_entry_text_column(combo_box_ptr))
            return rv
        }
        /// Sets the model column which `combo_box` should use to get strings from
        /// to be `text_column`. The column `text_column` in the model of `combo_box`
        /// must be of type `G_TYPE_STRING`.
        /// 
        /// This is only relevant if `combo_box` has been created with
        /// `GtkComboBox:has`-entry as `true`.
        nonmutating set {
            gtk_combo_box_set_entry_text_column(combo_box_ptr, gint(newValue))
        }
    }

    /// Returns whether the combo box has an entry.
    @inlinable var hasEntry: Bool {
        /// Returns whether the combo box has an entry.
        get {
            let rv = ((gtk_combo_box_get_has_entry(combo_box_ptr)) != 0)
            return rv
        }
    }

    /// Returns the column which `combo_box` is using to get string IDs
    /// for values from.
    @inlinable var idColumn: Int {
        /// Returns the column which `combo_box` is using to get string IDs
        /// for values from.
        get {
            let rv = Int(gtk_combo_box_get_id_column(combo_box_ptr))
            return rv
        }
        /// Sets the model column which `combo_box` should use to get string IDs
        /// for values from. The column `id_column` in the model of `combo_box`
        /// must be of type `G_TYPE_STRING`.
        nonmutating set {
            gtk_combo_box_set_id_column(combo_box_ptr, gint(newValue))
        }
    }

    /// The model from which the combo box takes the values shown
    /// in the list.
    @inlinable var model: TreeModelRef! {
        /// Returns the `GtkTreeModel` which is acting as data source for `combo_box`.
        get {
            let rv = TreeModelRef(gconstpointer: gconstpointer(gtk_combo_box_get_model(combo_box_ptr)))
            return rv
        }
        /// Sets the model used by `combo_box` to be `model`. Will unset a previously set
        /// model (if applicable). If model is `nil`, then it will unset the model.
        /// 
        /// Note that this function does not clear the cell renderers, you have to
        /// call `gtk_cell_layout_clear()` yourself if you need to set up different
        /// cell renderers for the new model.
        nonmutating set {
            gtk_combo_box_set_model(combo_box_ptr, UnsafeMutablePointer<GtkTreeModel>(newValue?.tree_model_ptr))
        }
    }

    /// Gets whether the popup uses a fixed width matching
    /// the allocated width of the combo box.
    @inlinable var popupFixedWidth: Bool {
        /// Gets whether the popup uses a fixed width matching
        /// the allocated width of the combo box.
        get {
            let rv = ((gtk_combo_box_get_popup_fixed_width(combo_box_ptr)) != 0)
            return rv
        }
        /// Specifies whether the popup’s width should be a fixed width
        /// matching the allocated width of the combo box.
        nonmutating set {
            gtk_combo_box_set_popup_fixed_width(combo_box_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns the current row separator function.
    @inlinable var rowSeparatorFunc: GtkTreeViewRowSeparatorFunc! {
        /// Returns the current row separator function.
        get {
            let rv = gtk_combo_box_get_row_separator_func(combo_box_ptr)
            return rv
        }
    }

    @inlinable var parentInstance: GtkWidget {
        get {
            let rv = combo_box_ptr.pointee.parent_instance
            return rv
        }
    }

}



// MARK: - ComboBoxText Class

/// The `ComboBoxTextProtocol` protocol exposes the methods and properties of an underlying `GtkComboBoxText` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ComboBoxText`.
/// Alternatively, use `ComboBoxTextRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A GtkComboBoxText is a simple variant of `GtkComboBox` that hides
/// the model-view complexity for simple text-only use cases.
/// 
/// To create a GtkComboBoxText, use `gtk_combo_box_text_new()` or
/// `gtk_combo_box_text_new_with_entry()`.
/// 
/// You can add items to a GtkComboBoxText with
/// `gtk_combo_box_text_append_text()`, `gtk_combo_box_text_insert_text()`
/// or `gtk_combo_box_text_prepend_text()` and remove options with
/// `gtk_combo_box_text_remove()`.
/// 
/// If the GtkComboBoxText contains an entry (via the “has-entry” property),
/// its contents can be retrieved using `gtk_combo_box_text_get_active_text()`.
/// The entry itself can be accessed by calling `gtk_bin_get_child()` on the
/// combo box.
/// 
/// You should not call `gtk_combo_box_set_model()` or attempt to pack more cells
/// into this combo box via its GtkCellLayout interface.
/// 
/// # GtkComboBoxText as GtkBuildable
/// 
/// The GtkComboBoxText implementation of the GtkBuildable interface supports
/// adding items directly using the <items> element and specifying <item>
/// elements for each item. Each <item> element can specify the “id”
/// corresponding to the appended text and also supports the regular
/// translation attributes “translatable”, “context” and “comments”.
/// 
/// Here is a UI definition fragment specifying GtkComboBoxText items:
/// ```
/// <object class="GtkComboBoxText">
///   <items>
///     <item translatable="yes" id="factory">Factory</item>
///     <item translatable="yes" id="home">Home</item>
///     <item translatable="yes" id="subway">Subway</item>
///   </items>
/// </object>
/// ```
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// combobox
/// ╰── box.linked
///     ├── entry.combo
///     ├── button.combo
///     ╰── window.popup
/// ```
/// 
/// GtkComboBoxText has a single CSS node with name combobox. It adds
/// the style class .combo to the main CSS nodes of its entry and button
/// children, and the .linked class to the node of its internal box.
public protocol ComboBoxTextProtocol: ComboBoxProtocol {
        /// Untyped pointer to the underlying `GtkComboBoxText` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkComboBoxText` instance.
    var combo_box_text_ptr: UnsafeMutablePointer<GtkComboBoxText>! { get }

}

/// The `ComboBoxTextRef` type acts as a lightweight Swift reference to an underlying `GtkComboBoxText` instance.
/// It exposes methods that can operate on this data type through `ComboBoxTextProtocol` conformance.
/// Use `ComboBoxTextRef` only as an `unowned` reference to an existing `GtkComboBoxText` instance.
///
/// A GtkComboBoxText is a simple variant of `GtkComboBox` that hides
/// the model-view complexity for simple text-only use cases.
/// 
/// To create a GtkComboBoxText, use `gtk_combo_box_text_new()` or
/// `gtk_combo_box_text_new_with_entry()`.
/// 
/// You can add items to a GtkComboBoxText with
/// `gtk_combo_box_text_append_text()`, `gtk_combo_box_text_insert_text()`
/// or `gtk_combo_box_text_prepend_text()` and remove options with
/// `gtk_combo_box_text_remove()`.
/// 
/// If the GtkComboBoxText contains an entry (via the “has-entry” property),
/// its contents can be retrieved using `gtk_combo_box_text_get_active_text()`.
/// The entry itself can be accessed by calling `gtk_bin_get_child()` on the
/// combo box.
/// 
/// You should not call `gtk_combo_box_set_model()` or attempt to pack more cells
/// into this combo box via its GtkCellLayout interface.
/// 
/// # GtkComboBoxText as GtkBuildable
/// 
/// The GtkComboBoxText implementation of the GtkBuildable interface supports
/// adding items directly using the <items> element and specifying <item>
/// elements for each item. Each <item> element can specify the “id”
/// corresponding to the appended text and also supports the regular
/// translation attributes “translatable”, “context” and “comments”.
/// 
/// Here is a UI definition fragment specifying GtkComboBoxText items:
/// ```
/// <object class="GtkComboBoxText">
///   <items>
///     <item translatable="yes" id="factory">Factory</item>
///     <item translatable="yes" id="home">Home</item>
///     <item translatable="yes" id="subway">Subway</item>
///   </items>
/// </object>
/// ```
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// combobox
/// ╰── box.linked
///     ├── entry.combo
///     ├── button.combo
///     ╰── window.popup
/// ```
/// 
/// GtkComboBoxText has a single CSS node with name combobox. It adds
/// the style class .combo to the main CSS nodes of its entry and button
/// children, and the .linked class to the node of its internal box.
public struct ComboBoxTextRef: ComboBoxTextProtocol {
        /// Untyped pointer to the underlying `GtkComboBoxText` instance.
    /// For type-safe access, use the generated, typed pointer `combo_box_text_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ComboBoxTextRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkComboBoxText>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkComboBoxText>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkComboBoxText>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkComboBoxText>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ComboBoxTextProtocol`
    @inlinable init<T: ComboBoxTextProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkComboBoxText`, which is a `GtkComboBox` just displaying
    /// strings.
    @inlinable init() {
        let rv = gtk_combo_box_text_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
    /// Creates a new `GtkComboBoxText`, which is a `GtkComboBox` just displaying
    /// strings. The combo box created by this function has an entry.
    @inlinable static func comboBoxTextNewWithEntry() -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_combo_box_text_new_with_entry())) else { return nil }
        return rv
    }
}

/// The `ComboBoxText` type acts as a reference-counted owner of an underlying `GtkComboBoxText` instance.
/// It provides the methods that can operate on this data type through `ComboBoxTextProtocol` conformance.
/// Use `ComboBoxText` as a strong reference or owner of a `GtkComboBoxText` instance.
///
/// A GtkComboBoxText is a simple variant of `GtkComboBox` that hides
/// the model-view complexity for simple text-only use cases.
/// 
/// To create a GtkComboBoxText, use `gtk_combo_box_text_new()` or
/// `gtk_combo_box_text_new_with_entry()`.
/// 
/// You can add items to a GtkComboBoxText with
/// `gtk_combo_box_text_append_text()`, `gtk_combo_box_text_insert_text()`
/// or `gtk_combo_box_text_prepend_text()` and remove options with
/// `gtk_combo_box_text_remove()`.
/// 
/// If the GtkComboBoxText contains an entry (via the “has-entry” property),
/// its contents can be retrieved using `gtk_combo_box_text_get_active_text()`.
/// The entry itself can be accessed by calling `gtk_bin_get_child()` on the
/// combo box.
/// 
/// You should not call `gtk_combo_box_set_model()` or attempt to pack more cells
/// into this combo box via its GtkCellLayout interface.
/// 
/// # GtkComboBoxText as GtkBuildable
/// 
/// The GtkComboBoxText implementation of the GtkBuildable interface supports
/// adding items directly using the <items> element and specifying <item>
/// elements for each item. Each <item> element can specify the “id”
/// corresponding to the appended text and also supports the regular
/// translation attributes “translatable”, “context” and “comments”.
/// 
/// Here is a UI definition fragment specifying GtkComboBoxText items:
/// ```
/// <object class="GtkComboBoxText">
///   <items>
///     <item translatable="yes" id="factory">Factory</item>
///     <item translatable="yes" id="home">Home</item>
///     <item translatable="yes" id="subway">Subway</item>
///   </items>
/// </object>
/// ```
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// combobox
/// ╰── box.linked
///     ├── entry.combo
///     ├── button.combo
///     ╰── window.popup
/// ```
/// 
/// GtkComboBoxText has a single CSS node with name combobox. It adds
/// the style class .combo to the main CSS nodes of its entry and button
/// children, and the .linked class to the node of its internal box.
open class ComboBoxText: ComboBox, ComboBoxTextProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ComboBoxText` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkComboBoxText>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ComboBoxText` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkComboBoxText>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ComboBoxText` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ComboBoxText` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ComboBoxText` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkComboBoxText>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ComboBoxText` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkComboBoxText>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkComboBoxText`.
    /// i.e., ownership is transferred to the `ComboBoxText` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkComboBoxText>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ComboBoxTextProtocol`
    /// Will retain `GtkComboBoxText`.
    /// - Parameter other: an instance of a related type that implements `ComboBoxTextProtocol`
    @inlinable public init<T: ComboBoxTextProtocol>(comboBoxText other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkComboBoxText`, which is a `GtkComboBox` just displaying
    /// strings.
    @inlinable override public init() {
        let rv = gtk_combo_box_text_new()
        super.init(gpointer: gpointer(rv))
    }

    /// Creates a new `GtkComboBoxText`, which is a `GtkComboBox` just displaying
    /// strings. The combo box created by this function has an entry.
    @inlinable public static func comboBoxTextNewWithEntry() -> Widget! {
        guard let rv = Widget(gconstpointer: gconstpointer(gtk_combo_box_text_new_with_entry())) else { return nil }
        return rv
    }

}

public enum ComboBoxTextPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    /// The item which is currently active. If the model is a non-flat treemodel,
    /// and the active item is not an immediate child of the root of the tree,
    /// this property has the value
    /// `gtk_tree_path_get_indices (path)[0]`,
    /// where `path` is the `GtkTreePath` of the active item.
    case active = "active"
    /// The value of the ID column of the active row.
    case activeId = "active-id"
    /// Whether the dropdown button is sensitive when
    /// the model is empty.
    case buttonSensitivity = "button-sensitivity"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    case canTarget = "can-target"
    case child = "child"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`. See `gtk_widget_set_cursor()` for details.
    case cursor = "cursor"
    /// The column in the combo box's model to associate with strings from the entry
    /// if the combo was created with `GtkComboBox:has`-entry = `true`.
    case entryTextColumn = "entry-text-column"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    /// Whether the combo box has an entry.
    case hasEntry = "has-entry"
    case hasFocus = "has-focus"
    /// The has-frame property controls whether a frame
    /// is drawn around the entry.
    case hasFrame = "has-frame"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    /// The column in the combo box's model that provides string
    /// IDs for the values in the model, if != -1.
    case idColumn = "id-column"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    /// The model from which the combo box takes the values shown
    /// in the list.
    case model = "model"
    case name = "name"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    case parent = "parent"
    /// Whether the popup's width should be a fixed width matching the
    /// allocated width of the combo box.
    case popupFixedWidth = "popup-fixed-width"
    /// Whether the combo boxes dropdown is popped up.
    /// Note that this property is mainly useful, because
    /// it allows you to connect to notify`popup`-shown.
    case popupShown = "popup-shown"
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget or `nil` if
    /// the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
}

public extension ComboBoxTextProtocol {
    /// Bind a `ComboBoxTextPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ComboBoxTextPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ComboBoxText property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ComboBoxTextPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ComboBoxText property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ComboBoxTextPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ComboBoxTextSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The changed signal is emitted when the active
    /// item is changed. The can be due to the user selecting
    /// a different item from the list, or due to a
    /// call to `gtk_combo_box_set_active_iter()`.
    /// It will also be emitted while typing into the entry of a combo box
    /// with an entry.
    case changed = "changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold. May result in finalization of the widget
    /// if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// The `direction`-changed signal is emitted when the text direction
    /// of a widget changes.
    case directionChanged = "direction-changed"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// For combo boxes that are created with an entry (See GtkComboBox:has-entry).
    /// 
    /// A signal which allows you to change how the text displayed in a combo box's
    /// entry is displayed.
    /// 
    /// Connect a signal handler which returns an allocated string representing
    /// `path`. That string will then be used to set the text in the combo box's entry.
    /// The default signal handler uses the text from the GtkComboBox`entry`-text-column
    /// model column.
    /// 
    /// Here's an example signal handler which fetches data from the model and
    /// displays it in the entry.
    /// (C Language Example):
    /// ```C
    /// static char *
    /// format_entry_text_callback (GtkComboBox *combo,
    ///                             const char *path,
    ///                             gpointer     user_data)
    /// {
    ///   GtkTreeIter iter;
    ///   GtkTreeModel model;
    ///   double       value;
    /// 
    ///   model = gtk_combo_box_get_model (combo);
    /// 
    ///   gtk_tree_model_get_iter_from_string (model, &iter, path);
    ///   gtk_tree_model_get (model, &iter,
    ///                       THE_DOUBLE_VALUE_COLUMN, &value,
    ///                       -1);
    /// 
    ///   return g_strdup_printf ("%g", value);
    /// }
    /// ```
    /// 
    case formatEntryText = "format-entry-text"
    /// The `hide` signal is emitted when `widget` is hidden, for example with
    /// `gtk_widget_hide()`.
    case hide = "hide"
    /// Gets emitted if keyboard navigation fails.
    /// See `gtk_widget_keynav_failed()` for details.
    case keynavFailed = "keynav-failed"
    /// The `map` signal is emitted when `widget` is going to be mapped, that is
    /// when the widget is visible (which is controlled with
    /// `gtk_widget_set_visible()`) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of `GtkWidget::unmap`.
    case map = "map"
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// The `move`-active signal is a
    /// [keybinding signal](#GtkSignalAction)
    /// which gets emitted to move the active selection.
    case moveActive = "move-active"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The `popdown` signal is a
    /// [keybinding signal](#GtkSignalAction)
    /// which gets emitted to popdown the combo box list.
    /// 
    /// The default bindings for this signal are Alt+Up and Escape.
    case popdown = "popdown"
    /// The `popup` signal is a
    /// [keybinding signal](#GtkSignalAction)
    /// which gets emitted to popup the combo box list.
    /// 
    /// The default binding for this signal is Alt+Down.
    case popup = "popup"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// Emitted when `GtkWidget:has`-tooltip is `true` and the hover timeout
    /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
    /// focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// The `realize` signal is emitted when `widget` is associated with a
    /// `GdkSurface`, which means that `gtk_widget_realize()` has been called or the
    /// widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// The `show` signal is emitted when `widget` is shown, for example with
    /// `gtk_widget_show()`.
    case show = "show"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The `state`-flags-changed signal is emitted when the widget state
    /// changes, see `gtk_widget_get_state_flags()`.
    case stateFlagsChanged = "state-flags-changed"
    /// The `unmap` signal is emitted when `widget` is going to be unmapped, which
    /// means that either it or any of its parents up to the toplevel widget have
    /// been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer, it can be
    /// used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// The `unrealize` signal is emitted when the `GdkSurface` associated with
    /// `widget` is destroyed, which means that `gtk_widget_unrealize()` has been
    /// called or the widget has been unmapped (that is, it is going to be
    /// hidden).
    case unrealize = "unrealize"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    /// The item which is currently active. If the model is a non-flat treemodel,
    /// and the active item is not an immediate child of the root of the tree,
    /// this property has the value
    /// `gtk_tree_path_get_indices (path)[0]`,
    /// where `path` is the `GtkTreePath` of the active item.
    case notifyActive = "notify::active"
    /// The value of the ID column of the active row.
    case notifyActiveId = "notify::active-id"
    /// Whether the dropdown button is sensitive when
    /// the model is empty.
    case notifyButtonSensitivity = "notify::button-sensitivity"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    case notifyCanTarget = "notify::can-target"
    case notifyChild = "notify::child"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`. See `gtk_widget_set_cursor()` for details.
    case notifyCursor = "notify::cursor"
    /// The column in the combo box's model to associate with strings from the entry
    /// if the combo was created with `GtkComboBox:has`-entry = `true`.
    case notifyEntryTextColumn = "notify::entry-text-column"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case notifyHalign = "notify::halign"
    case notifyHasDefault = "notify::has-default"
    /// Whether the combo box has an entry.
    case notifyHasEntry = "notify::has-entry"
    case notifyHasFocus = "notify::has-focus"
    /// The has-frame property controls whether a frame
    /// is drawn around the entry.
    case notifyHasFrame = "notify::has-frame"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The column in the combo box's model that provides string
    /// IDs for the values in the model, if != -1.
    case notifyIdColumn = "notify::id-column"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginTop = "notify::margin-top"
    /// The model from which the combo box takes the values shown
    /// in the list.
    case notifyModel = "notify::model"
    case notifyName = "notify::name"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    case notifyParent = "notify::parent"
    /// Whether the popup's width should be a fixed width matching the
    /// allocated width of the combo box.
    case notifyPopupFixedWidth = "notify::popup-fixed-width"
    /// Whether the combo boxes dropdown is popped up.
    /// Note that this property is mainly useful, because
    /// it allows you to connect to notify`popup`-shown.
    case notifyPopupShown = "notify::popup-shown"
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget or `nil` if
    /// the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case notifyScaleFactor = "notify::scale-factor"
    case notifySensitive = "notify::sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case notifyValign = "notify::valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case notifyVexpandSet = "notify::vexpand-set"
    case notifyVisible = "notify::visible"
    case notifyWidthRequest = "notify::width-request"
}

public extension ComboBoxTextProtocol {
    /// Connect a `ComboBoxTextSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @inlinable @discardableResult func connect(signal kind: ComboBoxTextSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> Int {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> Int {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(raw: ptr).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

// MARK: ComboBoxText Class: ComboBoxTextProtocol extension (methods and fields)
public extension ComboBoxTextProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkComboBoxText` instance.
    @inlinable var combo_box_text_ptr: UnsafeMutablePointer<GtkComboBoxText>! { return ptr?.assumingMemoryBound(to: GtkComboBoxText.self) }

    /// Appends `text` to the list of strings stored in `combo_box`.
    /// If `id` is non-`nil` then it is used as the ID of the row.
    /// 
    /// This is the same as calling `gtk_combo_box_text_insert()` with a
    /// position of -1.
    @inlinable func append(id: UnsafePointer<CChar>? = nil, text: UnsafePointer<CChar>!) {
        gtk_combo_box_text_append(combo_box_text_ptr, id, text)
    
    }

    /// Appends `text` to the list of strings stored in `combo_box`.
    /// 
    /// This is the same as calling `gtk_combo_box_text_insert_text()` with a
    /// position of -1.
    @inlinable func append(text: UnsafePointer<CChar>!) {
        gtk_combo_box_text_append_text(combo_box_text_ptr, text)
    
    }

    /// Returns the currently active string in `combo_box`, or `nil`
    /// if none is selected. If `combo_box` contains an entry, this
    /// function will return its contents (which will not necessarily
    /// be an item from the list).
    @inlinable func getActiveText() -> String! {
        let rv = gtk_combo_box_text_get_active_text(combo_box_text_ptr).map({ String(cString: $0) })
        return rv
    }

    /// Inserts `text` at `position` in the list of strings stored in `combo_box`.
    /// If `id` is non-`nil` then it is used as the ID of the row.  See
    /// `GtkComboBox:id`-column.
    /// 
    /// If `position` is negative then `text` is appended.
    @inlinable func insert(position: Int, id: UnsafePointer<CChar>? = nil, text: UnsafePointer<CChar>!) {
        gtk_combo_box_text_insert(combo_box_text_ptr, gint(position), id, text)
    
    }

    /// Inserts `text` at `position` in the list of strings stored in `combo_box`.
    /// 
    /// If `position` is negative then `text` is appended.
    /// 
    /// This is the same as calling `gtk_combo_box_text_insert()` with a `nil`
    /// ID string.
    @inlinable func insertText(position: Int, text: UnsafePointer<CChar>!) {
        gtk_combo_box_text_insert_text(combo_box_text_ptr, gint(position), text)
    
    }

    /// Prepends `text` to the list of strings stored in `combo_box`.
    /// If `id` is non-`nil` then it is used as the ID of the row.
    /// 
    /// This is the same as calling `gtk_combo_box_text_insert()` with a
    /// position of 0.
    @inlinable func prepend(id: UnsafePointer<CChar>? = nil, text: UnsafePointer<CChar>!) {
        gtk_combo_box_text_prepend(combo_box_text_ptr, id, text)
    
    }

    /// Prepends `text` to the list of strings stored in `combo_box`.
    /// 
    /// This is the same as calling `gtk_combo_box_text_insert_text()` with a
    /// position of 0.
    @inlinable func prepend(text: UnsafePointer<CChar>!) {
        gtk_combo_box_text_prepend_text(combo_box_text_ptr, text)
    
    }

    /// Removes the string at `position` from `combo_box`.
    @inlinable func remove(position: Int) {
        gtk_combo_box_text_remove(combo_box_text_ptr, gint(position))
    
    }

    /// Removes all the text entries from the combo box.
    @inlinable func removeAll() {
        gtk_combo_box_text_remove_all(combo_box_text_ptr)
    
    }
    /// Returns the currently active string in `combo_box`, or `nil`
    /// if none is selected. If `combo_box` contains an entry, this
    /// function will return its contents (which will not necessarily
    /// be an item from the list).
    @inlinable var activeText: String! {
        /// Returns the currently active string in `combo_box`, or `nil`
        /// if none is selected. If `combo_box` contains an entry, this
        /// function will return its contents (which will not necessarily
        /// be an item from the list).
        get {
            let rv = gtk_combo_box_text_get_active_text(combo_box_text_ptr).map({ String(cString: $0) })
            return rv
        }
    }


}



// MARK: - ConstantExpression Class

/// The `ConstantExpressionProtocol` protocol exposes the methods and properties of an underlying `GtkConstantExpression` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ConstantExpression`.
/// Alternatively, use `ConstantExpressionRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///

public protocol ConstantExpressionProtocol: ExpressionProtocol {
        /// Untyped pointer to the underlying `GtkConstantExpression` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkConstantExpression` instance.
    var constant_expression_ptr: UnsafeMutablePointer<GtkConstantExpression>! { get }

}

/// The `ConstantExpressionRef` type acts as a lightweight Swift reference to an underlying `GtkConstantExpression` instance.
/// It exposes methods that can operate on this data type through `ConstantExpressionProtocol` conformance.
/// Use `ConstantExpressionRef` only as an `unowned` reference to an existing `GtkConstantExpression` instance.
///

public struct ConstantExpressionRef: ConstantExpressionProtocol {
        /// Untyped pointer to the underlying `GtkConstantExpression` instance.
    /// For type-safe access, use the generated, typed pointer `constant_expression_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ConstantExpressionRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkConstantExpression>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkConstantExpression>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkConstantExpression>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkConstantExpression>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ConstantExpressionProtocol`
    @inlinable init<T: ConstantExpressionProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstantExpressionProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstantExpressionProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstantExpressionProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstantExpressionProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstantExpressionProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    
    // *** new() is not available because it has a varargs (...) parameter!


    /// Creates an expression that always evaluates to the given `value`.
    @inlinable init<ValueT: GLibObject.ValueProtocol>(value: ValueT) {
        let rv = gtk_constant_expression_new_for_value(value.value_ptr)
        ptr = UnsafeMutableRawPointer(rv)
    }
    /// Creates an expression that always evaluates to the given `value`.
    @inlinable static func newFor<ValueT: GLibObject.ValueProtocol>(value: ValueT) -> ExpressionRef! {
        guard let rv = ExpressionRef(gconstpointer: gconstpointer(gtk_constant_expression_new_for_value(value.value_ptr))) else { return nil }
        return rv
    }
}

/// The `ConstantExpression` type acts as a reference-counted owner of an underlying `GtkConstantExpression` instance.
/// It provides the methods that can operate on this data type through `ConstantExpressionProtocol` conformance.
/// Use `ConstantExpression` as a strong reference or owner of a `GtkConstantExpression` instance.
///

open class ConstantExpression: Expression, ConstantExpressionProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstantExpression` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkConstantExpression>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstantExpression` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkConstantExpression>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstantExpression` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstantExpression` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstantExpression` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkConstantExpression>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstantExpression` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkConstantExpression>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkConstantExpression`.
    /// i.e., ownership is transferred to the `ConstantExpression` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkConstantExpression>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ConstantExpressionProtocol`
    /// Will retain `GtkConstantExpression`.
    /// - Parameter other: an instance of a related type that implements `ConstantExpressionProtocol`
    @inlinable public init<T: ConstantExpressionProtocol>(constantExpression other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstantExpressionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstantExpressionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstantExpressionProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstantExpressionProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstantExpressionProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstantExpressionProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstantExpressionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstantExpressionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }


    // *** new() is not available because it has a varargs (...) parameter!


    /// Creates an expression that always evaluates to the given `value`.
    @inlinable public init<ValueT: GLibObject.ValueProtocol>(value: ValueT) {
        let rv = gtk_constant_expression_new_for_value(value.value_ptr)
        super.init(gpointer: gpointer(rv))
    }

    /// Creates an expression that always evaluates to the given `value`.
    @inlinable public static func newFor<ValueT: GLibObject.ValueProtocol>(value: ValueT) -> Expression! {
        guard let rv = Expression(gconstpointer: gconstpointer(gtk_constant_expression_new_for_value(value.value_ptr))) else { return nil }
        return rv
    }

}

// MARK: no ConstantExpression properties

// MARK: no ConstantExpression signals


// MARK: ConstantExpression Class: ConstantExpressionProtocol extension (methods and fields)
public extension ConstantExpressionProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkConstantExpression` instance.
    @inlinable var constant_expression_ptr: UnsafeMutablePointer<GtkConstantExpression>! { return ptr?.assumingMemoryBound(to: GtkConstantExpression.self) }

    /// Gets the value that a constant expression evaluates to.
    @inlinable func getValue() -> GLibObject.ValueRef! {
        let rv = GLibObject.ValueRef(gtk_constant_expression_get_value(expression_ptr))
        return rv
    }
    /// Gets the value that a constant expression evaluates to.
    @inlinable var value: GLibObject.ValueRef! {
        /// Gets the value that a constant expression evaluates to.
        get {
            let rv = GLibObject.ValueRef(gtk_constant_expression_get_value(expression_ptr))
            return rv
        }
    }


}



// MARK: - Constraint Class

/// The `ConstraintProtocol` protocol exposes the methods and properties of an underlying `GtkConstraint` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `Constraint`.
/// Alternatively, use `ConstraintRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkConstraint` describes a constraint between an attribute on a widget
/// and another attribute on another widget, expressed as a linear equation
/// like:
/// 
/// ```
///   target.attr1 = source.attr2 × multiplier + constant
/// ```
/// 
/// Each `GtkConstraint` is part of a system that will be solved by a
/// `GtkConstraintLayout` in order to allocate and position each child widget.
/// 
/// The source and target widgets, as well as their attributes, of a
/// `GtkConstraint` instance are immutable after creation.
public protocol ConstraintProtocol: GLibObject.ObjectProtocol {
        /// Untyped pointer to the underlying `GtkConstraint` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkConstraint` instance.
    var constraint_ptr: UnsafeMutablePointer<GtkConstraint>! { get }

}

/// The `ConstraintRef` type acts as a lightweight Swift reference to an underlying `GtkConstraint` instance.
/// It exposes methods that can operate on this data type through `ConstraintProtocol` conformance.
/// Use `ConstraintRef` only as an `unowned` reference to an existing `GtkConstraint` instance.
///
/// `GtkConstraint` describes a constraint between an attribute on a widget
/// and another attribute on another widget, expressed as a linear equation
/// like:
/// 
/// ```
///   target.attr1 = source.attr2 × multiplier + constant
/// ```
/// 
/// Each `GtkConstraint` is part of a system that will be solved by a
/// `GtkConstraintLayout` in order to allocate and position each child widget.
/// 
/// The source and target widgets, as well as their attributes, of a
/// `GtkConstraint` instance are immutable after creation.
public struct ConstraintRef: ConstraintProtocol {
        /// Untyped pointer to the underlying `GtkConstraint` instance.
    /// For type-safe access, use the generated, typed pointer `constraint_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ConstraintRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkConstraint>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkConstraint>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkConstraint>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkConstraint>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ConstraintProtocol`
    @inlinable init<T: ConstraintProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkConstraint` representing a relation between a layout
    /// attribute on a source and a layout attribute on a target.
    @inlinable init<ConstraintTargetT: ConstraintTargetProtocol>( target: ConstraintTargetT?, targetAttribute: GtkConstraintAttribute, relation: GtkConstraintRelation, source: ConstraintTargetT?, sourceAttribute: GtkConstraintAttribute, multiplier: CDouble, constant: CDouble, strength: Int) {
        let rv = gtk_constraint_new(target?.constraint_target_ptr, targetAttribute, relation, source?.constraint_target_ptr, sourceAttribute, multiplier, constant, gint(strength))
        ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GtkConstraint` representing a relation between a layout
    /// attribute on a target and a constant value.
    @inlinable init<ConstraintTargetT: ConstraintTargetProtocol>(constant target: ConstraintTargetT?, targetAttribute: GtkConstraintAttribute, relation: GtkConstraintRelation, constant: CDouble, strength: Int) {
        let rv = gtk_constraint_new_constant(target?.constraint_target_ptr, targetAttribute, relation, constant, gint(strength))
        ptr = UnsafeMutableRawPointer(rv)
    }
    /// Creates a new `GtkConstraint` representing a relation between a layout
    /// attribute on a target and a constant value.
    @inlinable static func new<ConstraintTargetT: ConstraintTargetProtocol>(constant target: ConstraintTargetT?, targetAttribute: GtkConstraintAttribute, relation: GtkConstraintRelation, constant: CDouble, strength: Int) -> ConstraintRef! {
        guard let rv = ConstraintRef(gconstpointer: gconstpointer(gtk_constraint_new_constant(target?.constraint_target_ptr, targetAttribute, relation, constant, gint(strength)))) else { return nil }
        return rv
    }
}

/// The `Constraint` type acts as a reference-counted owner of an underlying `GtkConstraint` instance.
/// It provides the methods that can operate on this data type through `ConstraintProtocol` conformance.
/// Use `Constraint` as a strong reference or owner of a `GtkConstraint` instance.
///
/// `GtkConstraint` describes a constraint between an attribute on a widget
/// and another attribute on another widget, expressed as a linear equation
/// like:
/// 
/// ```
///   target.attr1 = source.attr2 × multiplier + constant
/// ```
/// 
/// Each `GtkConstraint` is part of a system that will be solved by a
/// `GtkConstraintLayout` in order to allocate and position each child widget.
/// 
/// The source and target widgets, as well as their attributes, of a
/// `GtkConstraint` instance are immutable after creation.
open class Constraint: GLibObject.Object, ConstraintProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Constraint` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkConstraint>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Constraint` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkConstraint>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Constraint` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Constraint` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Constraint` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkConstraint>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Constraint` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkConstraint>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkConstraint`.
    /// i.e., ownership is transferred to the `Constraint` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkConstraint>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ConstraintProtocol`
    /// Will retain `GtkConstraint`.
    /// - Parameter other: an instance of a related type that implements `ConstraintProtocol`
    @inlinable public init<T: ConstraintProtocol>(constraint other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkConstraint` representing a relation between a layout
    /// attribute on a source and a layout attribute on a target.
    @inlinable public init<ConstraintTargetT: ConstraintTargetProtocol>( target: ConstraintTargetT?, targetAttribute: GtkConstraintAttribute, relation: GtkConstraintRelation, source: ConstraintTargetT?, sourceAttribute: GtkConstraintAttribute, multiplier: CDouble, constant: CDouble, strength: Int) {
        let rv = gtk_constraint_new(target?.constraint_target_ptr, targetAttribute, relation, source?.constraint_target_ptr, sourceAttribute, multiplier, constant, gint(strength))
        super.init(gpointer: gpointer(rv))
    }

    /// Creates a new `GtkConstraint` representing a relation between a layout
    /// attribute on a target and a constant value.
    @inlinable public init<ConstraintTargetT: ConstraintTargetProtocol>(constant target: ConstraintTargetT?, targetAttribute: GtkConstraintAttribute, relation: GtkConstraintRelation, constant: CDouble, strength: Int) {
        let rv = gtk_constraint_new_constant(target?.constraint_target_ptr, targetAttribute, relation, constant, gint(strength))
        super.init(gpointer: gpointer(rv))
    }

    /// Creates a new `GtkConstraint` representing a relation between a layout
    /// attribute on a target and a constant value.
    @inlinable public static func new<ConstraintTargetT: ConstraintTargetProtocol>(constant target: ConstraintTargetT?, targetAttribute: GtkConstraintAttribute, relation: GtkConstraintRelation, constant: CDouble, strength: Int) -> Constraint! {
        guard let rv = Constraint(gconstpointer: gconstpointer(gtk_constraint_new_constant(target?.constraint_target_ptr, targetAttribute, relation, constant, gint(strength)))) else { return nil }
        return rv
    }

}

public enum ConstraintPropertyName: String, PropertyNameProtocol {
    /// The constant value to be added to the `GtkConstraint:source`-attribute.
    case constant = "constant"
    /// The multiplication factor to be applied to the
    /// `GtkConstraint:source`-attribute.
    case multiplier = "multiplier"
    /// The order relation between the terms of the constraint.
    case relation = "relation"
    /// The source of the constraint.
    /// 
    /// The constraint will set the `GtkConstraint:target`-attribute of the
    /// target using the `GtkConstraint:source`-attribute of the source.
    case source = "source"
    /// The attribute of the `GtkConstraint:source` read by the constraint.
    case sourceAttribute = "source-attribute"
    /// The strength of the constraint.
    /// 
    /// The strength can be expressed either using one of the symbolic values
    /// of the `GtkConstraintStrength` enumeration, or any positive integer
    /// value.
    case strength = "strength"
    /// The target of the constraint.
    /// 
    /// The constraint will set the `GtkConstraint:target`-attribute of the
    /// target using the `GtkConstraint:source`-attribute of the source
    /// widget.
    case target = "target"
    /// The attribute of the `GtkConstraint:target` set by the constraint.
    case targetAttribute = "target-attribute"
}

public extension ConstraintProtocol {
    /// Bind a `ConstraintPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ConstraintPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a Constraint property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ConstraintPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a Constraint property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ConstraintPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ConstraintSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The constant value to be added to the `GtkConstraint:source`-attribute.
    case notifyConstant = "notify::constant"
    /// The multiplication factor to be applied to the
    /// `GtkConstraint:source`-attribute.
    case notifyMultiplier = "notify::multiplier"
    /// The order relation between the terms of the constraint.
    case notifyRelation = "notify::relation"
    /// The source of the constraint.
    /// 
    /// The constraint will set the `GtkConstraint:target`-attribute of the
    /// target using the `GtkConstraint:source`-attribute of the source.
    case notifySource = "notify::source"
    /// The attribute of the `GtkConstraint:source` read by the constraint.
    case notifySourceAttribute = "notify::source-attribute"
    /// The strength of the constraint.
    /// 
    /// The strength can be expressed either using one of the symbolic values
    /// of the `GtkConstraintStrength` enumeration, or any positive integer
    /// value.
    case notifyStrength = "notify::strength"
    /// The target of the constraint.
    /// 
    /// The constraint will set the `GtkConstraint:target`-attribute of the
    /// target using the `GtkConstraint:source`-attribute of the source
    /// widget.
    case notifyTarget = "notify::target"
    /// The attribute of the `GtkConstraint:target` set by the constraint.
    case notifyTargetAttribute = "notify::target-attribute"
}

public extension ConstraintProtocol {
    /// Connect a `ConstraintSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @inlinable @discardableResult func connect(signal kind: ConstraintSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> Int {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> Int {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(raw: ptr).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

// MARK: Constraint Class: ConstraintProtocol extension (methods and fields)
public extension ConstraintProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkConstraint` instance.
    @inlinable var constraint_ptr: UnsafeMutablePointer<GtkConstraint>! { return ptr?.assumingMemoryBound(to: GtkConstraint.self) }

    /// Retrieves the constant factor added to the source attributes' value.
    @inlinable func getConstant() -> CDouble {
        let rv = gtk_constraint_get_constant(constraint_ptr)
        return rv
    }

    /// Retrieves the multiplication factor applied to the source
    /// attribute's value.
    @inlinable func getMultiplier() -> CDouble {
        let rv = gtk_constraint_get_multiplier(constraint_ptr)
        return rv
    }

    /// The order relation between the terms of the `constraint`.
    @inlinable func getRelation() -> GtkConstraintRelation {
        let rv = gtk_constraint_get_relation(constraint_ptr)
        return rv
    }

    /// Retrieves the `GtkConstraintTarget` used as the source for `constraint`.
    /// 
    /// If the `GtkConstraint:source` property is set to `nil`, the `constraint`
    /// will use the `GtkConstraintLayout`'s widget.
    @inlinable func getSource() -> ConstraintTargetRef! {
        let rv = ConstraintTargetRef(gconstpointer: gconstpointer(gtk_constraint_get_source(constraint_ptr)))
        return rv
    }

    /// Retrieves the attribute of the source to be read by the `constraint`.
    @inlinable func getSourceAttribute() -> GtkConstraintAttribute {
        let rv = gtk_constraint_get_source_attribute(constraint_ptr)
        return rv
    }

    /// Retrieves the strength of the constraint.
    @inlinable func getStrength() -> Int {
        let rv = Int(gtk_constraint_get_strength(constraint_ptr))
        return rv
    }

    /// Retrieves the `GtkConstraintTarget` used as the target for `constraint`.
    /// 
    /// If the `GtkConstraint:target` property is set to `nil`, the `constraint`
    /// will use the `GtkConstraintLayout`'s widget.
    @inlinable func getTarget() -> ConstraintTargetRef! {
        let rv = ConstraintTargetRef(gconstpointer: gconstpointer(gtk_constraint_get_target(constraint_ptr)))
        return rv
    }

    /// Retrieves the attribute of the target to be set by the `constraint`.
    @inlinable func getTargetAttribute() -> GtkConstraintAttribute {
        let rv = gtk_constraint_get_target_attribute(constraint_ptr)
        return rv
    }
    /// The constant value to be added to the `GtkConstraint:source`-attribute.
    @inlinable var constant: CDouble {
        /// Retrieves the constant factor added to the source attributes' value.
        get {
            let rv = gtk_constraint_get_constant(constraint_ptr)
            return rv
        }
    }

    /// Checks whether the `constraint` is attached to a `GtkConstraintLayout`,
    /// and it is contributing to the layout.
    @inlinable var isAttached: Bool {
        /// Checks whether the `constraint` is attached to a `GtkConstraintLayout`,
        /// and it is contributing to the layout.
        get {
            let rv = ((gtk_constraint_is_attached(constraint_ptr)) != 0)
            return rv
        }
    }

    /// Checks whether the `constraint` describes a relation between an attribute
    /// on the `GtkConstraint:target` and a constant value.
    @inlinable var isConstant: Bool {
        /// Checks whether the `constraint` describes a relation between an attribute
        /// on the `GtkConstraint:target` and a constant value.
        get {
            let rv = ((gtk_constraint_is_constant(constraint_ptr)) != 0)
            return rv
        }
    }

    /// Checks whether the `constraint` is a required relation for solving the
    /// constraint layout.
    @inlinable var isRequired: Bool {
        /// Checks whether the `constraint` is a required relation for solving the
        /// constraint layout.
        get {
            let rv = ((gtk_constraint_is_required(constraint_ptr)) != 0)
            return rv
        }
    }

    /// The multiplication factor to be applied to the
    /// `GtkConstraint:source`-attribute.
    @inlinable var multiplier: CDouble {
        /// Retrieves the multiplication factor applied to the source
        /// attribute's value.
        get {
            let rv = gtk_constraint_get_multiplier(constraint_ptr)
            return rv
        }
    }

    /// The order relation between the terms of the constraint.
    @inlinable var relation: GtkConstraintRelation {
        /// The order relation between the terms of the `constraint`.
        get {
            let rv = gtk_constraint_get_relation(constraint_ptr)
            return rv
        }
    }

    /// The source of the constraint.
    /// 
    /// The constraint will set the `GtkConstraint:target`-attribute of the
    /// target using the `GtkConstraint:source`-attribute of the source.
    @inlinable var source: ConstraintTargetRef! {
        /// Retrieves the `GtkConstraintTarget` used as the source for `constraint`.
        /// 
        /// If the `GtkConstraint:source` property is set to `nil`, the `constraint`
        /// will use the `GtkConstraintLayout`'s widget.
        get {
            let rv = ConstraintTargetRef(gconstpointer: gconstpointer(gtk_constraint_get_source(constraint_ptr)))
            return rv
        }
    }

    /// Retrieves the attribute of the source to be read by the `constraint`.
    @inlinable var sourceAttribute: GtkConstraintAttribute {
        /// Retrieves the attribute of the source to be read by the `constraint`.
        get {
            let rv = gtk_constraint_get_source_attribute(constraint_ptr)
            return rv
        }
    }

    /// The strength of the constraint.
    /// 
    /// The strength can be expressed either using one of the symbolic values
    /// of the `GtkConstraintStrength` enumeration, or any positive integer
    /// value.
    @inlinable var strength: Int {
        /// Retrieves the strength of the constraint.
        get {
            let rv = Int(gtk_constraint_get_strength(constraint_ptr))
            return rv
        }
    }

    /// The target of the constraint.
    /// 
    /// The constraint will set the `GtkConstraint:target`-attribute of the
    /// target using the `GtkConstraint:source`-attribute of the source
    /// widget.
    @inlinable var target: ConstraintTargetRef! {
        /// Retrieves the `GtkConstraintTarget` used as the target for `constraint`.
        /// 
        /// If the `GtkConstraint:target` property is set to `nil`, the `constraint`
        /// will use the `GtkConstraintLayout`'s widget.
        get {
            let rv = ConstraintTargetRef(gconstpointer: gconstpointer(gtk_constraint_get_target(constraint_ptr)))
            return rv
        }
    }

    /// Retrieves the attribute of the target to be set by the `constraint`.
    @inlinable var targetAttribute: GtkConstraintAttribute {
        /// Retrieves the attribute of the target to be set by the `constraint`.
        get {
            let rv = gtk_constraint_get_target_attribute(constraint_ptr)
            return rv
        }
    }


}



// MARK: - ConstraintGuide Class

/// The `ConstraintGuideProtocol` protocol exposes the methods and properties of an underlying `GtkConstraintGuide` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ConstraintGuide`.
/// Alternatively, use `ConstraintGuideRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A `GtkConstraintGuide` is an invisible layout element that can be
/// used by widgets inside a `GtkConstraintLayout` as a source or a target
/// of a `GtkConstraint`. Guides can be used like guidelines or as
/// flexible space.
/// 
/// Unlike a `GtkWidget`, a `GtkConstraintGuide` will not be drawn.
public protocol ConstraintGuideProtocol: GLibObject.ObjectProtocol, ConstraintTargetProtocol {
        /// Untyped pointer to the underlying `GtkConstraintGuide` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkConstraintGuide` instance.
    var constraint_guide_ptr: UnsafeMutablePointer<GtkConstraintGuide>! { get }

}

/// The `ConstraintGuideRef` type acts as a lightweight Swift reference to an underlying `GtkConstraintGuide` instance.
/// It exposes methods that can operate on this data type through `ConstraintGuideProtocol` conformance.
/// Use `ConstraintGuideRef` only as an `unowned` reference to an existing `GtkConstraintGuide` instance.
///
/// A `GtkConstraintGuide` is an invisible layout element that can be
/// used by widgets inside a `GtkConstraintLayout` as a source or a target
/// of a `GtkConstraint`. Guides can be used like guidelines or as
/// flexible space.
/// 
/// Unlike a `GtkWidget`, a `GtkConstraintGuide` will not be drawn.
public struct ConstraintGuideRef: ConstraintGuideProtocol {
        /// Untyped pointer to the underlying `GtkConstraintGuide` instance.
    /// For type-safe access, use the generated, typed pointer `constraint_guide_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ConstraintGuideRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkConstraintGuide>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkConstraintGuide>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkConstraintGuide>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkConstraintGuide>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ConstraintGuideProtocol`
    @inlinable init<T: ConstraintGuideProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkConstraintGuide` object.
    @inlinable init() {
        let rv = gtk_constraint_guide_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `ConstraintGuide` type acts as a reference-counted owner of an underlying `GtkConstraintGuide` instance.
/// It provides the methods that can operate on this data type through `ConstraintGuideProtocol` conformance.
/// Use `ConstraintGuide` as a strong reference or owner of a `GtkConstraintGuide` instance.
///
/// A `GtkConstraintGuide` is an invisible layout element that can be
/// used by widgets inside a `GtkConstraintLayout` as a source or a target
/// of a `GtkConstraint`. Guides can be used like guidelines or as
/// flexible space.
/// 
/// Unlike a `GtkWidget`, a `GtkConstraintGuide` will not be drawn.
open class ConstraintGuide: GLibObject.Object, ConstraintGuideProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintGuide` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkConstraintGuide>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintGuide` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkConstraintGuide>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintGuide` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintGuide` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintGuide` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkConstraintGuide>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintGuide` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkConstraintGuide>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkConstraintGuide`.
    /// i.e., ownership is transferred to the `ConstraintGuide` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkConstraintGuide>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ConstraintGuideProtocol`
    /// Will retain `GtkConstraintGuide`.
    /// - Parameter other: an instance of a related type that implements `ConstraintGuideProtocol`
    @inlinable public init<T: ConstraintGuideProtocol>(constraintGuide other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkConstraintGuide` object.
    @inlinable public init() {
        let rv = gtk_constraint_guide_new()
        super.init(gpointer: gpointer(rv))
    }


}

public enum ConstraintGuidePropertyName: String, PropertyNameProtocol {
    /// The maximum height of the guide.
    case maxHeight = "max-height"
    /// The maximum width of the guide.
    case maxWidth = "max-width"
    /// The minimum height of the guide.
    case minHeight = "min-height"
    /// The minimum width of the guide.
    case minWidth = "min-width"
    /// A name that identifies the `GtkConstraintGuide`, for debugging.
    case name = "name"
    /// The preferred, or natural, height of the guide.
    case natHeight = "nat-height"
    /// The preferred, or natural, width of the guide.
    case natWidth = "nat-width"
    /// The `GtkConstraintStrength` to be used for the constraint on
    /// the natural size of the guide.
    case strength = "strength"
}

public extension ConstraintGuideProtocol {
    /// Bind a `ConstraintGuidePropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ConstraintGuidePropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ConstraintGuide property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ConstraintGuidePropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ConstraintGuide property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ConstraintGuidePropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ConstraintGuideSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The maximum height of the guide.
    case notifyMaxHeight = "notify::max-height"
    /// The maximum width of the guide.
    case notifyMaxWidth = "notify::max-width"
    /// The minimum height of the guide.
    case notifyMinHeight = "notify::min-height"
    /// The minimum width of the guide.
    case notifyMinWidth = "notify::min-width"
    /// A name that identifies the `GtkConstraintGuide`, for debugging.
    case notifyName = "notify::name"
    /// The preferred, or natural, height of the guide.
    case notifyNatHeight = "notify::nat-height"
    /// The preferred, or natural, width of the guide.
    case notifyNatWidth = "notify::nat-width"
    /// The `GtkConstraintStrength` to be used for the constraint on
    /// the natural size of the guide.
    case notifyStrength = "notify::strength"
}

public extension ConstraintGuideProtocol {
    /// Connect a `ConstraintGuideSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @inlinable @discardableResult func connect(signal kind: ConstraintGuideSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> Int {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> Int {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(raw: ptr).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

// MARK: ConstraintGuide Class: ConstraintGuideProtocol extension (methods and fields)
public extension ConstraintGuideProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkConstraintGuide` instance.
    @inlinable var constraint_guide_ptr: UnsafeMutablePointer<GtkConstraintGuide>! { return ptr?.assumingMemoryBound(to: GtkConstraintGuide.self) }

    /// Gets the maximum size of `guide`.
    @inlinable func getMaxSize(width: UnsafeMutablePointer<gint>? = nil, height: UnsafeMutablePointer<gint>? = nil) {
        gtk_constraint_guide_get_max_size(constraint_guide_ptr, width, height)
    
    }

    /// Gets the minimum size of `guide`.
    @inlinable func getMinSize(width: UnsafeMutablePointer<gint>? = nil, height: UnsafeMutablePointer<gint>? = nil) {
        gtk_constraint_guide_get_min_size(constraint_guide_ptr, width, height)
    
    }

    /// Retrieves the name set using `gtk_constraint_guide_set_name()`.
    @inlinable func getName() -> String! {
        let rv = gtk_constraint_guide_get_name(constraint_guide_ptr).map({ String(cString: $0) })
        return rv
    }

    /// Gets the natural size of `guide`.
    @inlinable func getNatSize(width: UnsafeMutablePointer<gint>? = nil, height: UnsafeMutablePointer<gint>? = nil) {
        gtk_constraint_guide_get_nat_size(constraint_guide_ptr, width, height)
    
    }

    /// Retrieves the strength set using `gtk_constraint_guide_set_strength()`.
    @inlinable func getStrength() -> GtkConstraintStrength {
        let rv = gtk_constraint_guide_get_strength(constraint_guide_ptr)
        return rv
    }

    /// Sets the maximum size of `guide`.
    /// 
    /// If `guide` is attached to a `GtkConstraintLayout`,
    /// the constraints will be updated to reflect the new size.
    @inlinable func setMaxSize(width: Int, height: Int) {
        gtk_constraint_guide_set_max_size(constraint_guide_ptr, gint(width), gint(height))
    
    }

    /// Sets the minimum size of `guide`.
    /// 
    /// If `guide` is attached to a `GtkConstraintLayout`,
    /// the constraints will be updated to reflect the new size.
    @inlinable func setMinSize(width: Int, height: Int) {
        gtk_constraint_guide_set_min_size(constraint_guide_ptr, gint(width), gint(height))
    
    }

    /// Sets a name for the given `GtkConstraintGuide`.
    /// 
    /// The name is useful for debugging purposes.
    @inlinable func set(name: UnsafePointer<CChar>? = nil) {
        gtk_constraint_guide_set_name(constraint_guide_ptr, name)
    
    }

    /// Sets the natural size of `guide`.
    /// 
    /// If `guide` is attached to a `GtkConstraintLayout`,
    /// the constraints will be updated to reflect the new size.
    @inlinable func setNatSize(width: Int, height: Int) {
        gtk_constraint_guide_set_nat_size(constraint_guide_ptr, gint(width), gint(height))
    
    }

    /// Sets the strength of the constraint on the natural size of the
    /// given `GtkConstraintGuide`.
    @inlinable func set(strength: GtkConstraintStrength) {
        gtk_constraint_guide_set_strength(constraint_guide_ptr, strength)
    
    }
    /// A name that identifies the `GtkConstraintGuide`, for debugging.
    @inlinable var name: String! {
        /// Retrieves the name set using `gtk_constraint_guide_set_name()`.
        get {
            let rv = gtk_constraint_guide_get_name(constraint_guide_ptr).map({ String(cString: $0) })
            return rv
        }
        /// Sets a name for the given `GtkConstraintGuide`.
        /// 
        /// The name is useful for debugging purposes.
        nonmutating set {
            gtk_constraint_guide_set_name(constraint_guide_ptr, newValue)
        }
    }

    /// The `GtkConstraintStrength` to be used for the constraint on
    /// the natural size of the guide.
    @inlinable var strength: GtkConstraintStrength {
        /// Retrieves the strength set using `gtk_constraint_guide_set_strength()`.
        get {
            let rv = gtk_constraint_guide_get_strength(constraint_guide_ptr)
            return rv
        }
        /// Sets the strength of the constraint on the natural size of the
        /// given `GtkConstraintGuide`.
        nonmutating set {
            gtk_constraint_guide_set_strength(constraint_guide_ptr, newValue)
        }
    }


}



// MARK: - ConstraintLayout Class

/// The `ConstraintLayoutProtocol` protocol exposes the methods and properties of an underlying `GtkConstraintLayout` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ConstraintLayout`.
/// Alternatively, use `ConstraintLayoutRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// GtkConstraintLayout is a layout manager that uses relations between
/// widget attributes, expressed via `GtkConstraint` instances, to measure
/// and allocate widgets.
/// 
/// # How do constraints work
/// 
/// Constraints are objects defining the relationship between attributes
/// of a widget; you can read the description of the `GtkConstraint`
/// class to have a more in depth definition.
/// 
/// By taking multiple constraints and applying them to the children of
/// a widget using `GtkConstraintLayout`, it's possible to describe complex
/// layout policies; each constraint applied to a child or to the parent
/// widgets contributes to the full description of the layout, in terms of
/// parameters for resolving the value of each attribute.
/// 
/// It is important to note that a layout is defined by the totality of
/// constraints; removing a child, or a constraint, from an existing layout
/// without changing the remaining constraints may result in an unstable
/// or unsolvable layout.
/// 
/// Constraints have an implicit "reading order"; you should start describing
/// each edge of each child, as well as their relationship with the parent
/// container, from the top left (or top right, in RTL languages), horizontally
/// first, and then vertically.
/// 
/// A constraint-based layout with too few constraints can become "unstable",
/// that is: have more than one solution. The behavior of an unstable layout
/// is undefined.
/// 
/// A constraint-based layout with conflicting constraints may be unsolvable,
/// and lead to an unstable layout. You can use the `GtkConstraint:strength`
/// property of `GtkConstraint` to "nudge" the layout towards a solution.
/// 
/// # GtkConstraintLayout as GtkBuildable
/// 
/// GtkConstraintLayout implements the `GtkBuildable` interface and has a
/// custom "constraints" element which allows describing constraints in a
/// GtkBuilder UI file.
/// 
/// An example of a UI definition fragment specifying a constraint:
/// 
/// ```
///   <object class="GtkConstraintLayout">
///     <constraints>
///       <constraint target="button" target-attribute="start"
///                   relation="eq"
///                   source="super" source-attribute="start"
///                   constant="12"
///                   strength="required" />
///       <constraint target="button" target-attribute="width"
///                   relation="ge"
///                   constant="250"
///                   strength="strong" />
///     </constraints>
///   </object>
/// ```
/// 
/// The definition above will add two constraints to the GtkConstraintLayout:
/// 
///  - a required constraint between the leading edge of "button" and
///    the leading edge of the widget using the constraint layout, plus
///    12 pixels
///  - a strong, constant constraint making the width of "button" greater
///    than, or equal to 250 pixels
/// 
/// The "target" and "target-attribute" attributes are required.
/// 
/// The "source" and "source-attribute" attributes of the "constraint"
/// element are optional; if they are not specified, the constraint is
/// assumed to be a constant.
/// 
/// The "relation" attribute is optional; if not specified, the constraint
/// is assumed to be an equality.
/// 
/// The "strength" attribute is optional; if not specified, the constraint
/// is assumed to be required.
/// 
/// The "source" and "target" attributes can be set to "super" to indicate
/// that the constraint target is the widget using the GtkConstraintLayout.
/// 
/// There can be "constant" and "multiplier" attributes.
/// 
/// Additionally, the "constraints" element can also contain a description
/// of the `GtkConstraintGuides` used by the layout:
/// 
/// ```
///   <constraints>
///     <guide min-width="100" max-width="500" name="hspace"/>
///     <guide min-height="64" nat-height="128" name="vspace" strength="strong"/>
///   </constraints>
/// ```
/// 
/// The "guide" element has the following optional attributes:
/// 
///   - "min-width", "nat-width", and "max-width", describe the minimum,
///     natural, and maximum width of the guide, respectively
///   - "min-height", "nat-height", and "max-height", describe the minimum,
///     natural, and maximum height of the guide, respectively
///   - "strength" describes the strength of the constraint on the natural
///     size of the guide; if not specified, the constraint is assumed to
///     have a medium strength
///   - "name" describes a name for the guide, useful when debugging
/// 
/// # Using the Visual Format Language
/// 
/// Complex constraints can be described using a compact syntax called VFL,
/// or *Visual Format Language*.
/// 
/// The Visual Format Language describes all the constraints on a row or
/// column, typically starting from the leading edge towards the trailing
/// one. Each element of the layout is composed by "views", which identify
/// a `GtkConstraintTarget`.
/// 
/// For instance:
/// 
/// ```
///   [button]-[textField]
/// ```
/// 
/// Describes a constraint that binds the trailing edge of "button" to the
/// leading edge of "textField", leaving a default space between the two.
/// 
/// Using VFL is also possible to specify predicates that describe constraints
/// on attributes like width and height:
/// 
/// ```
///   // Width must be greater than, or equal to 50
///   [button(>=50)]
/// 
///   // Width of button1 must be equal to width of button2
///   [button1(==button2)]
/// ```
/// 
/// The default orientation for a VFL description is horizontal, unless
/// otherwise specified:
/// 
/// ```
///   // horizontal orientation, default attribute: width
///   H:[button(>=150)]
/// 
///   // vertical orientation, default attribute: height
///   V:[button1(==button2)]
/// ```
/// 
/// It's also possible to specify multiple predicates, as well as their
/// strength:
/// 
/// ```
///   // minimum width of button must be 150
///   // natural width of button can be 250
///   [button(>=150@required, ==250@medium)]
/// ```
/// 
/// Finally, it's also possible to use simple arithmetic operators:
/// 
/// ```
///   // width of button1 must be equal to width of button2
///   // divided by 2 plus 12
///   [button1(button2 / 2 + 12)]
/// ```
/// 
public protocol ConstraintLayoutProtocol: LayoutManagerProtocol, BuildableProtocol {
        /// Untyped pointer to the underlying `GtkConstraintLayout` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkConstraintLayout` instance.
    var constraint_layout_ptr: UnsafeMutablePointer<GtkConstraintLayout>! { get }

}

/// The `ConstraintLayoutRef` type acts as a lightweight Swift reference to an underlying `GtkConstraintLayout` instance.
/// It exposes methods that can operate on this data type through `ConstraintLayoutProtocol` conformance.
/// Use `ConstraintLayoutRef` only as an `unowned` reference to an existing `GtkConstraintLayout` instance.
///
/// GtkConstraintLayout is a layout manager that uses relations between
/// widget attributes, expressed via `GtkConstraint` instances, to measure
/// and allocate widgets.
/// 
/// # How do constraints work
/// 
/// Constraints are objects defining the relationship between attributes
/// of a widget; you can read the description of the `GtkConstraint`
/// class to have a more in depth definition.
/// 
/// By taking multiple constraints and applying them to the children of
/// a widget using `GtkConstraintLayout`, it's possible to describe complex
/// layout policies; each constraint applied to a child or to the parent
/// widgets contributes to the full description of the layout, in terms of
/// parameters for resolving the value of each attribute.
/// 
/// It is important to note that a layout is defined by the totality of
/// constraints; removing a child, or a constraint, from an existing layout
/// without changing the remaining constraints may result in an unstable
/// or unsolvable layout.
/// 
/// Constraints have an implicit "reading order"; you should start describing
/// each edge of each child, as well as their relationship with the parent
/// container, from the top left (or top right, in RTL languages), horizontally
/// first, and then vertically.
/// 
/// A constraint-based layout with too few constraints can become "unstable",
/// that is: have more than one solution. The behavior of an unstable layout
/// is undefined.
/// 
/// A constraint-based layout with conflicting constraints may be unsolvable,
/// and lead to an unstable layout. You can use the `GtkConstraint:strength`
/// property of `GtkConstraint` to "nudge" the layout towards a solution.
/// 
/// # GtkConstraintLayout as GtkBuildable
/// 
/// GtkConstraintLayout implements the `GtkBuildable` interface and has a
/// custom "constraints" element which allows describing constraints in a
/// GtkBuilder UI file.
/// 
/// An example of a UI definition fragment specifying a constraint:
/// 
/// ```
///   <object class="GtkConstraintLayout">
///     <constraints>
///       <constraint target="button" target-attribute="start"
///                   relation="eq"
///                   source="super" source-attribute="start"
///                   constant="12"
///                   strength="required" />
///       <constraint target="button" target-attribute="width"
///                   relation="ge"
///                   constant="250"
///                   strength="strong" />
///     </constraints>
///   </object>
/// ```
/// 
/// The definition above will add two constraints to the GtkConstraintLayout:
/// 
///  - a required constraint between the leading edge of "button" and
///    the leading edge of the widget using the constraint layout, plus
///    12 pixels
///  - a strong, constant constraint making the width of "button" greater
///    than, or equal to 250 pixels
/// 
/// The "target" and "target-attribute" attributes are required.
/// 
/// The "source" and "source-attribute" attributes of the "constraint"
/// element are optional; if they are not specified, the constraint is
/// assumed to be a constant.
/// 
/// The "relation" attribute is optional; if not specified, the constraint
/// is assumed to be an equality.
/// 
/// The "strength" attribute is optional; if not specified, the constraint
/// is assumed to be required.
/// 
/// The "source" and "target" attributes can be set to "super" to indicate
/// that the constraint target is the widget using the GtkConstraintLayout.
/// 
/// There can be "constant" and "multiplier" attributes.
/// 
/// Additionally, the "constraints" element can also contain a description
/// of the `GtkConstraintGuides` used by the layout:
/// 
/// ```
///   <constraints>
///     <guide min-width="100" max-width="500" name="hspace"/>
///     <guide min-height="64" nat-height="128" name="vspace" strength="strong"/>
///   </constraints>
/// ```
/// 
/// The "guide" element has the following optional attributes:
/// 
///   - "min-width", "nat-width", and "max-width", describe the minimum,
///     natural, and maximum width of the guide, respectively
///   - "min-height", "nat-height", and "max-height", describe the minimum,
///     natural, and maximum height of the guide, respectively
///   - "strength" describes the strength of the constraint on the natural
///     size of the guide; if not specified, the constraint is assumed to
///     have a medium strength
///   - "name" describes a name for the guide, useful when debugging
/// 
/// # Using the Visual Format Language
/// 
/// Complex constraints can be described using a compact syntax called VFL,
/// or *Visual Format Language*.
/// 
/// The Visual Format Language describes all the constraints on a row or
/// column, typically starting from the leading edge towards the trailing
/// one. Each element of the layout is composed by "views", which identify
/// a `GtkConstraintTarget`.
/// 
/// For instance:
/// 
/// ```
///   [button]-[textField]
/// ```
/// 
/// Describes a constraint that binds the trailing edge of "button" to the
/// leading edge of "textField", leaving a default space between the two.
/// 
/// Using VFL is also possible to specify predicates that describe constraints
/// on attributes like width and height:
/// 
/// ```
///   // Width must be greater than, or equal to 50
///   [button(>=50)]
/// 
///   // Width of button1 must be equal to width of button2
///   [button1(==button2)]
/// ```
/// 
/// The default orientation for a VFL description is horizontal, unless
/// otherwise specified:
/// 
/// ```
///   // horizontal orientation, default attribute: width
///   H:[button(>=150)]
/// 
///   // vertical orientation, default attribute: height
///   V:[button1(==button2)]
/// ```
/// 
/// It's also possible to specify multiple predicates, as well as their
/// strength:
/// 
/// ```
///   // minimum width of button must be 150
///   // natural width of button can be 250
///   [button(>=150@required, ==250@medium)]
/// ```
/// 
/// Finally, it's also possible to use simple arithmetic operators:
/// 
/// ```
///   // width of button1 must be equal to width of button2
///   // divided by 2 plus 12
///   [button1(button2 / 2 + 12)]
/// ```
/// 
public struct ConstraintLayoutRef: ConstraintLayoutProtocol {
        /// Untyped pointer to the underlying `GtkConstraintLayout` instance.
    /// For type-safe access, use the generated, typed pointer `constraint_layout_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ConstraintLayoutRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkConstraintLayout>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkConstraintLayout>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkConstraintLayout>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkConstraintLayout>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ConstraintLayoutProtocol`
    @inlinable init<T: ConstraintLayoutProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkConstraintLayout` layout manager.
    @inlinable init() {
        let rv = gtk_constraint_layout_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `ConstraintLayout` type acts as a reference-counted owner of an underlying `GtkConstraintLayout` instance.
/// It provides the methods that can operate on this data type through `ConstraintLayoutProtocol` conformance.
/// Use `ConstraintLayout` as a strong reference or owner of a `GtkConstraintLayout` instance.
///
/// GtkConstraintLayout is a layout manager that uses relations between
/// widget attributes, expressed via `GtkConstraint` instances, to measure
/// and allocate widgets.
/// 
/// # How do constraints work
/// 
/// Constraints are objects defining the relationship between attributes
/// of a widget; you can read the description of the `GtkConstraint`
/// class to have a more in depth definition.
/// 
/// By taking multiple constraints and applying them to the children of
/// a widget using `GtkConstraintLayout`, it's possible to describe complex
/// layout policies; each constraint applied to a child or to the parent
/// widgets contributes to the full description of the layout, in terms of
/// parameters for resolving the value of each attribute.
/// 
/// It is important to note that a layout is defined by the totality of
/// constraints; removing a child, or a constraint, from an existing layout
/// without changing the remaining constraints may result in an unstable
/// or unsolvable layout.
/// 
/// Constraints have an implicit "reading order"; you should start describing
/// each edge of each child, as well as their relationship with the parent
/// container, from the top left (or top right, in RTL languages), horizontally
/// first, and then vertically.
/// 
/// A constraint-based layout with too few constraints can become "unstable",
/// that is: have more than one solution. The behavior of an unstable layout
/// is undefined.
/// 
/// A constraint-based layout with conflicting constraints may be unsolvable,
/// and lead to an unstable layout. You can use the `GtkConstraint:strength`
/// property of `GtkConstraint` to "nudge" the layout towards a solution.
/// 
/// # GtkConstraintLayout as GtkBuildable
/// 
/// GtkConstraintLayout implements the `GtkBuildable` interface and has a
/// custom "constraints" element which allows describing constraints in a
/// GtkBuilder UI file.
/// 
/// An example of a UI definition fragment specifying a constraint:
/// 
/// ```
///   <object class="GtkConstraintLayout">
///     <constraints>
///       <constraint target="button" target-attribute="start"
///                   relation="eq"
///                   source="super" source-attribute="start"
///                   constant="12"
///                   strength="required" />
///       <constraint target="button" target-attribute="width"
///                   relation="ge"
///                   constant="250"
///                   strength="strong" />
///     </constraints>
///   </object>
/// ```
/// 
/// The definition above will add two constraints to the GtkConstraintLayout:
/// 
///  - a required constraint between the leading edge of "button" and
///    the leading edge of the widget using the constraint layout, plus
///    12 pixels
///  - a strong, constant constraint making the width of "button" greater
///    than, or equal to 250 pixels
/// 
/// The "target" and "target-attribute" attributes are required.
/// 
/// The "source" and "source-attribute" attributes of the "constraint"
/// element are optional; if they are not specified, the constraint is
/// assumed to be a constant.
/// 
/// The "relation" attribute is optional; if not specified, the constraint
/// is assumed to be an equality.
/// 
/// The "strength" attribute is optional; if not specified, the constraint
/// is assumed to be required.
/// 
/// The "source" and "target" attributes can be set to "super" to indicate
/// that the constraint target is the widget using the GtkConstraintLayout.
/// 
/// There can be "constant" and "multiplier" attributes.
/// 
/// Additionally, the "constraints" element can also contain a description
/// of the `GtkConstraintGuides` used by the layout:
/// 
/// ```
///   <constraints>
///     <guide min-width="100" max-width="500" name="hspace"/>
///     <guide min-height="64" nat-height="128" name="vspace" strength="strong"/>
///   </constraints>
/// ```
/// 
/// The "guide" element has the following optional attributes:
/// 
///   - "min-width", "nat-width", and "max-width", describe the minimum,
///     natural, and maximum width of the guide, respectively
///   - "min-height", "nat-height", and "max-height", describe the minimum,
///     natural, and maximum height of the guide, respectively
///   - "strength" describes the strength of the constraint on the natural
///     size of the guide; if not specified, the constraint is assumed to
///     have a medium strength
///   - "name" describes a name for the guide, useful when debugging
/// 
/// # Using the Visual Format Language
/// 
/// Complex constraints can be described using a compact syntax called VFL,
/// or *Visual Format Language*.
/// 
/// The Visual Format Language describes all the constraints on a row or
/// column, typically starting from the leading edge towards the trailing
/// one. Each element of the layout is composed by "views", which identify
/// a `GtkConstraintTarget`.
/// 
/// For instance:
/// 
/// ```
///   [button]-[textField]
/// ```
/// 
/// Describes a constraint that binds the trailing edge of "button" to the
/// leading edge of "textField", leaving a default space between the two.
/// 
/// Using VFL is also possible to specify predicates that describe constraints
/// on attributes like width and height:
/// 
/// ```
///   // Width must be greater than, or equal to 50
///   [button(>=50)]
/// 
///   // Width of button1 must be equal to width of button2
///   [button1(==button2)]
/// ```
/// 
/// The default orientation for a VFL description is horizontal, unless
/// otherwise specified:
/// 
/// ```
///   // horizontal orientation, default attribute: width
///   H:[button(>=150)]
/// 
///   // vertical orientation, default attribute: height
///   V:[button1(==button2)]
/// ```
/// 
/// It's also possible to specify multiple predicates, as well as their
/// strength:
/// 
/// ```
///   // minimum width of button must be 150
///   // natural width of button can be 250
///   [button(>=150@required, ==250@medium)]
/// ```
/// 
/// Finally, it's also possible to use simple arithmetic operators:
/// 
/// ```
///   // width of button1 must be equal to width of button2
///   // divided by 2 plus 12
///   [button1(button2 / 2 + 12)]
/// ```
/// 
open class ConstraintLayout: LayoutManager, ConstraintLayoutProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkConstraintLayout>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkConstraintLayout>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintLayout` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkConstraintLayout>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkConstraintLayout>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkConstraintLayout`.
    /// i.e., ownership is transferred to the `ConstraintLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkConstraintLayout>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ConstraintLayoutProtocol`
    /// Will retain `GtkConstraintLayout`.
    /// - Parameter other: an instance of a related type that implements `ConstraintLayoutProtocol`
    @inlinable public init<T: ConstraintLayoutProtocol>(constraintLayout other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkConstraintLayout` layout manager.
    @inlinable public init() {
        let rv = gtk_constraint_layout_new()
        super.init(gpointer: gpointer(rv))
    }


}

// MARK: no ConstraintLayout properties

public enum ConstraintLayoutSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"

}

public extension ConstraintLayoutProtocol {
    /// Connect a `ConstraintLayoutSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @inlinable @discardableResult func connect(signal kind: ConstraintLayoutSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> Int {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> Int {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(raw: ptr).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

// MARK: ConstraintLayout Class: ConstraintLayoutProtocol extension (methods and fields)
public extension ConstraintLayoutProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkConstraintLayout` instance.
    @inlinable var constraint_layout_ptr: UnsafeMutablePointer<GtkConstraintLayout>! { return ptr?.assumingMemoryBound(to: GtkConstraintLayout.self) }

    /// Adds a `GtkConstraint` to the layout manager.
    /// 
    /// The `GtkConstraint:source` and `GtkConstraint:target`
    /// properties of `constraint` can be:
    /// 
    ///  - set to `nil` to indicate that the constraint refers to the
    ///    widget using `layout`
    ///  - set to the `GtkWidget` using `layout`
    ///  - set to a child of the `GtkWidget` using `layout`
    ///  - set to a guide that is part of `layout`
    /// 
    /// The `layout` acquires the ownership of `constraint` after calling
    /// this function.
    @inlinable func add<ConstraintT: ConstraintProtocol>(constraint: ConstraintT) {
        gtk_constraint_layout_add_constraint(constraint_layout_ptr, constraint.constraint_ptr)
    
    }


    // *** addConstraintsFromDescription() is not available because it has a varargs (...) parameter!


    /// Creates a list of constraints from a formal description using a compact
    /// description syntax called VFL, or "Visual Format Language".
    /// 
    /// The Visual Format Language is based on Apple's AutoLayout [VFL](https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html).
    /// 
    /// The `views` dictionary is used to match `GtkConstraintTargets` to the symbolic
    /// view name inside the VFL.
    /// 
    /// The VFL grammar is:
    /// 
    /// (plain Language Example):
    /// ```plain
    ///        <visualFormatString> = (<orientation>)?
    ///                               (<superview><connection>)?
    ///                               <view>(<connection><view>)*
    ///                               (<connection><superview>)?
    ///               <orientation> = 'H' | 'V'
    ///                 <superview> = '|'
    ///                <connection> = '' | '-' <predicateList> '-' | '-'
    ///             <predicateList> = <simplePredicate> | <predicateListWithParens>
    ///           <simplePredicate> = <metricName> | <positiveNumber>
    ///   <predicateListWithParens> = '(' <predicate> (',' <predicate>)* ')'
    ///                 <predicate> = (<relation>)? <objectOfPredicate> (<operatorList>)? ('@' <priority>)?
    ///                  <relation> = '==' | '<=' | '>='
    ///         <objectOfPredicate> = <constant> | <viewName> | ('.' <attributeName>)?
    ///                  <priority> = <positiveNumber> | 'required' | 'strong' | 'medium' | 'weak'
    ///                  <constant> = <number>
    ///              <operatorList> = (<multiplyOperator>)? (<addOperator>)?
    ///          <multiplyOperator> = [ '*' | '/' ] <positiveNumber>
    ///               <addOperator> = [ '+' | '-' ] <positiveNumber>
    ///                  <viewName> = [A-Za-z_]([A-Za-z0-9_]*) // A C identifier
    ///                <metricName> = [A-Za-z_]([A-Za-z0-9_]*) // A C identifier
    ///             <attributeName> = 'top' | 'bottom' | 'left' | 'right' | 'width' | 'height' |
    ///                               'start' | 'end' | 'centerX' | 'centerY' | 'baseline'
    ///            <positiveNumber> // A positive real number parseable by g_ascii_strtod()
    ///                    <number> // A real number parseable by g_ascii_strtod()
    /// ```
    /// 
    /// **Note**: The VFL grammar used by GTK is slightly different than the one
    /// defined by Apple, as it can use symbolic values for the constraint's
    /// strength instead of numeric values; additionally, GTK allows adding
    /// simple arithmetic operations inside predicates.
    /// 
    /// Examples of VFL descriptions are:
    /// 
    /// (plain Language Example):
    /// ```plain
    ///   // Default spacing
    ///   [button]-[textField]
    /// 
    ///   // Width constraint
    ///   [button(>=50)]
    /// 
    ///   // Connection to super view
    ///   |-50-[purpleBox]-50-|
    /// 
    ///   // Vertical layout
    ///   V:[topField]-10-[bottomField]
    /// 
    ///   // Flush views
    ///   [maroonView][blueView]
    /// 
    ///   // Priority
    ///   [button(100@strong)]
    /// 
    ///   // Equal widths
    ///   [button1(==button2)]
    /// 
    ///   // Multiple predicates
    ///   [flexibleButton(>=70,<=100)]
    /// 
    ///   // A complete line of layout
    ///   |-[find]-[findNext]-[findField(>=20)]-|
    /// 
    ///   // Operators
    ///   [button1(button2 / 3 + 50)]
    /// 
    ///   // Named attributes
    ///   [button1(==button2.height)]
    /// ```
    /// 
    @inlinable func addConstraintsFromDescriptionv<HashTableT: GLib.HashTableProtocol>(lines: UnsafePointer<UnsafePointer<CChar>?>!, nLines: Int, hspacing: Int, vspacing: Int, views: HashTableT) throws -> GLib.ListRef! {
        var error: UnsafeMutablePointer<GError>?
        let rv = GLib.ListRef(gtk_constraint_layout_add_constraints_from_descriptionv(constraint_layout_ptr, lines, gsize(nLines), gint(hspacing), gint(vspacing), views.hash_table_ptr, &error))
        if let error = error { throw GLibError(error) }
        return rv
    }

    /// Adds a guide to `layout`. A guide can be used as
    /// the source or target of constraints, like a widget,
    /// but it is not visible.
    /// 
    /// The `layout` acquires the ownership of `guide` after calling
    /// this function.
    @inlinable func add<ConstraintGuideT: ConstraintGuideProtocol>(guide: ConstraintGuideT) {
        gtk_constraint_layout_add_guide(constraint_layout_ptr, guide.constraint_guide_ptr)
    
    }

    /// Returns a `GListModel` to track the constraints that are
    /// part of `layout`.
    /// 
    /// Calling this function will enable extra internal bookkeeping
    /// to track constraints and emit signals on the returned listmodel.
    /// It may slow down operations a lot.
    /// 
    /// Applications should try hard to avoid calling this function
    /// because of the slowdowns.
    @inlinable func observeConstraints() -> GIO.ListModelRef! {
        let rv = GIO.ListModelRef(gtk_constraint_layout_observe_constraints(constraint_layout_ptr))
        return rv
    }

    /// Returns a `GListModel` to track the guides that are
    /// part of `layout`.
    /// 
    /// Calling this function will enable extra internal bookkeeping
    /// to track guides and emit signals on the returned listmodel.
    /// It may slow down operations a lot.
    /// 
    /// Applications should try hard to avoid calling this function
    /// because of the slowdowns.
    @inlinable func observeGuides() -> GIO.ListModelRef! {
        let rv = GIO.ListModelRef(gtk_constraint_layout_observe_guides(constraint_layout_ptr))
        return rv
    }

    /// Removes all constraints from the layout manager.
    @inlinable func removeAllConstraints() {
        gtk_constraint_layout_remove_all_constraints(constraint_layout_ptr)
    
    }

    /// Removes `constraint` from the layout manager,
    /// so that it no longer influences the layout.
    @inlinable func remove<ConstraintT: ConstraintProtocol>(constraint: ConstraintT) {
        gtk_constraint_layout_remove_constraint(constraint_layout_ptr, constraint.constraint_ptr)
    
    }

    /// Removes `guide` from the layout manager,
    /// so that it no longer influences the layout.
    @inlinable func remove<ConstraintGuideT: ConstraintGuideProtocol>(guide: ConstraintGuideT) {
        gtk_constraint_layout_remove_guide(constraint_layout_ptr, guide.constraint_guide_ptr)
    
    }


}



// MARK: - ConstraintLayoutChild Class

/// The `ConstraintLayoutChildProtocol` protocol exposes the methods and properties of an underlying `GtkConstraintLayoutChild` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ConstraintLayoutChild`.
/// Alternatively, use `ConstraintLayoutChildRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A `GtkLayoutChild` in a `GtkConstraintLayout`.
public protocol ConstraintLayoutChildProtocol: LayoutChildProtocol {
        /// Untyped pointer to the underlying `GtkConstraintLayoutChild` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkConstraintLayoutChild` instance.
    var constraint_layout_child_ptr: UnsafeMutablePointer<GtkConstraintLayoutChild>! { get }

}

/// The `ConstraintLayoutChildRef` type acts as a lightweight Swift reference to an underlying `GtkConstraintLayoutChild` instance.
/// It exposes methods that can operate on this data type through `ConstraintLayoutChildProtocol` conformance.
/// Use `ConstraintLayoutChildRef` only as an `unowned` reference to an existing `GtkConstraintLayoutChild` instance.
///
/// A `GtkLayoutChild` in a `GtkConstraintLayout`.
public struct ConstraintLayoutChildRef: ConstraintLayoutChildProtocol {
        /// Untyped pointer to the underlying `GtkConstraintLayoutChild` instance.
    /// For type-safe access, use the generated, typed pointer `constraint_layout_child_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ConstraintLayoutChildRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkConstraintLayoutChild>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkConstraintLayoutChild>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkConstraintLayoutChild>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkConstraintLayoutChild>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ConstraintLayoutChildProtocol`
    @inlinable init<T: ConstraintLayoutChildProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `ConstraintLayoutChild` type acts as a reference-counted owner of an underlying `GtkConstraintLayoutChild` instance.
/// It provides the methods that can operate on this data type through `ConstraintLayoutChildProtocol` conformance.
/// Use `ConstraintLayoutChild` as a strong reference or owner of a `GtkConstraintLayoutChild` instance.
///
/// A `GtkLayoutChild` in a `GtkConstraintLayout`.
open class ConstraintLayoutChild: LayoutChild, ConstraintLayoutChildProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintLayoutChild` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkConstraintLayoutChild>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintLayoutChild` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkConstraintLayoutChild>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintLayoutChild` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintLayoutChild` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintLayoutChild` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkConstraintLayoutChild>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintLayoutChild` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkConstraintLayoutChild>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkConstraintLayoutChild`.
    /// i.e., ownership is transferred to the `ConstraintLayoutChild` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkConstraintLayoutChild>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ConstraintLayoutChildProtocol`
    /// Will retain `GtkConstraintLayoutChild`.
    /// - Parameter other: an instance of a related type that implements `ConstraintLayoutChildProtocol`
    @inlinable public init<T: ConstraintLayoutChildProtocol>(constraintLayoutChild other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum ConstraintLayoutChildPropertyName: String, PropertyNameProtocol {
    /// The widget that is associated to the `GtkLayoutChild` instance.
    case childWidget = "child-widget"
    /// The layout manager that created the `GtkLayoutChild` instance.
    case layoutManager = "layout-manager"
}

public extension ConstraintLayoutChildProtocol {
    /// Bind a `ConstraintLayoutChildPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ConstraintLayoutChildPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ConstraintLayoutChild property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ConstraintLayoutChildPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ConstraintLayoutChild property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ConstraintLayoutChildPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ConstraintLayoutChildSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The widget that is associated to the `GtkLayoutChild` instance.
    case notifyChildWidget = "notify::child-widget"
    /// The layout manager that created the `GtkLayoutChild` instance.
    case notifyLayoutManager = "notify::layout-manager"
}

public extension ConstraintLayoutChildProtocol {
    /// Connect a `ConstraintLayoutChildSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @inlinable @discardableResult func connect(signal kind: ConstraintLayoutChildSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> Int {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> Int {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(raw: ptr).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

// MARK: ConstraintLayoutChild Class: ConstraintLayoutChildProtocol extension (methods and fields)
public extension ConstraintLayoutChildProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkConstraintLayoutChild` instance.
    @inlinable var constraint_layout_child_ptr: UnsafeMutablePointer<GtkConstraintLayoutChild>! { return ptr?.assumingMemoryBound(to: GtkConstraintLayoutChild.self) }



}



// MARK: - CssProvider Class

/// The `CssProviderProtocol` protocol exposes the methods and properties of an underlying `GtkCssProvider` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CssProvider`.
/// Alternatively, use `CssProviderRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// GtkCssProvider is an object implementing the `GtkStyleProvider` interface.
/// It is able to parse [CSS-like](#css-overview) input in order to style widgets.
/// 
/// An application can make GTK parse a specific CSS style sheet by calling
/// `gtk_css_provider_load_from_file()` or `gtk_css_provider_load_from_resource()`
/// and adding the provider with `gtk_style_context_add_provider()` or
/// `gtk_style_context_add_provider_for_display()`.
/// 
/// In addition, certain files will be read when GTK is initialized. First, the
/// file `$XDG_CONFIG_HOME/gtk-4.0/gtk.css` is loaded if it exists. Then, GTK
/// loads the first existing file among
/// `XDG_DATA_HOME/themes/THEME/gtk-VERSION/gtk-VARIANT.css`,
/// `$HOME/.themes/THEME/gtk-VERSION/gtk-VARIANT.css`,
/// `$XDG_DATA_DIRS/themes/THEME/gtk-VERSION/gtk-VARIANT.css` and
/// `DATADIR/share/themes/THEME/gtk-VERSION/gtk-VARIANT.css`,
/// where `THEME` is the name of the current theme (see the `GtkSettings:gtk`-theme-name
/// setting), VARIANT is the variant to load (see the
/// `GtkSettings:gtk`-application-prefer-dark-theme setting), `DATADIR`
/// is the prefix configured when GTK was compiled (unless overridden by the
/// `GTK_DATA_PREFIX` environment variable), and `VERSION` is the GTK version number.
/// If no file is found for the current version, GTK tries older versions all the
/// way back to 4.0.
public protocol CssProviderProtocol: GLibObject.ObjectProtocol, StyleProviderProtocol {
        /// Untyped pointer to the underlying `GtkCssProvider` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCssProvider` instance.
    var css_provider_ptr: UnsafeMutablePointer<GtkCssProvider>! { get }

}

/// The `CssProviderRef` type acts as a lightweight Swift reference to an underlying `GtkCssProvider` instance.
/// It exposes methods that can operate on this data type through `CssProviderProtocol` conformance.
/// Use `CssProviderRef` only as an `unowned` reference to an existing `GtkCssProvider` instance.
///
/// GtkCssProvider is an object implementing the `GtkStyleProvider` interface.
/// It is able to parse [CSS-like](#css-overview) input in order to style widgets.
/// 
/// An application can make GTK parse a specific CSS style sheet by calling
/// `gtk_css_provider_load_from_file()` or `gtk_css_provider_load_from_resource()`
/// and adding the provider with `gtk_style_context_add_provider()` or
/// `gtk_style_context_add_provider_for_display()`.
/// 
/// In addition, certain files will be read when GTK is initialized. First, the
/// file `$XDG_CONFIG_HOME/gtk-4.0/gtk.css` is loaded if it exists. Then, GTK
/// loads the first existing file among
/// `XDG_DATA_HOME/themes/THEME/gtk-VERSION/gtk-VARIANT.css`,
/// `$HOME/.themes/THEME/gtk-VERSION/gtk-VARIANT.css`,
/// `$XDG_DATA_DIRS/themes/THEME/gtk-VERSION/gtk-VARIANT.css` and
/// `DATADIR/share/themes/THEME/gtk-VERSION/gtk-VARIANT.css`,
/// where `THEME` is the name of the current theme (see the `GtkSettings:gtk`-theme-name
/// setting), VARIANT is the variant to load (see the
/// `GtkSettings:gtk`-application-prefer-dark-theme setting), `DATADIR`
/// is the prefix configured when GTK was compiled (unless overridden by the
/// `GTK_DATA_PREFIX` environment variable), and `VERSION` is the GTK version number.
/// If no file is found for the current version, GTK tries older versions all the
/// way back to 4.0.
public struct CssProviderRef: CssProviderProtocol {
        /// Untyped pointer to the underlying `GtkCssProvider` instance.
    /// For type-safe access, use the generated, typed pointer `css_provider_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CssProviderRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCssProvider>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCssProvider>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCssProvider>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCssProvider>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CssProviderProtocol`
    @inlinable init<T: CssProviderProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Returns a newly created `GtkCssProvider`.
    @inlinable init() {
        let rv = gtk_css_provider_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `CssProvider` type acts as a reference-counted owner of an underlying `GtkCssProvider` instance.
/// It provides the methods that can operate on this data type through `CssProviderProtocol` conformance.
/// Use `CssProvider` as a strong reference or owner of a `GtkCssProvider` instance.
///
/// GtkCssProvider is an object implementing the `GtkStyleProvider` interface.
/// It is able to parse [CSS-like](#css-overview) input in order to style widgets.
/// 
/// An application can make GTK parse a specific CSS style sheet by calling
/// `gtk_css_provider_load_from_file()` or `gtk_css_provider_load_from_resource()`
/// and adding the provider with `gtk_style_context_add_provider()` or
/// `gtk_style_context_add_provider_for_display()`.
/// 
/// In addition, certain files will be read when GTK is initialized. First, the
/// file `$XDG_CONFIG_HOME/gtk-4.0/gtk.css` is loaded if it exists. Then, GTK
/// loads the first existing file among
/// `XDG_DATA_HOME/themes/THEME/gtk-VERSION/gtk-VARIANT.css`,
/// `$HOME/.themes/THEME/gtk-VERSION/gtk-VARIANT.css`,
/// `$XDG_DATA_DIRS/themes/THEME/gtk-VERSION/gtk-VARIANT.css` and
/// `DATADIR/share/themes/THEME/gtk-VERSION/gtk-VARIANT.css`,
/// where `THEME` is the name of the current theme (see the `GtkSettings:gtk`-theme-name
/// setting), VARIANT is the variant to load (see the
/// `GtkSettings:gtk`-application-prefer-dark-theme setting), `DATADIR`
/// is the prefix configured when GTK was compiled (unless overridden by the
/// `GTK_DATA_PREFIX` environment variable), and `VERSION` is the GTK version number.
/// If no file is found for the current version, GTK tries older versions all the
/// way back to 4.0.
open class CssProvider: GLibObject.Object, CssProviderProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CssProvider` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCssProvider>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CssProvider` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCssProvider>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CssProvider` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CssProvider` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CssProvider` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCssProvider>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CssProvider` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCssProvider>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCssProvider`.
    /// i.e., ownership is transferred to the `CssProvider` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCssProvider>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CssProviderProtocol`
    /// Will retain `GtkCssProvider`.
    /// - Parameter other: an instance of a related type that implements `CssProviderProtocol`
    @inlinable public init<T: CssProviderProtocol>(cssProvider other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Returns a newly created `GtkCssProvider`.
    @inlinable public init() {
        let rv = gtk_css_provider_new()
        super.init(gpointer: gpointer(rv))
    }


}

// MARK: no CssProvider properties

public enum CssProviderSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Signals that a parsing error occurred. the `path`, `line` and `position`
    /// describe the actual location of the error as accurately as possible.
    /// 
    /// Parsing errors are never fatal, so the parsing will resume after
    /// the error. Errors may however cause parts of the given
    /// data or even all of it to not be parsed at all. So it is a useful idea
    /// to check that the parsing succeeds by connecting to this signal.
    /// 
    /// Note that this signal may be emitted at any time as the css provider
    /// may opt to defer parsing parts or all of the input to a later time
    /// than when a loading function was called.
    case parsingError = "parsing-error"

}

public extension CssProviderProtocol {
    /// Connect a `CssProviderSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @inlinable @discardableResult func connect(signal kind: CssProviderSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> Int {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> Int {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(raw: ptr).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

// MARK: CssProvider Class: CssProviderProtocol extension (methods and fields)
public extension CssProviderProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCssProvider` instance.
    @inlinable var css_provider_ptr: UnsafeMutablePointer<GtkCssProvider>! { return ptr?.assumingMemoryBound(to: GtkCssProvider.self) }

    /// Loads `data` into `css_provider`, and by doing so clears any previously loaded
    /// information.
    @inlinable func load(from data: UnsafePointer<CChar>!, length: gssize) {
        gtk_css_provider_load_from_data(css_provider_ptr, data, length)
    
    }

    /// Loads the data contained in `file` into `css_provider`, making it
    /// clear any previously loaded information.
    @inlinable func load<FileT: GIO.FileProtocol>(from file: FileT) {
        gtk_css_provider_load_from_file(css_provider_ptr, file.file_ptr)
    
    }

    /// Loads the data contained in `path` into `css_provider`, making it clear
    /// any previously loaded information.
    @inlinable func load(from path: UnsafePointer<CChar>!) {
        gtk_css_provider_load_from_path(css_provider_ptr, path)
    
    }

    /// Loads the data contained in the resource at `resource_path` into
    /// the `GtkCssProvider`, clearing any previously loaded information.
    /// 
    /// To track errors while loading CSS, connect to the
    /// `GtkCssProvider::parsing`-error signal.
    @inlinable func loadFromResource(resourcePath: UnsafePointer<CChar>!) {
        gtk_css_provider_load_from_resource(css_provider_ptr, resourcePath)
    
    }

    /// Loads a theme from the usual theme paths. The actual process of
    /// finding the theme might change between releases, but it is
    /// guaranteed that this function uses the same mechanism to load the
    /// theme that GTK uses for loading its own theme.
    @inlinable func loadNamed(name: UnsafePointer<CChar>!, variant: UnsafePointer<CChar>? = nil) {
        gtk_css_provider_load_named(css_provider_ptr, name, variant)
    
    }

    /// Converts the `provider` into a string representation in CSS
    /// format.
    /// 
    /// Using `gtk_css_provider_load_from_data()` with the return value
    /// from this function on a new provider created with
    /// `gtk_css_provider_new()` will basically create a duplicate of
    /// this `provider`.
    @inlinable func toString() -> String! {
        let rv = gtk_css_provider_to_string(css_provider_ptr).map({ String(cString: $0) })
        return rv
    }

    @inlinable var parentInstance: GObject {
        get {
            let rv = css_provider_ptr.pointee.parent_instance
            return rv
        }
    }

}



// MARK: - CustomFilter Class

/// The `CustomFilterProtocol` protocol exposes the methods and properties of an underlying `GtkCustomFilter` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CustomFilter`.
/// Alternatively, use `CustomFilterRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkCustomFilter` is a `GtkFilter` that uses a callback to determine
/// whether to include an item or not.
public protocol CustomFilterProtocol: FilterProtocol {
        /// Untyped pointer to the underlying `GtkCustomFilter` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCustomFilter` instance.
    var custom_filter_ptr: UnsafeMutablePointer<GtkCustomFilter>! { get }

}

/// The `CustomFilterRef` type acts as a lightweight Swift reference to an underlying `GtkCustomFilter` instance.
/// It exposes methods that can operate on this data type through `CustomFilterProtocol` conformance.
/// Use `CustomFilterRef` only as an `unowned` reference to an existing `GtkCustomFilter` instance.
///
/// `GtkCustomFilter` is a `GtkFilter` that uses a callback to determine
/// whether to include an item or not.
public struct CustomFilterRef: CustomFilterProtocol {
        /// Untyped pointer to the underlying `GtkCustomFilter` instance.
    /// For type-safe access, use the generated, typed pointer `custom_filter_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CustomFilterRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCustomFilter>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCustomFilter>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCustomFilter>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCustomFilter>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CustomFilterProtocol`
    @inlinable init<T: CustomFilterProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new filter using the given `match_func` to filter
    /// items.
    /// 
    /// If `match_func` is `nil`, the filter matches all items.
    /// 
    /// If the filter func changes its filtering behavior,
    /// `gtk_filter_changed()` needs to be called.
    @inlinable init( matchFunc: GtkCustomFilterFunc? = nil, userData: gpointer! = nil, userDestroy: GDestroyNotify?) {
        let rv = gtk_custom_filter_new(matchFunc, userData, userDestroy)
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `CustomFilter` type acts as a reference-counted owner of an underlying `GtkCustomFilter` instance.
/// It provides the methods that can operate on this data type through `CustomFilterProtocol` conformance.
/// Use `CustomFilter` as a strong reference or owner of a `GtkCustomFilter` instance.
///
/// `GtkCustomFilter` is a `GtkFilter` that uses a callback to determine
/// whether to include an item or not.
open class CustomFilter: Filter, CustomFilterProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomFilter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCustomFilter>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomFilter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCustomFilter>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomFilter` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomFilter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomFilter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCustomFilter>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomFilter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCustomFilter>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCustomFilter`.
    /// i.e., ownership is transferred to the `CustomFilter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCustomFilter>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CustomFilterProtocol`
    /// Will retain `GtkCustomFilter`.
    /// - Parameter other: an instance of a related type that implements `CustomFilterProtocol`
    @inlinable public init<T: CustomFilterProtocol>(customFilter other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new filter using the given `match_func` to filter
    /// items.
    /// 
    /// If `match_func` is `nil`, the filter matches all items.
    /// 
    /// If the filter func changes its filtering behavior,
    /// `gtk_filter_changed()` needs to be called.
    @inlinable public init( matchFunc: GtkCustomFilterFunc? = nil, userData: gpointer! = nil, userDestroy: GDestroyNotify?) {
        let rv = gtk_custom_filter_new(matchFunc, userData, userDestroy)
        super.init(gpointer: gpointer(rv))
    }


}

// MARK: no CustomFilter properties

public enum CustomFilterSignalName: String, SignalNameProtocol {
    /// This signal is emitted whenever the filter changed. Users of the filter
    /// should then check items again via `gtk_filter_match()`.
    /// 
    /// `GtkFilterListModel` handles this signal automatically.
    /// 
    /// Depending on the `change` parameter, not all items need to be changed, but
    /// only some. Refer to the `GtkFilterChange` documentation for details.
    case changed = "changed"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"

}

public extension CustomFilterProtocol {
    /// Connect a `CustomFilterSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @inlinable @discardableResult func connect(signal kind: CustomFilterSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> Int {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> Int {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(raw: ptr).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

// MARK: CustomFilter Class: CustomFilterProtocol extension (methods and fields)
public extension CustomFilterProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCustomFilter` instance.
    @inlinable var custom_filter_ptr: UnsafeMutablePointer<GtkCustomFilter>! { return ptr?.assumingMemoryBound(to: GtkCustomFilter.self) }

    /// Sets (or unsets) the function used for filtering items.
    /// 
    /// If `match_func` is `nil`, the filter matches all items.
    /// 
    /// If the filter func changes its filtering behavior,
    /// `gtk_filter_changed()` needs to be called.
    /// 
    /// If a previous function was set, its `user_destroy` will be
    /// called now.
    @inlinable func setFilterFunc(matchFunc: GtkCustomFilterFunc? = nil, userData: gpointer! = nil, userDestroy: GDestroyNotify?) {
        gtk_custom_filter_set_filter_func(custom_filter_ptr, matchFunc, userData, userDestroy)
    
    }


}



// MARK: - CustomLayout Class

/// The `CustomLayoutProtocol` protocol exposes the methods and properties of an underlying `GtkCustomLayout` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CustomLayout`.
/// Alternatively, use `CustomLayoutRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkCustomLayout` is a convenience type meant to be used as a transition
/// mechanism between `GtkWidgets` implementing a layout policy, and
/// `GtkLayoutManager` classes.
/// 
/// A `GtkCustomLayout` uses closures matching to the old `GtkWidget` virtual
/// functions for size negotiation, as a convenience API to ease the porting
/// towards the corresponding `GtkLayoutManager` virtual functions.
public protocol CustomLayoutProtocol: LayoutManagerProtocol {
        /// Untyped pointer to the underlying `GtkCustomLayout` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCustomLayout` instance.
    var custom_layout_ptr: UnsafeMutablePointer<GtkCustomLayout>! { get }

}

/// The `CustomLayoutRef` type acts as a lightweight Swift reference to an underlying `GtkCustomLayout` instance.
/// It exposes methods that can operate on this data type through `CustomLayoutProtocol` conformance.
/// Use `CustomLayoutRef` only as an `unowned` reference to an existing `GtkCustomLayout` instance.
///
/// `GtkCustomLayout` is a convenience type meant to be used as a transition
/// mechanism between `GtkWidgets` implementing a layout policy, and
/// `GtkLayoutManager` classes.
/// 
/// A `GtkCustomLayout` uses closures matching to the old `GtkWidget` virtual
/// functions for size negotiation, as a convenience API to ease the porting
/// towards the corresponding `GtkLayoutManager` virtual functions.
public struct CustomLayoutRef: CustomLayoutProtocol {
        /// Untyped pointer to the underlying `GtkCustomLayout` instance.
    /// For type-safe access, use the generated, typed pointer `custom_layout_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CustomLayoutRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCustomLayout>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCustomLayout>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCustomLayout>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCustomLayout>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CustomLayoutProtocol`
    @inlinable init<T: CustomLayoutProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new legacy layout manager.
    /// 
    /// Legacy layout managers map to the old `GtkWidget` size negotiation
    /// virtual functions, and are meant to be used during the transition
    /// from layout containers to layout manager delegates.
    @inlinable init( requestMode: GtkCustomRequestModeFunc? = nil, measure: GtkCustomMeasureFunc?, allocate: GtkCustomAllocateFunc?) {
        let rv = gtk_custom_layout_new(requestMode, measure, allocate)
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `CustomLayout` type acts as a reference-counted owner of an underlying `GtkCustomLayout` instance.
/// It provides the methods that can operate on this data type through `CustomLayoutProtocol` conformance.
/// Use `CustomLayout` as a strong reference or owner of a `GtkCustomLayout` instance.
///
/// `GtkCustomLayout` is a convenience type meant to be used as a transition
/// mechanism between `GtkWidgets` implementing a layout policy, and
/// `GtkLayoutManager` classes.
/// 
/// A `GtkCustomLayout` uses closures matching to the old `GtkWidget` virtual
/// functions for size negotiation, as a convenience API to ease the porting
/// towards the corresponding `GtkLayoutManager` virtual functions.
open class CustomLayout: LayoutManager, CustomLayoutProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCustomLayout>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCustomLayout>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomLayout` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCustomLayout>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCustomLayout>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCustomLayout`.
    /// i.e., ownership is transferred to the `CustomLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCustomLayout>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CustomLayoutProtocol`
    /// Will retain `GtkCustomLayout`.
    /// - Parameter other: an instance of a related type that implements `CustomLayoutProtocol`
    @inlinable public init<T: CustomLayoutProtocol>(customLayout other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new legacy layout manager.
    /// 
    /// Legacy layout managers map to the old `GtkWidget` size negotiation
    /// virtual functions, and are meant to be used during the transition
    /// from layout containers to layout manager delegates.
    @inlinable public init( requestMode: GtkCustomRequestModeFunc? = nil, measure: GtkCustomMeasureFunc?, allocate: GtkCustomAllocateFunc?) {
        let rv = gtk_custom_layout_new(requestMode, measure, allocate)
        super.init(gpointer: gpointer(rv))
    }


}

// MARK: no CustomLayout properties

public enum CustomLayoutSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"

}

public extension CustomLayoutProtocol {
    /// Connect a `CustomLayoutSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @inlinable @discardableResult func connect(signal kind: CustomLayoutSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> Int {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> Int {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(raw: ptr).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

// MARK: CustomLayout Class: CustomLayoutProtocol extension (methods and fields)
public extension CustomLayoutProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCustomLayout` instance.
    @inlinable var custom_layout_ptr: UnsafeMutablePointer<GtkCustomLayout>! { return ptr?.assumingMemoryBound(to: GtkCustomLayout.self) }



}



// MARK: - CustomSorter Class

/// The `CustomSorterProtocol` protocol exposes the methods and properties of an underlying `GtkCustomSorter` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CustomSorter`.
/// Alternatively, use `CustomSorterRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// GtkCustomSorter is a `GtkSorter` implementation that sorts
/// via a traditional `GCompareDataFunc` callback.
public protocol CustomSorterProtocol: SorterProtocol {
        /// Untyped pointer to the underlying `GtkCustomSorter` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCustomSorter` instance.
    var custom_sorter_ptr: UnsafeMutablePointer<GtkCustomSorter>! { get }

}

/// The `CustomSorterRef` type acts as a lightweight Swift reference to an underlying `GtkCustomSorter` instance.
/// It exposes methods that can operate on this data type through `CustomSorterProtocol` conformance.
/// Use `CustomSorterRef` only as an `unowned` reference to an existing `GtkCustomSorter` instance.
///
/// GtkCustomSorter is a `GtkSorter` implementation that sorts
/// via a traditional `GCompareDataFunc` callback.
public struct CustomSorterRef: CustomSorterProtocol {
        /// Untyped pointer to the underlying `GtkCustomSorter` instance.
    /// For type-safe access, use the generated, typed pointer `custom_sorter_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CustomSorterRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCustomSorter>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCustomSorter>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCustomSorter>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCustomSorter>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CustomSorterProtocol`
    @inlinable init<T: CustomSorterProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkSorter` that works by calling
    /// `sort_func` to compare items.
    /// 
    /// If `sort_func` is `nil`, all items are considered equal.
    @inlinable init( sortFunc: GCompareDataFunc? = nil, userData: gpointer! = nil, userDestroy: GDestroyNotify? = nil) {
        let rv = gtk_custom_sorter_new(sortFunc, userData, userDestroy)
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `CustomSorter` type acts as a reference-counted owner of an underlying `GtkCustomSorter` instance.
/// It provides the methods that can operate on this data type through `CustomSorterProtocol` conformance.
/// Use `CustomSorter` as a strong reference or owner of a `GtkCustomSorter` instance.
///
/// GtkCustomSorter is a `GtkSorter` implementation that sorts
/// via a traditional `GCompareDataFunc` callback.
open class CustomSorter: Sorter, CustomSorterProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomSorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCustomSorter>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomSorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCustomSorter>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomSorter` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomSorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomSorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCustomSorter>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomSorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCustomSorter>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCustomSorter`.
    /// i.e., ownership is transferred to the `CustomSorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCustomSorter>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CustomSorterProtocol`
    /// Will retain `GtkCustomSorter`.
    /// - Parameter other: an instance of a related type that implements `CustomSorterProtocol`
    @inlinable public init<T: CustomSorterProtocol>(customSorter other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkSorter` that works by calling
    /// `sort_func` to compare items.
    /// 
    /// If `sort_func` is `nil`, all items are considered equal.
    @inlinable public init( sortFunc: GCompareDataFunc? = nil, userData: gpointer! = nil, userDestroy: GDestroyNotify? = nil) {
        let rv = gtk_custom_sorter_new(sortFunc, userData, userDestroy)
        super.init(gpointer: gpointer(rv))
    }


}

// MARK: no CustomSorter properties

public enum CustomSorterSignalName: String, SignalNameProtocol {
    /// This signal is emitted whenever the sorter changed. Users of the sorter
    /// should then update the sort order again via `gtk_sorter_compare()`.
    /// 
    /// `GtkSortListModel` handles this signal automatically.
    /// 
    /// Depending on the `change` parameter, it may be possible to update
    /// the sort order without a full resorting. Refer to the `GtkSorterChange`
    /// documentation for details.
    case changed = "changed"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"

}

public extension CustomSorterProtocol {
    /// Connect a `CustomSorterSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @inlinable @discardableResult func connect(signal kind: CustomSorterSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> Int {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> Int {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(raw: ptr).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

// MARK: CustomSorter Class: CustomSorterProtocol extension (methods and fields)
public extension CustomSorterProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCustomSorter` instance.
    @inlinable var custom_sorter_ptr: UnsafeMutablePointer<GtkCustomSorter>! { return ptr?.assumingMemoryBound(to: GtkCustomSorter.self) }

    /// Sets (or unsets) the function used for sorting items.
    /// 
    /// If `sort_func` is `nil`, all items are considered equal.
    /// 
    /// If the sort func changes its sorting behavior,
    /// `gtk_sorter_changed()` needs to be called.
    /// 
    /// If a previous function was set, its `user_destroy` will be
    /// called now.
    @inlinable func set(sortFunc: GCompareDataFunc? = nil, userData: gpointer! = nil, userDestroy: GDestroyNotify?) {
        gtk_custom_sorter_set_sort_func(custom_sorter_ptr, sortFunc, userData, userDestroy)
    
    }


}



// MARK: - Dialog Class

/// The `DialogProtocol` protocol exposes the methods and properties of an underlying `GtkDialog` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `Dialog`.
/// Alternatively, use `DialogRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// Dialog boxes are a convenient way to prompt the user for a small amount
/// of input, e.g. to display a message, ask a question, or anything else
/// that does not require extensive effort on the user’s part.
/// 
/// GTK treats a dialog as a window split vertically. The top section is a
/// `GtkBox`, and is where widgets such as a `GtkLabel` or a `GtkEntry` should
/// be packed. The bottom area is known as the
/// “action area”. This is generally used for
/// packing buttons into the dialog which may perform functions such as
/// cancel, ok, or apply.
/// 
/// `GtkDialog` boxes are created with a call to `gtk_dialog_new()` or
/// `gtk_dialog_new_with_buttons()`. `gtk_dialog_new_with_buttons()` is
/// recommended; it allows you to set the dialog title, some convenient
/// flags, and add simple buttons.
/// 
/// A “modal” dialog (that is, one which freezes the rest of the application
/// from user input), can be created by calling `gtk_window_set_modal()` on the
/// dialog. Use the `GTK_WINDOW()` macro to cast the widget returned from
/// `gtk_dialog_new()` into a `GtkWindow`. When using `gtk_dialog_new_with_buttons()`
/// you can also pass the `GTK_DIALOG_MODAL` flag to make a dialog modal.
/// 
/// If you add buttons to `GtkDialog` using `gtk_dialog_new_with_buttons()`,
/// `gtk_dialog_add_button()`, `gtk_dialog_add_buttons()`, or
/// `gtk_dialog_add_action_widget()`, clicking the button will emit a signal
/// called `GtkDialog::response` with a response ID that you specified. GTK
/// will never assign a meaning to positive response IDs; these are entirely
/// user-defined. But for convenience, you can use the response IDs in the
/// `GtkResponseType` enumeration (these all have values less than zero). If
/// a dialog receives a delete event, the `GtkDialog::response` signal will
/// be emitted with a response ID of `GTK_RESPONSE_DELETE_EVENT`.
/// 
/// For the simple dialog in the following example, in reality you’d probably
/// use `GtkMessageDialog` to save yourself some effort. But you’d need to
/// create the dialog contents manually if you had more than a simple message
/// in the dialog.
/// 
/// An example for simple GtkDialog usage:
/// (C Language Example):
/// ```C
/// // Function to open a dialog box with a message
/// void
/// quick_message (GtkWindow *parent, char *message)
/// {
///  GtkWidget *dialog, *label, *content_area;
///  GtkDialogFlags flags;
/// 
///  // Create the widgets
///  flags = GTK_DIALOG_DESTROY_WITH_PARENT;
///  dialog = gtk_dialog_new_with_buttons ("Message",
///                                        parent,
///                                        flags,
///                                        _("_OK"),
///                                        GTK_RESPONSE_NONE,
///                                        NULL);
///  content_area = gtk_dialog_get_content_area (GTK_DIALOG (dialog));
///  label = gtk_label_new (message);
/// 
///  // Ensure that the dialog box is destroyed when the user responds
/// 
///  g_signal_connect_swapped (dialog,
///                            "response",
///                            G_CALLBACK (gtk_window_destroy),
///                            dialog);
/// 
///  // Add the label, and show everything we’ve added
/// 
///  gtk_box_append (GTK_BOX (content_area), label);
///  gtk_widget_show (dialog);
/// }
/// ```
/// 
/// # GtkDialog as GtkBuildable
/// 
/// The GtkDialog implementation of the `GtkBuildable` interface exposes the
/// `content_area` and `action_area` as internal children with the names
/// “content_area” and “action_area”.
/// 
/// GtkDialog supports a custom <action-widgets> element, which can contain
/// multiple <action-widget> elements. The “response” attribute specifies a
/// numeric response, and the content of the element is the id of widget
/// (which should be a child of the dialogs `action_area`). To mark a response
/// as default, set the “default“ attribute of the <action-widget> element
/// to true.
/// 
/// GtkDialog supports adding action widgets by specifying “action“ as
/// the “type“ attribute of a <child> element. The widget will be added
/// either to the action area or the headerbar of the dialog, depending
/// on the “use-header-bar“ property. The response id has to be associated
/// with the action widget using the <action-widgets> element.
/// 
/// An example of a `GtkDialog` UI definition fragment:
/// ```
/// <object class="GtkDialog" id="dialog1">
///   <child type="action">
///     <object class="GtkButton" id="button_cancel"/>
///   </child>
///   <child type="action">
///     <object class="GtkButton" id="button_ok">
///     </object>
///   </child>
///   <action-widgets>
///     <action-widget response="cancel">button_cancel</action-widget>
///     <action-widget response="ok" default="true">button_ok</action-widget>
///   </action-widgets>
/// </object>
/// ```
/// 
/// # Accessibility
/// 
/// GtkDialog uses the `GTK_ACCESSIBLE_ROLE_DIALOG` role.
public protocol DialogProtocol: WindowProtocol {
        /// Untyped pointer to the underlying `GtkDialog` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkDialog` instance.
    var dialog_ptr: UnsafeMutablePointer<GtkDialog>! { get }

}

/// The `DialogRef` type acts as a lightweight Swift reference to an underlying `GtkDialog` instance.
/// It exposes methods that can operate on this data type through `DialogProtocol` conformance.
/// Use `DialogRef` only as an `unowned` reference to an existing `GtkDialog` instance.
///
/// Dialog boxes are a convenient way to prompt the user for a small amount
/// of input, e.g. to display a message, ask a question, or anything else
/// that does not require extensive effort on the user’s part.
/// 
/// GTK treats a dialog as a window split vertically. The top section is a
/// `GtkBox`, and is where widgets such as a `GtkLabel` or a `GtkEntry` should
/// be packed. The bottom area is known as the
/// “action area”. This is generally used for
/// packing buttons into the dialog which may perform functions such as
/// cancel, ok, or apply.
/// 
/// `GtkDialog` boxes are created with a call to `gtk_dialog_new()` or
/// `gtk_dialog_new_with_buttons()`. `gtk_dialog_new_with_buttons()` is
/// recommended; it allows you to set the dialog title, some convenient
/// flags, and add simple buttons.
/// 
/// A “modal” dialog (that is, one which freezes the rest of the application
/// from user input), can be created by calling `gtk_window_set_modal()` on the
/// dialog. Use the `GTK_WINDOW()` macro to cast the widget returned from
/// `gtk_dialog_new()` into a `GtkWindow`. When using `gtk_dialog_new_with_buttons()`
/// you can also pass the `GTK_DIALOG_MODAL` flag to make a dialog modal.
/// 
/// If you add buttons to `GtkDialog` using `gtk_dialog_new_with_buttons()`,
/// `gtk_dialog_add_button()`, `gtk_dialog_add_buttons()`, or
/// `gtk_dialog_add_action_widget()`, clicking the button will emit a signal
/// called `GtkDialog::response` with a response ID that you specified. GTK
/// will never assign a meaning to positive response IDs; these are entirely
/// user-defined. But for convenience, you can use the response IDs in the
/// `GtkResponseType` enumeration (these all have values less than zero). If
/// a dialog receives a delete event, the `GtkDialog::response` signal will
/// be emitted with a response ID of `GTK_RESPONSE_DELETE_EVENT`.
/// 
/// For the simple dialog in the following example, in reality you’d probably
/// use `GtkMessageDialog` to save yourself some effort. But you’d need to
/// create the dialog contents manually if you had more than a simple message
/// in the dialog.
/// 
/// An example for simple GtkDialog usage:
/// (C Language Example):
/// ```C
/// // Function to open a dialog box with a message
/// void
/// quick_message (GtkWindow *parent, char *message)
/// {
///  GtkWidget *dialog, *label, *content_area;
///  GtkDialogFlags flags;
/// 
///  // Create the widgets
///  flags = GTK_DIALOG_DESTROY_WITH_PARENT;
///  dialog = gtk_dialog_new_with_buttons ("Message",
///                                        parent,
///                                        flags,
///                                        _("_OK"),
///                                        GTK_RESPONSE_NONE,
///                                        NULL);
///  content_area = gtk_dialog_get_content_area (GTK_DIALOG (dialog));
///  label = gtk_label_new (message);
/// 
///  // Ensure that the dialog box is destroyed when the user responds
/// 
///  g_signal_connect_swapped (dialog,
///                            "response",
///                            G_CALLBACK (gtk_window_destroy),
///                            dialog);
/// 
///  // Add the label, and show everything we’ve added
/// 
///  gtk_box_append (GTK_BOX (content_area), label);
///  gtk_widget_show (dialog);
/// }
/// ```
/// 
/// # GtkDialog as GtkBuildable
/// 
/// The GtkDialog implementation of the `GtkBuildable` interface exposes the
/// `content_area` and `action_area` as internal children with the names
/// “content_area” and “action_area”.
/// 
/// GtkDialog supports a custom <action-widgets> element, which can contain
/// multiple <action-widget> elements. The “response” attribute specifies a
/// numeric response, and the content of the element is the id of widget
/// (which should be a child of the dialogs `action_area`). To mark a response
/// as default, set the “default“ attribute of the <action-widget> element
/// to true.
/// 
/// GtkDialog supports adding action widgets by specifying “action“ as
/// the “type“ attribute of a <child> element. The widget will be added
/// either to the action area or the headerbar of the dialog, depending
/// on the “use-header-bar“ property. The response id has to be associated
/// with the action widget using the <action-widgets> element.
/// 
/// An example of a `GtkDialog` UI definition fragment:
/// ```
/// <object class="GtkDialog" id="dialog1">
///   <child type="action">
///     <object class="GtkButton" id="button_cancel"/>
///   </child>
///   <child type="action">
///     <object class="GtkButton" id="button_ok">
///     </object>
///   </child>
///   <action-widgets>
///     <action-widget response="cancel">button_cancel</action-widget>
///     <action-widget response="ok" default="true">button_ok</action-widget>
///   </action-widgets>
/// </object>
/// ```
/// 
/// # Accessibility
/// 
/// GtkDialog uses the `GTK_ACCESSIBLE_ROLE_DIALOG` role.
public struct DialogRef: DialogProtocol {
        /// Untyped pointer to the underlying `GtkDialog` instance.
    /// For type-safe access, use the generated, typed pointer `dialog_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DialogRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkDialog>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkDialog>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkDialog>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkDialog>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DialogProtocol`
    @inlinable init<T: DialogProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DialogProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DialogProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DialogProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DialogProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DialogProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new dialog box.
    /// 
    /// Widgets should not be packed into this `GtkWindow`
    /// directly, but into the `content_area` and `action_area`, as described above.
    @inlinable init() {
        let rv = gtk_dialog_new()
        ptr = UnsafeMutableRawPointer(rv)
    }


    // *** newWithButtons() is not available because it has a varargs (...) parameter!


    // *** newWithButtons() is not available because it has a varargs (...) parameter!

}

/// The `Dialog` type acts as a reference-counted owner of an underlying `GtkDialog` instance.
/// It provides the methods that can operate on this data type through `DialogProtocol` conformance.
/// Use `Dialog` as a strong reference or owner of a `GtkDialog` instance.
///
/// Dialog boxes are a convenient way to prompt the user for a small amount
/// of input, e.g. to display a message, ask a question, or anything else
/// that does not require extensive effort on the user’s part.
/// 
/// GTK treats a dialog as a window split vertically. The top section is a
/// `GtkBox`, and is where widgets such as a `GtkLabel` or a `GtkEntry` should
/// be packed. The bottom area is known as the
/// “action area”. This is generally used for
/// packing buttons into the dialog which may perform functions such as
/// cancel, ok, or apply.
/// 
/// `GtkDialog` boxes are created with a call to `gtk_dialog_new()` or
/// `gtk_dialog_new_with_buttons()`. `gtk_dialog_new_with_buttons()` is
/// recommended; it allows you to set the dialog title, some convenient
/// flags, and add simple buttons.
/// 
/// A “modal” dialog (that is, one which freezes the rest of the application
/// from user input), can be created by calling `gtk_window_set_modal()` on the
/// dialog. Use the `GTK_WINDOW()` macro to cast the widget returned from
/// `gtk_dialog_new()` into a `GtkWindow`. When using `gtk_dialog_new_with_buttons()`
/// you can also pass the `GTK_DIALOG_MODAL` flag to make a dialog modal.
/// 
/// If you add buttons to `GtkDialog` using `gtk_dialog_new_with_buttons()`,
/// `gtk_dialog_add_button()`, `gtk_dialog_add_buttons()`, or
/// `gtk_dialog_add_action_widget()`, clicking the button will emit a signal
/// called `GtkDialog::response` with a response ID that you specified. GTK
/// will never assign a meaning to positive response IDs; these are entirely
/// user-defined. But for convenience, you can use the response IDs in the
/// `GtkResponseType` enumeration (these all have values less than zero). If
/// a dialog receives a delete event, the `GtkDialog::response` signal will
/// be emitted with a response ID of `GTK_RESPONSE_DELETE_EVENT`.
/// 
/// For the simple dialog in the following example, in reality you’d probably
/// use `GtkMessageDialog` to save yourself some effort. But you’d need to
/// create the dialog contents manually if you had more than a simple message
/// in the dialog.
/// 
/// An example for simple GtkDialog usage:
/// (C Language Example):
/// ```C
/// // Function to open a dialog box with a message
/// void
/// quick_message (GtkWindow *parent, char *message)
/// {
///  GtkWidget *dialog, *label, *content_area;
///  GtkDialogFlags flags;
/// 
///  // Create the widgets
///  flags = GTK_DIALOG_DESTROY_WITH_PARENT;
///  dialog = gtk_dialog_new_with_buttons ("Message",
///                                        parent,
///                                        flags,
///                                        _("_OK"),
///                                        GTK_RESPONSE_NONE,
///                                        NULL);
///  content_area = gtk_dialog_get_content_area (GTK_DIALOG (dialog));
///  label = gtk_label_new (message);
/// 
///  // Ensure that the dialog box is destroyed when the user responds
/// 
///  g_signal_connect_swapped (dialog,
///                            "response",
///                            G_CALLBACK (gtk_window_destroy),
///                            dialog);
/// 
///  // Add the label, and show everything we’ve added
/// 
///  gtk_box_append (GTK_BOX (content_area), label);
///  gtk_widget_show (dialog);
/// }
/// ```
/// 
/// # GtkDialog as GtkBuildable
/// 
/// The GtkDialog implementation of the `GtkBuildable` interface exposes the
/// `content_area` and `action_area` as internal children with the names
/// “content_area” and “action_area”.
/// 
/// GtkDialog supports a custom <action-widgets> element, which can contain
/// multiple <action-widget> elements. The “response” attribute specifies a
/// numeric response, and the content of the element is the id of widget
/// (which should be a child of the dialogs `action_area`). To mark a response
/// as default, set the “default“ attribute of the <action-widget> element
/// to true.
/// 
/// GtkDialog supports adding action widgets by specifying “action“ as
/// the “type“ attribute of a <child> element. The widget will be added
/// either to the action area or the headerbar of the dialog, depending
/// on the “use-header-bar“ property. The response id has to be associated
/// with the action widget using the <action-widgets> element.
/// 
/// An example of a `GtkDialog` UI definition fragment:
/// ```
/// <object class="GtkDialog" id="dialog1">
///   <child type="action">
///     <object class="GtkButton" id="button_cancel"/>
///   </child>
///   <child type="action">
///     <object class="GtkButton" id="button_ok">
///     </object>
///   </child>
///   <action-widgets>
///     <action-widget response="cancel">button_cancel</action-widget>
///     <action-widget response="ok" default="true">button_ok</action-widget>
///   </action-widgets>
/// </object>
/// ```
/// 
/// # Accessibility
/// 
/// GtkDialog uses the `GTK_ACCESSIBLE_ROLE_DIALOG` role.
open class Dialog: Window, DialogProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Dialog` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkDialog>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Dialog` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkDialog>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Dialog` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Dialog` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Dialog` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkDialog>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Dialog` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkDialog>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkDialog`.
    /// i.e., ownership is transferred to the `Dialog` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkDialog>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `DialogProtocol`
    /// Will retain `GtkDialog`.
    /// - Parameter other: an instance of a related type that implements `DialogProtocol`
    @inlinable public init<T: DialogProtocol>(dialog other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DialogProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DialogProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DialogProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DialogProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DialogProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DialogProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DialogProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DialogProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new dialog box.
    /// 
    /// Widgets should not be packed into this `GtkWindow`
    /// directly, but into the `content_area` and `action_area`, as described above.
    @inlinable override public init() {
        let rv = gtk_dialog_new()
        super.init(gpointer: gpointer(rv))
    }


    // *** newWithButtons() is not available because it has a varargs (...) parameter!



    // *** newWithButtons() is not available because it has a varargs (...) parameter!


}

public enum DialogPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    /// The `GtkApplication` associated with the window.
    /// 
    /// The application will be kept alive for at least as long as it
    /// has any windows associated with it (see `g_application_hold()`
    /// for a way to keep it alive without windows).
    /// 
    /// Normally, the connection between the application and the window
    /// will remain until the window is destroyed, but you can explicitly
    /// remove it by setting the :application property to `nil`.
    case application = "application"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    case canTarget = "can-target"
    case child = "child"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`. See `gtk_widget_set_cursor()` for details.
    case cursor = "cursor"
    /// Whether the window should be decorated by the window manager.
    case decorated = "decorated"
    case defaultHeight = "default-height"
    case defaultWidget = "default-widget"
    case defaultWidth = "default-width"
    /// Whether the window frame should have a close button.
    case deletable = "deletable"
    case destroyWithParent = "destroy-with-parent"
    case display = "display"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether 'focus rectangles' are currently visible in this window.
    /// 
    /// This property is maintained by GTK based on user input
    /// and should not be set by applications.
    case focusVisible = "focus-visible"
    case focusWidget = "focus-widget"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// Whether the window is fullscreen.
    /// 
    /// Setting this property is the equivalent of calling `gtk_window_fullscreen()`
    /// and `gtk_window_unfullscreen()`; either operation is asynchronous, which
    /// means you will need to connect to the `GObject::notify` signal in order to
    /// know whether the operation was successful.
    case fullscreened = "fullscreened"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    case hideOnClose = "hide-on-close"
    /// The :icon-name property specifies the name of the themed icon to
    /// use as the window icon. See `GtkIconTheme` for more details.
    case iconName = "icon-name"
    case isActive = "is-active"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    /// Whether the window is maximized.
    /// 
    /// Setting this property is the equivalent of calling `gtk_window_maximize()`
    /// and `gtk_window_unmaximize()`; either operation is asynchronous, which
    /// means you will need to connect to the `GObject::notify` signal in order to
    /// know whether the operation was successful.
    case maximized = "maximized"
    /// Whether mnemonics are currently visible in this window.
    /// 
    /// This property is maintained by GTK based on user input,
    /// and should not be set by applications.
    case mnemonicsVisible = "mnemonics-visible"
    case modal = "modal"
    case name = "name"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    case parent = "parent"
    case receivesDefault = "receives-default"
    case resizable = "resizable"
    /// The `GtkRoot` widget of the widget tree containing this widget or `nil` if
    /// the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    /// The :startup-id is a write-only property for setting window's
    /// startup notification identifier. See `gtk_window_set_startup_id()`
    /// for more details.
    case startupId = "startup-id"
    case title = "title"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// The transient parent of the window. See `gtk_window_set_transient_for()` for
    /// more details about transient windows.
    case transientFor = "transient-for"
    /// `true` if the dialog uses a `GtkHeaderBar` for action buttons
    /// instead of the action-area.
    /// 
    /// For technical reasons, this property is declared as an integer
    /// property, but you should only set it to `true` or `false`.
    case useHeaderBar = "use-header-bar"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
}

public extension DialogProtocol {
    /// Bind a `DialogPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: DialogPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a Dialog property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: DialogPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a Dialog property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: DialogPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum DialogSignalName: String, SignalNameProtocol {
    /// The `activate`-default signal is a
    /// [keybinding signal](#GtkSignalAction)
    /// which gets emitted when the user activates the default widget
    /// of `window`.
    case activateDefault = "activate-default"
    /// The `activate`-focus signal is a
    /// [keybinding signal](#GtkSignalAction)
    /// which gets emitted when the user activates the currently
    /// focused widget of `window`.
    case activateFocus = "activate-focus"
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// The `close` signal is a
    /// [keybinding signal](#GtkSignalAction)
    /// which gets emitted when the user uses a keybinding to close
    /// the dialog.
    /// 
    /// The default binding for this signal is the Escape key.
    case close = "close"
    /// The `close`-request signal is emitted when the user clicks on the close
    /// button of the window.
    case closeRequest = "close-request"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold. May result in finalization of the widget
    /// if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// The `direction`-changed signal is emitted when the text direction
    /// of a widget changes.
    case directionChanged = "direction-changed"
    /// The `enable`-debugging signal is a [keybinding signal](#GtkSignalAction)
    /// which gets emitted when the user enables or disables interactive
    /// debugging. When `toggle` is `true`, interactive debugging is toggled
    /// on or off, when it is `false`, the debugger will be pointed at the
    /// widget under the pointer.
    /// 
    /// The default bindings for this signal are Ctrl-Shift-I
    /// and Ctrl-Shift-D.
    case enableDebugging = "enable-debugging"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The `hide` signal is emitted when `widget` is hidden, for example with
    /// `gtk_widget_hide()`.
    case hide = "hide"
    /// Gets emitted if keyboard navigation fails.
    /// See `gtk_widget_keynav_failed()` for details.
    case keynavFailed = "keynav-failed"
    /// The `keys`-changed signal gets emitted when the set of accelerators
    /// or mnemonics that are associated with `window` changes.
    case keysChanged = "keys-changed"
    /// The `map` signal is emitted when `widget` is going to be mapped, that is
    /// when the widget is visible (which is controlled with
    /// `gtk_widget_set_visible()`) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of `GtkWidget::unmap`.
    case map = "map"
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// Emitted when `GtkWidget:has`-tooltip is `true` and the hover timeout
    /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
    /// focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// The `realize` signal is emitted when `widget` is associated with a
    /// `GdkSurface`, which means that `gtk_widget_realize()` has been called or the
    /// widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when an action widget is clicked, the dialog receives a
    /// delete event, or the application programmer calls `gtk_dialog_response()`.
    /// On a delete event, the response ID is `GTK_RESPONSE_DELETE_EVENT`.
    /// Otherwise, it depends on which action widget was clicked.
    case response = "response"
    /// The `show` signal is emitted when `widget` is shown, for example with
    /// `gtk_widget_show()`.
    case show = "show"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The `state`-flags-changed signal is emitted when the widget state
    /// changes, see `gtk_widget_get_state_flags()`.
    case stateFlagsChanged = "state-flags-changed"
    /// The `unmap` signal is emitted when `widget` is going to be unmapped, which
    /// means that either it or any of its parents up to the toplevel widget have
    /// been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer, it can be
    /// used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// The `unrealize` signal is emitted when the `GdkSurface` associated with
    /// `widget` is destroyed, which means that `gtk_widget_unrealize()` has been
    /// called or the widget has been unmapped (that is, it is going to be
    /// hidden).
    case unrealize = "unrealize"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    /// The `GtkApplication` associated with the window.
    /// 
    /// The application will be kept alive for at least as long as it
    /// has any windows associated with it (see `g_application_hold()`
    /// for a way to keep it alive without windows).
    /// 
    /// Normally, the connection between the application and the window
    /// will remain until the window is destroyed, but you can explicitly
    /// remove it by setting the :application property to `nil`.
    case notifyApplication = "notify::application"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    case notifyCanTarget = "notify::can-target"
    case notifyChild = "notify::child"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`. See `gtk_widget_set_cursor()` for details.
    case notifyCursor = "notify::cursor"
    /// Whether the window should be decorated by the window manager.
    case notifyDecorated = "notify::decorated"
    case notifyDefaultHeight = "notify::default-height"
    case notifyDefaultWidget = "notify::default-widget"
    case notifyDefaultWidth = "notify::default-width"
    /// Whether the window frame should have a close button.
    case notifyDeletable = "notify::deletable"
    case notifyDestroyWithParent = "notify::destroy-with-parent"
    case notifyDisplay = "notify::display"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether 'focus rectangles' are currently visible in this window.
    /// 
    /// This property is maintained by GTK based on user input
    /// and should not be set by applications.
    case notifyFocusVisible = "notify::focus-visible"
    case notifyFocusWidget = "notify::focus-widget"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// Whether the window is fullscreen.
    /// 
    /// Setting this property is the equivalent of calling `gtk_window_fullscreen()`
    /// and `gtk_window_unfullscreen()`; either operation is asynchronous, which
    /// means you will need to connect to the `GObject::notify` signal in order to
    /// know whether the operation was successful.
    case notifyFullscreened = "notify::fullscreened"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case notifyHalign = "notify::halign"
    case notifyHasDefault = "notify::has-default"
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case notifyHexpandSet = "notify::hexpand-set"
    case notifyHideOnClose = "notify::hide-on-close"
    /// The :icon-name property specifies the name of the themed icon to
    /// use as the window icon. See `GtkIconTheme` for more details.
    case notifyIconName = "notify::icon-name"
    case notifyIsActive = "notify::is-active"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginTop = "notify::margin-top"
    /// Whether the window is maximized.
    /// 
    /// Setting this property is the equivalent of calling `gtk_window_maximize()`
    /// and `gtk_window_unmaximize()`; either operation is asynchronous, which
    /// means you will need to connect to the `GObject::notify` signal in order to
    /// know whether the operation was successful.
    case notifyMaximized = "notify::maximized"
    /// Whether mnemonics are currently visible in this window.
    /// 
    /// This property is maintained by GTK based on user input,
    /// and should not be set by applications.
    case notifyMnemonicsVisible = "notify::mnemonics-visible"
    case notifyModal = "notify::modal"
    case notifyName = "notify::name"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    case notifyParent = "notify::parent"
    case notifyReceivesDefault = "notify::receives-default"
    case notifyResizable = "notify::resizable"
    /// The `GtkRoot` widget of the widget tree containing this widget or `nil` if
    /// the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case notifyScaleFactor = "notify::scale-factor"
    case notifySensitive = "notify::sensitive"
    /// The :startup-id is a write-only property for setting window's
    /// startup notification identifier. See `gtk_window_set_startup_id()`
    /// for more details.
    case notifyStartupId = "notify::startup-id"
    case notifyTitle = "notify::title"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// The transient parent of the window. See `gtk_window_set_transient_for()` for
    /// more details about transient windows.
    case notifyTransientFor = "notify::transient-for"
    /// `true` if the dialog uses a `GtkHeaderBar` for action buttons
    /// instead of the action-area.
    /// 
    /// For technical reasons, this property is declared as an integer
    /// property, but you should only set it to `true` or `false`.
    case notifyUseHeaderBar = "notify::use-header-bar"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case notifyValign = "notify::valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case notifyVexpandSet = "notify::vexpand-set"
    case notifyVisible = "notify::visible"
    case notifyWidthRequest = "notify::width-request"
}

public extension DialogProtocol {
    /// Connect a `DialogSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @inlinable @discardableResult func connect(signal kind: DialogSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> Int {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> Int {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(raw: ptr).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

// MARK: Dialog Class: DialogProtocol extension (methods and fields)
public extension DialogProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkDialog` instance.
    @inlinable var dialog_ptr: UnsafeMutablePointer<GtkDialog>! { return ptr?.assumingMemoryBound(to: GtkDialog.self) }

    /// Adds an activatable widget to the action area of a `GtkDialog`,
    /// connecting a signal handler that will emit the `GtkDialog::response`
    /// signal on the dialog when the widget is activated. The widget is
    /// appended to the end of the dialog’s action area. If you want to add a
    /// non-activatable widget, simply pack it into the `action_area` field
    /// of the `GtkDialog` struct.
    @inlinable func addActionWidget<WidgetT: WidgetProtocol>(child: WidgetT, responseId: Int) {
        gtk_dialog_add_action_widget(dialog_ptr, child.widget_ptr, gint(responseId))
    
    }

    /// Adds a button with the given text and sets things up so that
    /// clicking the button will emit the `GtkDialog::response` signal with
    /// the given `response_id`. The button is appended to the end of the
    /// dialog’s action area. The button widget is returned, but usually
    /// you don’t need it.
    @inlinable func addButton(buttonText: UnsafePointer<CChar>!, responseId: Int) -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_dialog_add_button(dialog_ptr, buttonText, gint(responseId)))) else { return nil }
        return rv
    }


    // *** addButtons() is not available because it has a varargs (...) parameter!


    /// Returns the content area of `dialog`.
    @inlinable func getContentArea() -> BoxRef! {
        let rv = BoxRef(gconstpointer: gconstpointer(gtk_dialog_get_content_area(dialog_ptr)))
        return rv
    }

    /// Returns the header bar of `dialog`. Note that the
    /// headerbar is only used by the dialog if the
    /// `GtkDialog:use`-header-bar property is `true`.
    @inlinable func getHeaderBar() -> HeaderBarRef! {
        let rv = HeaderBarRef(gconstpointer: gconstpointer(gtk_dialog_get_header_bar(dialog_ptr)))
        return rv
    }

    /// Gets the response id of a widget in the action area
    /// of a dialog.
    @inlinable func getResponseFor<WidgetT: WidgetProtocol>(widget: WidgetT) -> Int {
        let rv = Int(gtk_dialog_get_response_for_widget(dialog_ptr, widget.widget_ptr))
        return rv
    }

    /// Gets the widget button that uses the given response ID in the action area
    /// of a dialog.
    @inlinable func getWidgetForResponse(responseId: Int) -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_dialog_get_widget_for_response(dialog_ptr, gint(responseId)))) else { return nil }
        return rv
    }

    /// Emits the `GtkDialog::response` signal with the given response ID.
    /// 
    /// Used to indicate that the user has responded to the dialog in some way.
    @inlinable func response(responseId: Int) {
        gtk_dialog_response(dialog_ptr, gint(responseId))
    
    }

    /// Sets the last widget in the dialog’s action area with the given `response_id`
    /// as the default widget for the dialog. Pressing “Enter” normally activates
    /// the default widget.
    @inlinable func setDefaultResponse(responseId: Int) {
        gtk_dialog_set_default_response(dialog_ptr, gint(responseId))
    
    }

    /// Calls `gtk_widget_set_sensitive (widget, `setting`)`
    /// for each widget in the dialog’s action area with the given `response_id`.
    /// A convenient way to sensitize/desensitize dialog buttons.
    @inlinable func setResponseSensitive(responseId: Int, setting: Bool) {
        gtk_dialog_set_response_sensitive(dialog_ptr, gint(responseId), gboolean((setting) ? 1 : 0))
    
    }
    /// Returns the content area of `dialog`.
    @inlinable var contentArea: BoxRef! {
        /// Returns the content area of `dialog`.
        get {
            let rv = BoxRef(gconstpointer: gconstpointer(gtk_dialog_get_content_area(dialog_ptr)))
            return rv
        }
    }

    /// Returns the header bar of `dialog`. Note that the
    /// headerbar is only used by the dialog if the
    /// `GtkDialog:use`-header-bar property is `true`.
    @inlinable var headerBar: HeaderBarRef! {
        /// Returns the header bar of `dialog`. Note that the
        /// headerbar is only used by the dialog if the
        /// `GtkDialog:use`-header-bar property is `true`.
        get {
            let rv = HeaderBarRef(gconstpointer: gconstpointer(gtk_dialog_get_header_bar(dialog_ptr)))
            return rv
        }
    }

    @inlinable var parentInstance: GtkWindow {
        get {
            let rv = dialog_ptr.pointee.parent_instance
            return rv
        }
    }

}



