import CGLib
import CCairo
import CPango
import CGdkPixbuf
import CGdk
import CGtk
import GLib
import GLibObject
import GIO
import Pango
import Cairo
import PangoCairo
import GdkPixbuf
import Gdk

// MARK: - ScaleButton Class

/// The `ScaleButtonProtocol` protocol exposes the methods and properties of an underlying `GtkScaleButton` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ScaleButton`.
/// Alternatively, use `ScaleButtonRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkScaleButton` provides a button which pops up a scale widget.
/// This kind of widget is commonly used for volume controls in multimedia
/// applications, and GTK provides a `GtkVolumeButton` subclass that
/// is tailored for this use case.
/// 
/// # CSS nodes
/// 
/// GtkScaleButton has a single CSS node with name button. To differentiate
/// it from a plain `GtkButton`, it gets the .scale style class.
public protocol ScaleButtonProtocol: WidgetProtocol, OrientableProtocol {
        /// Untyped pointer to the underlying `GtkScaleButton` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkScaleButton` instance.
    var scale_button_ptr: UnsafeMutablePointer<GtkScaleButton>! { get }

}

/// The `ScaleButtonRef` type acts as a lightweight Swift reference to an underlying `GtkScaleButton` instance.
/// It exposes methods that can operate on this data type through `ScaleButtonProtocol` conformance.
/// Use `ScaleButtonRef` only as an `unowned` reference to an existing `GtkScaleButton` instance.
///
/// `GtkScaleButton` provides a button which pops up a scale widget.
/// This kind of widget is commonly used for volume controls in multimedia
/// applications, and GTK provides a `GtkVolumeButton` subclass that
/// is tailored for this use case.
/// 
/// # CSS nodes
/// 
/// GtkScaleButton has a single CSS node with name button. To differentiate
/// it from a plain `GtkButton`, it gets the .scale style class.
public struct ScaleButtonRef: ScaleButtonProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkScaleButton` instance.
    /// For type-safe access, use the generated, typed pointer `scale_button_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ScaleButtonRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkScaleButton>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkScaleButton>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkScaleButton>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkScaleButton>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ScaleButtonProtocol`
    @inlinable init<T: ScaleButtonProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ScaleButtonProtocol>(_ other: T) -> ScaleButtonRef { ScaleButtonRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScaleButtonProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScaleButtonProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScaleButtonProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScaleButtonProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScaleButtonProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a `GtkScaleButton`, with a range between `min` and `max`, with
    /// a stepping of `step`.
    @inlinable init( min: CDouble, max: CDouble, step: CDouble, icons: UnsafeMutablePointer<UnsafePointer<CChar>?>! = nil) {
        let rv = gtk_scale_button_new(min, max, step, icons)
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `ScaleButton` type acts as a reference-counted owner of an underlying `GtkScaleButton` instance.
/// It provides the methods that can operate on this data type through `ScaleButtonProtocol` conformance.
/// Use `ScaleButton` as a strong reference or owner of a `GtkScaleButton` instance.
///
/// `GtkScaleButton` provides a button which pops up a scale widget.
/// This kind of widget is commonly used for volume controls in multimedia
/// applications, and GTK provides a `GtkVolumeButton` subclass that
/// is tailored for this use case.
/// 
/// # CSS nodes
/// 
/// GtkScaleButton has a single CSS node with name button. To differentiate
/// it from a plain `GtkButton`, it gets the .scale style class.
open class ScaleButton: Widget, ScaleButtonProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ScaleButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkScaleButton>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ScaleButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkScaleButton>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ScaleButton` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ScaleButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ScaleButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkScaleButton>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ScaleButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkScaleButton>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkScaleButton`.
    /// i.e., ownership is transferred to the `ScaleButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkScaleButton>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ScaleButtonProtocol`
    /// Will retain `GtkScaleButton`.
    /// - Parameter other: an instance of a related type that implements `ScaleButtonProtocol`
    @inlinable public init<T: ScaleButtonProtocol>(scaleButton other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScaleButtonProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScaleButtonProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScaleButtonProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScaleButtonProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScaleButtonProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScaleButtonProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScaleButtonProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScaleButtonProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a `GtkScaleButton`, with a range between `min` and `max`, with
    /// a stepping of `step`.
    @inlinable public init( min: CDouble, max: CDouble, step: CDouble, icons: UnsafeMutablePointer<UnsafePointer<CChar>?>! = nil) {
        let rv = gtk_scale_button_new(min, max, step, icons)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum ScaleButtonPropertyName: String, PropertyNameProtocol {
    case adjustment = "adjustment"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`. See `gtk_widget_set_cursor()` for details.
    case cursor = "cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    /// The names of the icons to be used by the scale button.
    /// The first item in the array will be used in the button
    /// when the current value is the lowest value, the second
    /// item for the highest value. All the subsequent icons will
    /// be used for all the other values, spread evenly over the
    /// range of values.
    /// 
    /// If there's only one icon name in the `icons` array, it will
    /// be used for all the values. If only two icon names are in
    /// the `icons` array, the first one will be used for the bottom
    /// 50% of the scale, and the second one for the top 50%.
    /// 
    /// It is recommended to use at least 3 icons so that the
    /// `GtkScaleButton` reflects the current value of the scale
    /// better for the users.
    case icons = "icons"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case name = "name"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    case parent = "parent"
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget or `nil` if
    /// the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    case value = "value"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
}

public extension ScaleButtonProtocol {
    /// Bind a `ScaleButtonPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ScaleButtonPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ScaleButton property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ScaleButtonPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ScaleButton property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ScaleButtonPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

// MARK: Signals of ScaleButton
public extension ScaleButtonProtocol {
    /// The `popdown` signal is a
    /// [keybinding signal](#GtkSignalAction)
    /// which gets emitted to popdown the scale widget.
    /// 
    /// The default binding for this signal is Escape.
    /// - Note: Representation of signal named `popdown`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    @discardableResult
    func onPopdown(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScaleButtonRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<ScaleButtonRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScaleButtonRef(raw: unownedSelf))
            return output
        }
        return signalConnectData(
            detailedSignal: "popdown", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The `popup` signal is a
    /// [keybinding signal](#GtkSignalAction)
    /// which gets emitted to popup the scale widget.
    /// 
    /// The default bindings for this signal are Space, Enter and Return.
    /// - Note: Representation of signal named `popup`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    @discardableResult
    func onPopup(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScaleButtonRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<ScaleButtonRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScaleButtonRef(raw: unownedSelf))
            return output
        }
        return signalConnectData(
            detailedSignal: "popup", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The `value`-changed signal is emitted when the value field has
    /// changed.
    /// - Note: Representation of signal named `value-changed`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter value: the new value
    @discardableResult
    func onValueChanged(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScaleButtonRef, _ value: Double) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScaleButtonRef, Double, Void>
        let cCallback: @convention(c) (gpointer, gdouble, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScaleButtonRef(raw: unownedSelf), Double(arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "value-changed", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::adjustment`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyAdjustment(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScaleButtonRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScaleButtonRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScaleButtonRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::adjustment", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::icons`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyIcons(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScaleButtonRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScaleButtonRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScaleButtonRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::icons", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::value`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyValue(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScaleButtonRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScaleButtonRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScaleButtonRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::value", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
}

// MARK: ScaleButton Class: ScaleButtonProtocol extension (methods and fields)
public extension ScaleButtonProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkScaleButton` instance.
    @inlinable var scale_button_ptr: UnsafeMutablePointer<GtkScaleButton>! { return ptr?.assumingMemoryBound(to: GtkScaleButton.self) }

    /// Gets the `GtkAdjustment` associated with the `GtkScaleButton`’s scale.
    /// See `gtk_range_get_adjustment()` for details.
    @inlinable func getAdjustment() -> AdjustmentRef! {
        let rv = AdjustmentRef(gconstpointer: gconstpointer(gtk_scale_button_get_adjustment(scale_button_ptr)))
        return rv
    }

    /// Retrieves the minus button of the `GtkScaleButton`.
    @inlinable func getMinusButton() -> ButtonRef! {
        let rv = ButtonRef(gconstpointer: gconstpointer(gtk_scale_button_get_minus_button(scale_button_ptr)))
        return rv
    }

    /// Retrieves the plus button of the `GtkScaleButton`.
    @inlinable func getPlusButton() -> ButtonRef! {
        let rv = ButtonRef(gconstpointer: gconstpointer(gtk_scale_button_get_plus_button(scale_button_ptr)))
        return rv
    }

    /// Retrieves the popup of the `GtkScaleButton`.
    @inlinable func getPopup() -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_scale_button_get_popup(scale_button_ptr))) else { return nil }
        return rv
    }

    /// Gets the current value of the scale button.
    @inlinable func getValue() -> CDouble {
        let rv = gtk_scale_button_get_value(scale_button_ptr)
        return rv
    }

    /// Sets the `GtkAdjustment` to be used as a model
    /// for the `GtkScaleButton`’s scale.
    /// See `gtk_range_set_adjustment()` for details.
    @inlinable func set<AdjustmentT: AdjustmentProtocol>(adjustment: AdjustmentT) {
        gtk_scale_button_set_adjustment(scale_button_ptr, adjustment.adjustment_ptr)
    
    }

    /// Sets the icons to be used by the scale button.
    /// For details, see the `GtkScaleButton:icons` property.
    @inlinable func set(icons: UnsafeMutablePointer<UnsafePointer<CChar>?>!) {
        gtk_scale_button_set_icons(scale_button_ptr, icons)
    
    }

    /// Sets the current value of the scale; if the value is outside
    /// the minimum or maximum range values, it will be clamped to fit
    /// inside them. The scale button emits the `GtkScaleButton::value`-changed
    /// signal if the value changes.
    @inlinable func set(value: CDouble) {
        gtk_scale_button_set_value(scale_button_ptr, value)
    
    }
    @inlinable var adjustment: AdjustmentRef! {
        /// Gets the `GtkAdjustment` associated with the `GtkScaleButton`’s scale.
        /// See `gtk_range_get_adjustment()` for details.
        get {
            let rv = AdjustmentRef(gconstpointer: gconstpointer(gtk_scale_button_get_adjustment(scale_button_ptr)))
            return rv
        }
        /// Sets the `GtkAdjustment` to be used as a model
        /// for the `GtkScaleButton`’s scale.
        /// See `gtk_range_set_adjustment()` for details.
        nonmutating set {
            gtk_scale_button_set_adjustment(scale_button_ptr, UnsafeMutablePointer<GtkAdjustment>(newValue?.adjustment_ptr))
        }
    }

    /// Retrieves the minus button of the `GtkScaleButton`.
    @inlinable var minusButton: ButtonRef! {
        /// Retrieves the minus button of the `GtkScaleButton`.
        get {
            let rv = ButtonRef(gconstpointer: gconstpointer(gtk_scale_button_get_minus_button(scale_button_ptr)))
            return rv
        }
    }

    /// Retrieves the plus button of the `GtkScaleButton`.
    @inlinable var plusButton: ButtonRef! {
        /// Retrieves the plus button of the `GtkScaleButton`.
        get {
            let rv = ButtonRef(gconstpointer: gconstpointer(gtk_scale_button_get_plus_button(scale_button_ptr)))
            return rv
        }
    }

    /// Retrieves the popup of the `GtkScaleButton`.
    @inlinable var popup: WidgetRef! {
        /// Retrieves the popup of the `GtkScaleButton`.
        get {
            guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_scale_button_get_popup(scale_button_ptr))) else { return nil }
            return rv
        }
    }

    @inlinable var value: CDouble {
        /// Gets the current value of the scale button.
        get {
            let rv = gtk_scale_button_get_value(scale_button_ptr)
            return rv
        }
        /// Sets the current value of the scale; if the value is outside
        /// the minimum or maximum range values, it will be clamped to fit
        /// inside them. The scale button emits the `GtkScaleButton::value`-changed
        /// signal if the value changes.
        nonmutating set {
            gtk_scale_button_set_value(scale_button_ptr, newValue)
        }
    }

    @inlinable var parentInstance: GtkWidget {
        get {
            let rv = scale_button_ptr.pointee.parent_instance
            return rv
        }
    }

}



// MARK: - Scrollbar Class

/// The `ScrollbarProtocol` protocol exposes the methods and properties of an underlying `GtkScrollbar` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `Scrollbar`.
/// Alternatively, use `ScrollbarRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// The `GtkScrollbar` widget is a horizontal or vertical scrollbar,
/// depending on the value of the `GtkOrientable:orientation` property.
/// 
/// Its position and movement are controlled by the adjustment that is passed to
/// or created by `gtk_scrollbar_new()`. See `GtkAdjustment` for more details. The
/// `GtkAdjustment:value` field sets the position of the thumb and must be between
/// `GtkAdjustment:lower` and `GtkAdjustment:upper` - `GtkAdjustment:page`-size. The
/// `GtkAdjustment:page`-size represents the size of the visible scrollable area.
/// The fields `GtkAdjustment:step`-increment and `GtkAdjustment:page`-increment
/// fields are added to or subtracted from the `GtkAdjustment:value` when the user
/// asks to move by a step (using e.g. the cursor arrow keys) or by a page (using
/// e.g. the Page Down/Up keys).
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// scrollbar
/// ╰── range[.fine-tune]
///     ╰── trough
///         ╰── slider
/// ```
/// 
/// GtkScrollbar has a main CSS node with name scrollbar and a subnode for its
/// contents. The main node gets the .horizontal or .vertical
/// style classes applied, depending on the scrollbar's orientation.
/// 
/// The range node gets the style class .fine-tune added when the scrollbar is
/// in 'fine-tuning' mode.
/// 
/// Other style classes that may be added to scrollbars inside `GtkScrolledWindow`
/// include the positional classes (.left, .right, .top, .bottom) and style
/// classes related to overlay scrolling (.overlay-indicator, .dragging, .hovering).
/// 
/// # Accessibility
/// 
/// GtkScrollbar uses the `GTK_ACCESSIBLE_ROLE_SCROLLBAR` role.
public protocol ScrollbarProtocol: WidgetProtocol, OrientableProtocol {
        /// Untyped pointer to the underlying `GtkScrollbar` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkScrollbar` instance.
    var scrollbar_ptr: UnsafeMutablePointer<GtkScrollbar>! { get }

}

/// The `ScrollbarRef` type acts as a lightweight Swift reference to an underlying `GtkScrollbar` instance.
/// It exposes methods that can operate on this data type through `ScrollbarProtocol` conformance.
/// Use `ScrollbarRef` only as an `unowned` reference to an existing `GtkScrollbar` instance.
///
/// The `GtkScrollbar` widget is a horizontal or vertical scrollbar,
/// depending on the value of the `GtkOrientable:orientation` property.
/// 
/// Its position and movement are controlled by the adjustment that is passed to
/// or created by `gtk_scrollbar_new()`. See `GtkAdjustment` for more details. The
/// `GtkAdjustment:value` field sets the position of the thumb and must be between
/// `GtkAdjustment:lower` and `GtkAdjustment:upper` - `GtkAdjustment:page`-size. The
/// `GtkAdjustment:page`-size represents the size of the visible scrollable area.
/// The fields `GtkAdjustment:step`-increment and `GtkAdjustment:page`-increment
/// fields are added to or subtracted from the `GtkAdjustment:value` when the user
/// asks to move by a step (using e.g. the cursor arrow keys) or by a page (using
/// e.g. the Page Down/Up keys).
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// scrollbar
/// ╰── range[.fine-tune]
///     ╰── trough
///         ╰── slider
/// ```
/// 
/// GtkScrollbar has a main CSS node with name scrollbar and a subnode for its
/// contents. The main node gets the .horizontal or .vertical
/// style classes applied, depending on the scrollbar's orientation.
/// 
/// The range node gets the style class .fine-tune added when the scrollbar is
/// in 'fine-tuning' mode.
/// 
/// Other style classes that may be added to scrollbars inside `GtkScrolledWindow`
/// include the positional classes (.left, .right, .top, .bottom) and style
/// classes related to overlay scrolling (.overlay-indicator, .dragging, .hovering).
/// 
/// # Accessibility
/// 
/// GtkScrollbar uses the `GTK_ACCESSIBLE_ROLE_SCROLLBAR` role.
public struct ScrollbarRef: ScrollbarProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkScrollbar` instance.
    /// For type-safe access, use the generated, typed pointer `scrollbar_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ScrollbarRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkScrollbar>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkScrollbar>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkScrollbar>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkScrollbar>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ScrollbarProtocol`
    @inlinable init<T: ScrollbarProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ScrollbarProtocol>(_ other: T) -> ScrollbarRef { ScrollbarRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrollbarProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrollbarProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrollbarProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrollbarProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrollbarProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new scrollbar with the given orientation.
    @inlinable init<AdjustmentT: AdjustmentProtocol>( orientation: GtkOrientation, adjustment: AdjustmentT?) {
        let rv = gtk_scrollbar_new(orientation, adjustment?.adjustment_ptr)
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `Scrollbar` type acts as a reference-counted owner of an underlying `GtkScrollbar` instance.
/// It provides the methods that can operate on this data type through `ScrollbarProtocol` conformance.
/// Use `Scrollbar` as a strong reference or owner of a `GtkScrollbar` instance.
///
/// The `GtkScrollbar` widget is a horizontal or vertical scrollbar,
/// depending on the value of the `GtkOrientable:orientation` property.
/// 
/// Its position and movement are controlled by the adjustment that is passed to
/// or created by `gtk_scrollbar_new()`. See `GtkAdjustment` for more details. The
/// `GtkAdjustment:value` field sets the position of the thumb and must be between
/// `GtkAdjustment:lower` and `GtkAdjustment:upper` - `GtkAdjustment:page`-size. The
/// `GtkAdjustment:page`-size represents the size of the visible scrollable area.
/// The fields `GtkAdjustment:step`-increment and `GtkAdjustment:page`-increment
/// fields are added to or subtracted from the `GtkAdjustment:value` when the user
/// asks to move by a step (using e.g. the cursor arrow keys) or by a page (using
/// e.g. the Page Down/Up keys).
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// scrollbar
/// ╰── range[.fine-tune]
///     ╰── trough
///         ╰── slider
/// ```
/// 
/// GtkScrollbar has a main CSS node with name scrollbar and a subnode for its
/// contents. The main node gets the .horizontal or .vertical
/// style classes applied, depending on the scrollbar's orientation.
/// 
/// The range node gets the style class .fine-tune added when the scrollbar is
/// in 'fine-tuning' mode.
/// 
/// Other style classes that may be added to scrollbars inside `GtkScrolledWindow`
/// include the positional classes (.left, .right, .top, .bottom) and style
/// classes related to overlay scrolling (.overlay-indicator, .dragging, .hovering).
/// 
/// # Accessibility
/// 
/// GtkScrollbar uses the `GTK_ACCESSIBLE_ROLE_SCROLLBAR` role.
open class Scrollbar: Widget, ScrollbarProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Scrollbar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkScrollbar>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Scrollbar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkScrollbar>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Scrollbar` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Scrollbar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Scrollbar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkScrollbar>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Scrollbar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkScrollbar>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkScrollbar`.
    /// i.e., ownership is transferred to the `Scrollbar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkScrollbar>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ScrollbarProtocol`
    /// Will retain `GtkScrollbar`.
    /// - Parameter other: an instance of a related type that implements `ScrollbarProtocol`
    @inlinable public init<T: ScrollbarProtocol>(scrollbar other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrollbarProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrollbarProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrollbarProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrollbarProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrollbarProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrollbarProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrollbarProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrollbarProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new scrollbar with the given orientation.
    @inlinable public init<AdjustmentT: AdjustmentProtocol>( orientation: GtkOrientation, adjustment: AdjustmentT?) {
        let rv = gtk_scrollbar_new(orientation, adjustment?.adjustment_ptr)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum ScrollbarPropertyName: String, PropertyNameProtocol {
    case adjustment = "adjustment"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`. See `gtk_widget_set_cursor()` for details.
    case cursor = "cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case name = "name"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    case parent = "parent"
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget or `nil` if
    /// the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
}

public extension ScrollbarProtocol {
    /// Bind a `ScrollbarPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ScrollbarPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a Scrollbar property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ScrollbarPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a Scrollbar property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ScrollbarPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

// MARK: Scrollbar has no signals// MARK: Scrollbar Class: ScrollbarProtocol extension (methods and fields)
public extension ScrollbarProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkScrollbar` instance.
    @inlinable var scrollbar_ptr: UnsafeMutablePointer<GtkScrollbar>! { return ptr?.assumingMemoryBound(to: GtkScrollbar.self) }

    /// Returns the scrollbar's adjustment.
    @inlinable func getAdjustment() -> AdjustmentRef! {
        let rv = AdjustmentRef(gconstpointer: gconstpointer(gtk_scrollbar_get_adjustment(scrollbar_ptr)))
        return rv
    }

    /// Makes the scrollbar use the given adjustment.
    @inlinable func set(adjustment: AdjustmentRef? = nil) {
        gtk_scrollbar_set_adjustment(scrollbar_ptr, adjustment?.adjustment_ptr)
    
    }
    /// Makes the scrollbar use the given adjustment.
    @inlinable func set<AdjustmentT: AdjustmentProtocol>(adjustment: AdjustmentT?) {
        gtk_scrollbar_set_adjustment(scrollbar_ptr, adjustment?.adjustment_ptr)
    
    }
    @inlinable var adjustment: AdjustmentRef! {
        /// Returns the scrollbar's adjustment.
        get {
            let rv = AdjustmentRef(gconstpointer: gconstpointer(gtk_scrollbar_get_adjustment(scrollbar_ptr)))
            return rv
        }
        /// Makes the scrollbar use the given adjustment.
        nonmutating set {
            gtk_scrollbar_set_adjustment(scrollbar_ptr, UnsafeMutablePointer<GtkAdjustment>(newValue?.adjustment_ptr))
        }
    }


}



// MARK: - ScrolledWindow Class

/// The `ScrolledWindowProtocol` protocol exposes the methods and properties of an underlying `GtkScrolledWindow` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ScrolledWindow`.
/// Alternatively, use `ScrolledWindowRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// GtkScrolledWindow is a container that accepts a single child widget, makes
/// that child scrollable using either internally added scrollbars or externally
/// associated adjustments, and optionally draws a frame around the child.
/// 
/// Widgets with native scrolling support, i.e. those whose classes implement the
/// `GtkScrollable` interface, are added directly. For other types of widget, the
/// class `GtkViewport` acts as an adaptor, giving scrollability to other widgets.
/// `gtk_scrolled_window_set_child()` intelligently
/// accounts for whether or not the added child is a `GtkScrollable`. If it isn’t,
/// `GtkScrolledWindow` wraps the child in a `GtkViewport` and adds that for you.
/// Therefore, you can just add any child widget and not worry about the details.
/// 
/// If `gtk_scrolled_window_set_child()` has added a `GtkViewport` for you, you can remove
/// both your added child widget from the `GtkViewport`, and the `GtkViewport`
/// from the GtkScrolledWindow, like this:
/// 
/// (C Language Example):
/// ```C
/// GtkWidget *scrolled_window = gtk_scrolled_window_new ();
/// GtkWidget *child_widget = gtk_button_new ();
/// 
/// // GtkButton is not a GtkScrollable, so GtkScrolledWindow will automatically
/// // add a GtkViewport.
/// gtk_box_append (GTK_BOX (scrolled_window),
///                    child_widget);
/// 
/// // Either of these will result in child_widget being unparented:
/// gtk_box_remove (GTK_BOX (scrolled_window),
///                       child_widget);
/// // or
/// gtk_box_remove (GTK_BOX (scrolled_window),
///                       gtk_bin_get_child (GTK_BIN (scrolled_window)));
/// ```
/// 
/// Unless `GtkScrolledWindow:hscrollbar`-policy and `GtkScrolledWindow:vscrollbar`-policy
/// are GTK_POLICY_NEVER or GTK_POLICY_EXTERNAL,
/// GtkScrolledWindow adds internal `GtkScrollbar` widgets around its child. The
/// scroll position of the child, and if applicable the scrollbars, is controlled
/// by the `GtkScrolledWindow:hadjustment` and `GtkScrolledWindow:vadjustment`
/// that are associated with the GtkScrolledWindow. See the docs on `GtkScrollbar`
/// for the details, but note that the “step_increment” and “page_increment”
/// fields are only effective if the policy causes scrollbars to be present.
/// 
/// If a GtkScrolledWindow doesn’t behave quite as you would like, or
/// doesn’t have exactly the right layout, it’s very possible to set up
/// your own scrolling with `GtkScrollbar` and for example a `GtkGrid`.
/// 
/// # Touch support
/// 
/// GtkScrolledWindow has built-in support for touch devices. When a
/// touchscreen is used, swiping will move the scrolled window, and will
/// expose 'kinetic' behavior. This can be turned off with the
/// `GtkScrolledWindow:kinetic`-scrolling property if it is undesired.
/// 
/// GtkScrolledWindow also displays visual 'overshoot' indication when
/// the content is pulled beyond the end, and this situation can be
/// captured with the `GtkScrolledWindow::edge`-overshot signal.
/// 
/// If no mouse device is present, the scrollbars will overlaid as
/// narrow, auto-hiding indicators over the content. If traditional
/// scrollbars are desired although no mouse is present, this behaviour
/// can be turned off with the `GtkScrolledWindow:overlay`-scrolling
/// property.
/// 
/// # CSS nodes
/// 
/// GtkScrolledWindow has a main CSS node with name scrolledwindow.
/// It gets a .frame style class added when `GtkScrolledWindow:has`-frame
/// is `true`.
/// 
/// It uses subnodes with names overshoot and undershoot to
/// draw the overflow and underflow indications. These nodes get
/// the .left, .right, .top or .bottom style class added depending
/// on where the indication is drawn.
/// 
/// GtkScrolledWindow also sets the positional style classes (.left,
/// .right, .top, .bottom) and style classes related to overlay
/// scrolling (.overlay-indicator, .dragging, .hovering) on its scrollbars.
/// 
/// If both scrollbars are visible, the area where they meet is drawn
/// with a subnode named junction.
/// 
/// # Accessibility
/// 
/// GtkScrolledWindow uses the `GTK_ACCESSIBLE_ROLE_GROUP` role.
public protocol ScrolledWindowProtocol: WidgetProtocol {
        /// Untyped pointer to the underlying `GtkScrolledWindow` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkScrolledWindow` instance.
    var scrolled_window_ptr: UnsafeMutablePointer<GtkScrolledWindow>! { get }

}

/// The `ScrolledWindowRef` type acts as a lightweight Swift reference to an underlying `GtkScrolledWindow` instance.
/// It exposes methods that can operate on this data type through `ScrolledWindowProtocol` conformance.
/// Use `ScrolledWindowRef` only as an `unowned` reference to an existing `GtkScrolledWindow` instance.
///
/// GtkScrolledWindow is a container that accepts a single child widget, makes
/// that child scrollable using either internally added scrollbars or externally
/// associated adjustments, and optionally draws a frame around the child.
/// 
/// Widgets with native scrolling support, i.e. those whose classes implement the
/// `GtkScrollable` interface, are added directly. For other types of widget, the
/// class `GtkViewport` acts as an adaptor, giving scrollability to other widgets.
/// `gtk_scrolled_window_set_child()` intelligently
/// accounts for whether or not the added child is a `GtkScrollable`. If it isn’t,
/// `GtkScrolledWindow` wraps the child in a `GtkViewport` and adds that for you.
/// Therefore, you can just add any child widget and not worry about the details.
/// 
/// If `gtk_scrolled_window_set_child()` has added a `GtkViewport` for you, you can remove
/// both your added child widget from the `GtkViewport`, and the `GtkViewport`
/// from the GtkScrolledWindow, like this:
/// 
/// (C Language Example):
/// ```C
/// GtkWidget *scrolled_window = gtk_scrolled_window_new ();
/// GtkWidget *child_widget = gtk_button_new ();
/// 
/// // GtkButton is not a GtkScrollable, so GtkScrolledWindow will automatically
/// // add a GtkViewport.
/// gtk_box_append (GTK_BOX (scrolled_window),
///                    child_widget);
/// 
/// // Either of these will result in child_widget being unparented:
/// gtk_box_remove (GTK_BOX (scrolled_window),
///                       child_widget);
/// // or
/// gtk_box_remove (GTK_BOX (scrolled_window),
///                       gtk_bin_get_child (GTK_BIN (scrolled_window)));
/// ```
/// 
/// Unless `GtkScrolledWindow:hscrollbar`-policy and `GtkScrolledWindow:vscrollbar`-policy
/// are GTK_POLICY_NEVER or GTK_POLICY_EXTERNAL,
/// GtkScrolledWindow adds internal `GtkScrollbar` widgets around its child. The
/// scroll position of the child, and if applicable the scrollbars, is controlled
/// by the `GtkScrolledWindow:hadjustment` and `GtkScrolledWindow:vadjustment`
/// that are associated with the GtkScrolledWindow. See the docs on `GtkScrollbar`
/// for the details, but note that the “step_increment” and “page_increment”
/// fields are only effective if the policy causes scrollbars to be present.
/// 
/// If a GtkScrolledWindow doesn’t behave quite as you would like, or
/// doesn’t have exactly the right layout, it’s very possible to set up
/// your own scrolling with `GtkScrollbar` and for example a `GtkGrid`.
/// 
/// # Touch support
/// 
/// GtkScrolledWindow has built-in support for touch devices. When a
/// touchscreen is used, swiping will move the scrolled window, and will
/// expose 'kinetic' behavior. This can be turned off with the
/// `GtkScrolledWindow:kinetic`-scrolling property if it is undesired.
/// 
/// GtkScrolledWindow also displays visual 'overshoot' indication when
/// the content is pulled beyond the end, and this situation can be
/// captured with the `GtkScrolledWindow::edge`-overshot signal.
/// 
/// If no mouse device is present, the scrollbars will overlaid as
/// narrow, auto-hiding indicators over the content. If traditional
/// scrollbars are desired although no mouse is present, this behaviour
/// can be turned off with the `GtkScrolledWindow:overlay`-scrolling
/// property.
/// 
/// # CSS nodes
/// 
/// GtkScrolledWindow has a main CSS node with name scrolledwindow.
/// It gets a .frame style class added when `GtkScrolledWindow:has`-frame
/// is `true`.
/// 
/// It uses subnodes with names overshoot and undershoot to
/// draw the overflow and underflow indications. These nodes get
/// the .left, .right, .top or .bottom style class added depending
/// on where the indication is drawn.
/// 
/// GtkScrolledWindow also sets the positional style classes (.left,
/// .right, .top, .bottom) and style classes related to overlay
/// scrolling (.overlay-indicator, .dragging, .hovering) on its scrollbars.
/// 
/// If both scrollbars are visible, the area where they meet is drawn
/// with a subnode named junction.
/// 
/// # Accessibility
/// 
/// GtkScrolledWindow uses the `GTK_ACCESSIBLE_ROLE_GROUP` role.
public struct ScrolledWindowRef: ScrolledWindowProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkScrolledWindow` instance.
    /// For type-safe access, use the generated, typed pointer `scrolled_window_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ScrolledWindowRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkScrolledWindow>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkScrolledWindow>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkScrolledWindow>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkScrolledWindow>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ScrolledWindowProtocol`
    @inlinable init<T: ScrolledWindowProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ScrolledWindowProtocol>(_ other: T) -> ScrolledWindowRef { ScrolledWindowRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrolledWindowProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrolledWindowProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrolledWindowProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrolledWindowProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrolledWindowProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new scrolled window.
    @inlinable init() {
        let rv = gtk_scrolled_window_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `ScrolledWindow` type acts as a reference-counted owner of an underlying `GtkScrolledWindow` instance.
/// It provides the methods that can operate on this data type through `ScrolledWindowProtocol` conformance.
/// Use `ScrolledWindow` as a strong reference or owner of a `GtkScrolledWindow` instance.
///
/// GtkScrolledWindow is a container that accepts a single child widget, makes
/// that child scrollable using either internally added scrollbars or externally
/// associated adjustments, and optionally draws a frame around the child.
/// 
/// Widgets with native scrolling support, i.e. those whose classes implement the
/// `GtkScrollable` interface, are added directly. For other types of widget, the
/// class `GtkViewport` acts as an adaptor, giving scrollability to other widgets.
/// `gtk_scrolled_window_set_child()` intelligently
/// accounts for whether or not the added child is a `GtkScrollable`. If it isn’t,
/// `GtkScrolledWindow` wraps the child in a `GtkViewport` and adds that for you.
/// Therefore, you can just add any child widget and not worry about the details.
/// 
/// If `gtk_scrolled_window_set_child()` has added a `GtkViewport` for you, you can remove
/// both your added child widget from the `GtkViewport`, and the `GtkViewport`
/// from the GtkScrolledWindow, like this:
/// 
/// (C Language Example):
/// ```C
/// GtkWidget *scrolled_window = gtk_scrolled_window_new ();
/// GtkWidget *child_widget = gtk_button_new ();
/// 
/// // GtkButton is not a GtkScrollable, so GtkScrolledWindow will automatically
/// // add a GtkViewport.
/// gtk_box_append (GTK_BOX (scrolled_window),
///                    child_widget);
/// 
/// // Either of these will result in child_widget being unparented:
/// gtk_box_remove (GTK_BOX (scrolled_window),
///                       child_widget);
/// // or
/// gtk_box_remove (GTK_BOX (scrolled_window),
///                       gtk_bin_get_child (GTK_BIN (scrolled_window)));
/// ```
/// 
/// Unless `GtkScrolledWindow:hscrollbar`-policy and `GtkScrolledWindow:vscrollbar`-policy
/// are GTK_POLICY_NEVER or GTK_POLICY_EXTERNAL,
/// GtkScrolledWindow adds internal `GtkScrollbar` widgets around its child. The
/// scroll position of the child, and if applicable the scrollbars, is controlled
/// by the `GtkScrolledWindow:hadjustment` and `GtkScrolledWindow:vadjustment`
/// that are associated with the GtkScrolledWindow. See the docs on `GtkScrollbar`
/// for the details, but note that the “step_increment” and “page_increment”
/// fields are only effective if the policy causes scrollbars to be present.
/// 
/// If a GtkScrolledWindow doesn’t behave quite as you would like, or
/// doesn’t have exactly the right layout, it’s very possible to set up
/// your own scrolling with `GtkScrollbar` and for example a `GtkGrid`.
/// 
/// # Touch support
/// 
/// GtkScrolledWindow has built-in support for touch devices. When a
/// touchscreen is used, swiping will move the scrolled window, and will
/// expose 'kinetic' behavior. This can be turned off with the
/// `GtkScrolledWindow:kinetic`-scrolling property if it is undesired.
/// 
/// GtkScrolledWindow also displays visual 'overshoot' indication when
/// the content is pulled beyond the end, and this situation can be
/// captured with the `GtkScrolledWindow::edge`-overshot signal.
/// 
/// If no mouse device is present, the scrollbars will overlaid as
/// narrow, auto-hiding indicators over the content. If traditional
/// scrollbars are desired although no mouse is present, this behaviour
/// can be turned off with the `GtkScrolledWindow:overlay`-scrolling
/// property.
/// 
/// # CSS nodes
/// 
/// GtkScrolledWindow has a main CSS node with name scrolledwindow.
/// It gets a .frame style class added when `GtkScrolledWindow:has`-frame
/// is `true`.
/// 
/// It uses subnodes with names overshoot and undershoot to
/// draw the overflow and underflow indications. These nodes get
/// the .left, .right, .top or .bottom style class added depending
/// on where the indication is drawn.
/// 
/// GtkScrolledWindow also sets the positional style classes (.left,
/// .right, .top, .bottom) and style classes related to overlay
/// scrolling (.overlay-indicator, .dragging, .hovering) on its scrollbars.
/// 
/// If both scrollbars are visible, the area where they meet is drawn
/// with a subnode named junction.
/// 
/// # Accessibility
/// 
/// GtkScrolledWindow uses the `GTK_ACCESSIBLE_ROLE_GROUP` role.
open class ScrolledWindow: Widget, ScrolledWindowProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ScrolledWindow` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkScrolledWindow>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ScrolledWindow` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkScrolledWindow>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ScrolledWindow` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ScrolledWindow` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ScrolledWindow` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkScrolledWindow>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ScrolledWindow` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkScrolledWindow>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkScrolledWindow`.
    /// i.e., ownership is transferred to the `ScrolledWindow` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkScrolledWindow>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ScrolledWindowProtocol`
    /// Will retain `GtkScrolledWindow`.
    /// - Parameter other: an instance of a related type that implements `ScrolledWindowProtocol`
    @inlinable public init<T: ScrolledWindowProtocol>(scrolledWindow other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrolledWindowProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrolledWindowProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrolledWindowProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrolledWindowProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrolledWindowProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrolledWindowProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrolledWindowProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrolledWindowProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new scrolled window.
    @inlinable public init() {
        let rv = gtk_scrolled_window_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum ScrolledWindowPropertyName: String, PropertyNameProtocol {
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    case canTarget = "can-target"
    case child = "child"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`. See `gtk_widget_set_cursor()` for details.
    case cursor = "cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    case hadjustment = "hadjustment"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    case hasFrame = "has-frame"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    case hscrollbarPolicy = "hscrollbar-policy"
    /// Whether kinetic scrolling is enabled or not. Kinetic scrolling
    /// only applies to devices with source `GDK_SOURCE_TOUCHSCREEN`.
    case kineticScrolling = "kinetic-scrolling"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    /// The maximum content height of `scrolled_window`, or -1 if not set.
    case maxContentHeight = "max-content-height"
    /// The maximum content width of `scrolled_window`, or -1 if not set.
    case maxContentWidth = "max-content-width"
    /// The minimum content height of `scrolled_window`, or -1 if not set.
    case minContentHeight = "min-content-height"
    /// The minimum content width of `scrolled_window`, or -1 if not set.
    case minContentWidth = "min-content-width"
    case name = "name"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// Whether overlay scrolling is enabled or not. If it is, the
    /// scrollbars are only added as traditional widgets when a mouse
    /// is present. Otherwise, they are overlaid on top of the content,
    /// as narrow indicators.
    /// 
    /// Note that overlay scrolling can also be globally disabled, with
    /// the `GtkSettings:gtk`-overlay-scrolling setting.
    case overlayScrolling = "overlay-scrolling"
    case parent = "parent"
    /// Whether the natural height of the child should be calculated and propagated
    /// through the scrolled window’s requested natural height.
    /// 
    /// This is useful in cases where an attempt should be made to allocate exactly
    /// enough space for the natural size of the child.
    case propagateNaturalHeight = "propagate-natural-height"
    /// Whether the natural width of the child should be calculated and propagated
    /// through the scrolled window’s requested natural width.
    /// 
    /// This is useful in cases where an attempt should be made to allocate exactly
    /// enough space for the natural size of the child.
    case propagateNaturalWidth = "propagate-natural-width"
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget or `nil` if
    /// the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    case vadjustment = "vadjustment"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case vscrollbarPolicy = "vscrollbar-policy"
    case widthRequest = "width-request"
    case windowPlacement = "window-placement"
}

public extension ScrolledWindowProtocol {
    /// Bind a `ScrolledWindowPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ScrolledWindowPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ScrolledWindow property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ScrolledWindowPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ScrolledWindow property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ScrolledWindowPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

// MARK: Signals of ScrolledWindow
public extension ScrolledWindowProtocol {
    /// The `edge`-overshot signal is emitted whenever user initiated scrolling
    /// makes the scrolled window firmly surpass (i.e. with some edge resistance)
    /// the lower or upper limits defined by the adjustment in that orientation.
    /// 
    /// A similar behavior without edge resistance is provided by the
    /// `GtkScrolledWindow::edge`-reached signal.
    /// 
    /// Note: The `pos` argument is LTR/RTL aware, so callers should be aware too
    /// if intending to provide behavior on horizontal edges.
    /// - Note: Representation of signal named `edge-overshot`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pos: edge side that was hit
    @discardableResult
    func onEdgeOvershot(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScrolledWindowRef, _ pos: PositionType) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScrolledWindowRef, PositionType, Void>
        let cCallback: @convention(c) (gpointer, UInt32, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScrolledWindowRef(raw: unownedSelf), PositionType(arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "edge-overshot", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The `edge`-reached signal is emitted whenever user-initiated scrolling
    /// makes the scrolled window exactly reach the lower or upper limits
    /// defined by the adjustment in that orientation.
    /// 
    /// A similar behavior with edge resistance is provided by the
    /// `GtkScrolledWindow::edge`-overshot signal.
    /// 
    /// Note: The `pos` argument is LTR/RTL aware, so callers should be aware too
    /// if intending to provide behavior on horizontal edges.
    /// - Note: Representation of signal named `edge-reached`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pos: edge side that was reached
    @discardableResult
    func onEdgeReached(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScrolledWindowRef, _ pos: PositionType) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScrolledWindowRef, PositionType, Void>
        let cCallback: @convention(c) (gpointer, UInt32, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScrolledWindowRef(raw: unownedSelf), PositionType(arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "edge-reached", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The `move`-focus-out signal is a
    /// [keybinding signal](#GtkSignalAction) which gets
    /// emitted when focus is moved away from the scrolled window by a
    /// keybinding. The `GtkWidget::move`-focus signal is emitted with
    /// `direction_type` on this scrolled window’s toplevel parent in the
    /// container hierarchy. The default bindings for this signal are
    /// `Ctrl + Tab` to move forward and `Ctrl + Shift + Tab` to move backward.
    /// - Note: Representation of signal named `move-focus-out`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter directionType: either `GTK_DIR_TAB_FORWARD` or   `GTK_DIR_TAB_BACKWARD`
    @discardableResult
    func onMoveFocusOut(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScrolledWindowRef, _ directionType: DirectionType) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScrolledWindowRef, DirectionType, Void>
        let cCallback: @convention(c) (gpointer, UInt32, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScrolledWindowRef(raw: unownedSelf), DirectionType(arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "move-focus-out", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The `scroll`-child signal is a
    /// [keybinding signal](#GtkSignalAction)
    /// which gets emitted when a keybinding that scrolls is pressed.
    /// The horizontal or vertical adjustment is updated which triggers a
    /// signal that the scrolled window’s child may listen to and scroll itself.
    /// - Note: Representation of signal named `scroll-child`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter scroll: a `GtkScrollType` describing how much to scroll
    /// - Parameter horizontal: whether the keybinding scrolls the child   horizontally or not
    @discardableResult
    func onScrollChild(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScrolledWindowRef, _ scroll: ScrollType, _ horizontal: Bool) -> Bool ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder3<ScrolledWindowRef, ScrollType, Bool, Bool>
        let cCallback: @convention(c) (gpointer, UInt32, gboolean, gpointer) -> gboolean = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call(ScrolledWindowRef(raw: unownedSelf), ScrollType(arg1), ((arg2) != 0))
            return gboolean((output) ? 1 : 0)
        }
        return signalConnectData(
            detailedSignal: "scroll-child", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::child`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyChild(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScrolledWindowRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScrolledWindowRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScrolledWindowRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::child", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::hadjustment`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyHadjustment(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScrolledWindowRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScrolledWindowRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScrolledWindowRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::hadjustment", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::has-frame`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyHasFrame(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScrolledWindowRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScrolledWindowRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScrolledWindowRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::has-frame", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::hscrollbar-policy`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyHscrollbarPolicy(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScrolledWindowRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScrolledWindowRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScrolledWindowRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::hscrollbar-policy", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::kinetic-scrolling`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyKineticScrolling(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScrolledWindowRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScrolledWindowRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScrolledWindowRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::kinetic-scrolling", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::max-content-height`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyMaxContentHeight(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScrolledWindowRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScrolledWindowRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScrolledWindowRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::max-content-height", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::max-content-width`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyMaxContentWidth(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScrolledWindowRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScrolledWindowRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScrolledWindowRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::max-content-width", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::min-content-height`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyMinContentHeight(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScrolledWindowRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScrolledWindowRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScrolledWindowRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::min-content-height", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::min-content-width`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyMinContentWidth(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScrolledWindowRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScrolledWindowRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScrolledWindowRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::min-content-width", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::overlay-scrolling`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyOverlayScrolling(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScrolledWindowRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScrolledWindowRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScrolledWindowRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::overlay-scrolling", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::propagate-natural-height`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyPropagateNaturalHeight(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScrolledWindowRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScrolledWindowRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScrolledWindowRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::propagate-natural-height", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::propagate-natural-width`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyPropagateNaturalWidth(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScrolledWindowRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScrolledWindowRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScrolledWindowRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::propagate-natural-width", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::vadjustment`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyVadjustment(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScrolledWindowRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScrolledWindowRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScrolledWindowRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::vadjustment", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::vscrollbar-policy`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyVscrollbarPolicy(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScrolledWindowRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScrolledWindowRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScrolledWindowRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::vscrollbar-policy", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::window-placement`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyWindowPlacement(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScrolledWindowRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScrolledWindowRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScrolledWindowRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::window-placement", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
}

// MARK: ScrolledWindow Class: ScrolledWindowProtocol extension (methods and fields)
public extension ScrolledWindowProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkScrolledWindow` instance.
    @inlinable var scrolled_window_ptr: UnsafeMutablePointer<GtkScrolledWindow>! { return ptr?.assumingMemoryBound(to: GtkScrolledWindow.self) }

    /// Gets the child widget of `scrolled_window`.
    @inlinable func getChild() -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_scrolled_window_get_child(scrolled_window_ptr))) else { return nil }
        return rv
    }

    /// Returns the horizontal scrollbar’s adjustment, used to connect the
    /// horizontal scrollbar to the child widget’s horizontal scroll
    /// functionality.
    @inlinable func getHadjustment() -> AdjustmentRef! {
        let rv = AdjustmentRef(gconstpointer: gconstpointer(gtk_scrolled_window_get_hadjustment(scrolled_window_ptr)))
        return rv
    }

    /// Gets whether the scrolled window draws a frame.
    /// See  `gtk_scrolled_window_set_has_frame()`.
    @inlinable func getHasFrame() -> Bool {
        let rv = ((gtk_scrolled_window_get_has_frame(scrolled_window_ptr)) != 0)
        return rv
    }

    /// Returns the horizontal scrollbar of `scrolled_window`.
    @inlinable func getHscrollbar() -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_scrolled_window_get_hscrollbar(scrolled_window_ptr))) else { return nil }
        return rv
    }

    /// Returns the specified kinetic scrolling behavior.
    @inlinable func getKineticScrolling() -> Bool {
        let rv = ((gtk_scrolled_window_get_kinetic_scrolling(scrolled_window_ptr)) != 0)
        return rv
    }

    /// Returns the maximum content height set.
    @inlinable func getMaxContentHeight() -> Int {
        let rv = Int(gtk_scrolled_window_get_max_content_height(scrolled_window_ptr))
        return rv
    }

    /// Returns the maximum content width set.
    @inlinable func getMaxContentWidth() -> Int {
        let rv = Int(gtk_scrolled_window_get_max_content_width(scrolled_window_ptr))
        return rv
    }

    /// Gets the minimal content height of `scrolled_window`, or -1 if not set.
    @inlinable func getMinContentHeight() -> Int {
        let rv = Int(gtk_scrolled_window_get_min_content_height(scrolled_window_ptr))
        return rv
    }

    /// Gets the minimum content width of `scrolled_window`, or -1 if not set.
    @inlinable func getMinContentWidth() -> Int {
        let rv = Int(gtk_scrolled_window_get_min_content_width(scrolled_window_ptr))
        return rv
    }

    /// Returns whether overlay scrolling is enabled for this scrolled window.
    @inlinable func getOverlayScrolling() -> Bool {
        let rv = ((gtk_scrolled_window_get_overlay_scrolling(scrolled_window_ptr)) != 0)
        return rv
    }

    /// Gets the placement of the contents with respect to the scrollbars
    /// for the scrolled window. See `gtk_scrolled_window_set_placement()`.
    @inlinable func getPlacement() -> GtkCornerType {
        let rv = gtk_scrolled_window_get_placement(scrolled_window_ptr)
        return rv
    }

    /// Retrieves the current policy values for the horizontal and vertical
    /// scrollbars. See `gtk_scrolled_window_set_policy()`.
    @inlinable func getPolicy(hscrollbarPolicy: UnsafeMutablePointer<GtkPolicyType>! = nil, vscrollbarPolicy: UnsafeMutablePointer<GtkPolicyType>! = nil) {
        gtk_scrolled_window_get_policy(scrolled_window_ptr, hscrollbarPolicy, vscrollbarPolicy)
    
    }

    /// Reports whether the natural height of the child will be calculated and propagated
    /// through the scrolled window’s requested natural height.
    @inlinable func getPropagateNaturalHeight() -> Bool {
        let rv = ((gtk_scrolled_window_get_propagate_natural_height(scrolled_window_ptr)) != 0)
        return rv
    }

    /// Reports whether the natural width of the child will be calculated and propagated
    /// through the scrolled window’s requested natural width.
    @inlinable func getPropagateNaturalWidth() -> Bool {
        let rv = ((gtk_scrolled_window_get_propagate_natural_width(scrolled_window_ptr)) != 0)
        return rv
    }

    /// Returns the vertical scrollbar’s adjustment, used to connect the
    /// vertical scrollbar to the child widget’s vertical scroll functionality.
    @inlinable func getVadjustment() -> AdjustmentRef! {
        let rv = AdjustmentRef(gconstpointer: gconstpointer(gtk_scrolled_window_get_vadjustment(scrolled_window_ptr)))
        return rv
    }

    /// Returns the vertical scrollbar of `scrolled_window`.
    @inlinable func getVscrollbar() -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_scrolled_window_get_vscrollbar(scrolled_window_ptr))) else { return nil }
        return rv
    }

    /// Sets the child widget of `scrolled_window`.
    @inlinable func set(child: WidgetRef? = nil) {
        gtk_scrolled_window_set_child(scrolled_window_ptr, child?.widget_ptr)
    
    }
    /// Sets the child widget of `scrolled_window`.
    @inlinable func set<WidgetT: WidgetProtocol>(child: WidgetT?) {
        gtk_scrolled_window_set_child(scrolled_window_ptr, child?.widget_ptr)
    
    }

    /// Sets the `GtkAdjustment` for the horizontal scrollbar.
    @inlinable func set(hadjustment: AdjustmentRef? = nil) {
        gtk_scrolled_window_set_hadjustment(scrolled_window_ptr, hadjustment?.adjustment_ptr)
    
    }
    /// Sets the `GtkAdjustment` for the horizontal scrollbar.
    @inlinable func set<AdjustmentT: AdjustmentProtocol>(hadjustment: AdjustmentT?) {
        gtk_scrolled_window_set_hadjustment(scrolled_window_ptr, hadjustment?.adjustment_ptr)
    
    }

    /// Changes the frame drawn around the contents of `scrolled_window`.
    @inlinable func set(hasFrame: Bool) {
        gtk_scrolled_window_set_has_frame(scrolled_window_ptr, gboolean((hasFrame) ? 1 : 0))
    
    }

    /// Turns kinetic scrolling on or off.
    /// Kinetic scrolling only applies to devices with source
    /// `GDK_SOURCE_TOUCHSCREEN`.
    @inlinable func set(kineticScrolling: Bool) {
        gtk_scrolled_window_set_kinetic_scrolling(scrolled_window_ptr, gboolean((kineticScrolling) ? 1 : 0))
    
    }

    /// Sets the maximum height that `scrolled_window` should keep visible. The
    /// `scrolled_window` will grow up to this height before it starts scrolling
    /// the content.
    /// 
    /// It is a programming error to set the maximum content height to a value
    /// smaller than `GtkScrolledWindow:min`-content-height.
    @inlinable func setMaxContent(height: Int) {
        gtk_scrolled_window_set_max_content_height(scrolled_window_ptr, gint(height))
    
    }

    /// Sets the maximum width that `scrolled_window` should keep visible. The
    /// `scrolled_window` will grow up to this width before it starts scrolling
    /// the content.
    /// 
    /// It is a programming error to set the maximum content width to a value
    /// smaller than `GtkScrolledWindow:min`-content-width.
    @inlinable func setMaxContent(width: Int) {
        gtk_scrolled_window_set_max_content_width(scrolled_window_ptr, gint(width))
    
    }

    /// Sets the minimum height that `scrolled_window` should keep visible.
    /// Note that this can and (usually will) be smaller than the minimum
    /// size of the content.
    /// 
    /// It is a programming error to set the minimum content height to a
    /// value greater than `GtkScrolledWindow:max`-content-height.
    @inlinable func setMinContent(height: Int) {
        gtk_scrolled_window_set_min_content_height(scrolled_window_ptr, gint(height))
    
    }

    /// Sets the minimum width that `scrolled_window` should keep visible.
    /// Note that this can and (usually will) be smaller than the minimum
    /// size of the content.
    /// 
    /// It is a programming error to set the minimum content width to a
    /// value greater than `GtkScrolledWindow:max`-content-width.
    @inlinable func setMinContent(width: Int) {
        gtk_scrolled_window_set_min_content_width(scrolled_window_ptr, gint(width))
    
    }

    /// Enables or disables overlay scrolling for this scrolled window.
    @inlinable func set(overlayScrolling: Bool) {
        gtk_scrolled_window_set_overlay_scrolling(scrolled_window_ptr, gboolean((overlayScrolling) ? 1 : 0))
    
    }

    /// Sets the placement of the contents with respect to the scrollbars
    /// for the scrolled window.
    /// 
    /// The default is `GTK_CORNER_TOP_LEFT`, meaning the child is
    /// in the top left, with the scrollbars underneath and to the right.
    /// Other values in `GtkCornerType` are `GTK_CORNER_TOP_RIGHT`,
    /// `GTK_CORNER_BOTTOM_LEFT`, and `GTK_CORNER_BOTTOM_RIGHT`.
    /// 
    /// See also `gtk_scrolled_window_get_placement()` and
    /// `gtk_scrolled_window_unset_placement()`.
    @inlinable func setPlacement(windowPlacement: GtkCornerType) {
        gtk_scrolled_window_set_placement(scrolled_window_ptr, windowPlacement)
    
    }

    /// Sets the scrollbar policy for the horizontal and vertical scrollbars.
    /// 
    /// The policy determines when the scrollbar should appear; it is a value
    /// from the `GtkPolicyType` enumeration. If `GTK_POLICY_ALWAYS`, the
    /// scrollbar is always present; if `GTK_POLICY_NEVER`, the scrollbar is
    /// never present; if `GTK_POLICY_AUTOMATIC`, the scrollbar is present only
    /// if needed (that is, if the slider part of the bar would be smaller
    /// than the trough — the display is larger than the page size).
    @inlinable func setPolicy(hscrollbarPolicy: GtkPolicyType, vscrollbarPolicy: GtkPolicyType) {
        gtk_scrolled_window_set_policy(scrolled_window_ptr, hscrollbarPolicy, vscrollbarPolicy)
    
    }

    /// Sets whether the natural height of the child should be calculated and propagated
    /// through the scrolled window’s requested natural height.
    @inlinable func setPropagateNaturalHeight(propagate: Bool) {
        gtk_scrolled_window_set_propagate_natural_height(scrolled_window_ptr, gboolean((propagate) ? 1 : 0))
    
    }

    /// Sets whether the natural width of the child should be calculated and propagated
    /// through the scrolled window’s requested natural width.
    @inlinable func setPropagateNaturalWidth(propagate: Bool) {
        gtk_scrolled_window_set_propagate_natural_width(scrolled_window_ptr, gboolean((propagate) ? 1 : 0))
    
    }

    /// Sets the `GtkAdjustment` for the vertical scrollbar.
    @inlinable func set(vadjustment: AdjustmentRef? = nil) {
        gtk_scrolled_window_set_vadjustment(scrolled_window_ptr, vadjustment?.adjustment_ptr)
    
    }
    /// Sets the `GtkAdjustment` for the vertical scrollbar.
    @inlinable func set<AdjustmentT: AdjustmentProtocol>(vadjustment: AdjustmentT?) {
        gtk_scrolled_window_set_vadjustment(scrolled_window_ptr, vadjustment?.adjustment_ptr)
    
    }

    /// Unsets the placement of the contents with respect to the scrollbars
    /// for the scrolled window. If no window placement is set for a scrolled
    /// window, it defaults to `GTK_CORNER_TOP_LEFT`.
    /// 
    /// See also `gtk_scrolled_window_set_placement()` and
    /// `gtk_scrolled_window_get_placement()`.
    @inlinable func unsetPlacement() {
        gtk_scrolled_window_unset_placement(scrolled_window_ptr)
    
    }
    @inlinable var child: WidgetRef! {
        /// Gets the child widget of `scrolled_window`.
        get {
            guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_scrolled_window_get_child(scrolled_window_ptr))) else { return nil }
            return rv
        }
        /// Sets the child widget of `scrolled_window`.
        nonmutating set {
            gtk_scrolled_window_set_child(scrolled_window_ptr, UnsafeMutablePointer<GtkWidget>(newValue?.widget_ptr))
        }
    }

    @inlinable var hadjustment: AdjustmentRef! {
        /// Returns the horizontal scrollbar’s adjustment, used to connect the
        /// horizontal scrollbar to the child widget’s horizontal scroll
        /// functionality.
        get {
            let rv = AdjustmentRef(gconstpointer: gconstpointer(gtk_scrolled_window_get_hadjustment(scrolled_window_ptr)))
            return rv
        }
        /// Sets the `GtkAdjustment` for the horizontal scrollbar.
        nonmutating set {
            gtk_scrolled_window_set_hadjustment(scrolled_window_ptr, UnsafeMutablePointer<GtkAdjustment>(newValue?.adjustment_ptr))
        }
    }

    /// Gets whether the scrolled window draws a frame.
    /// See  `gtk_scrolled_window_set_has_frame()`.
    @inlinable var hasFrame: Bool {
        /// Gets whether the scrolled window draws a frame.
        /// See  `gtk_scrolled_window_set_has_frame()`.
        get {
            let rv = ((gtk_scrolled_window_get_has_frame(scrolled_window_ptr)) != 0)
            return rv
        }
        /// Changes the frame drawn around the contents of `scrolled_window`.
        nonmutating set {
            gtk_scrolled_window_set_has_frame(scrolled_window_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns the horizontal scrollbar of `scrolled_window`.
    @inlinable var hscrollbar: WidgetRef! {
        /// Returns the horizontal scrollbar of `scrolled_window`.
        get {
            guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_scrolled_window_get_hscrollbar(scrolled_window_ptr))) else { return nil }
            return rv
        }
    }

    /// Returns the specified kinetic scrolling behavior.
    @inlinable var kineticScrolling: Bool {
        /// Returns the specified kinetic scrolling behavior.
        get {
            let rv = ((gtk_scrolled_window_get_kinetic_scrolling(scrolled_window_ptr)) != 0)
            return rv
        }
        /// Turns kinetic scrolling on or off.
        /// Kinetic scrolling only applies to devices with source
        /// `GDK_SOURCE_TOUCHSCREEN`.
        nonmutating set {
            gtk_scrolled_window_set_kinetic_scrolling(scrolled_window_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns the maximum content height set.
    @inlinable var maxContentHeight: Int {
        /// Returns the maximum content height set.
        get {
            let rv = Int(gtk_scrolled_window_get_max_content_height(scrolled_window_ptr))
            return rv
        }
        /// Sets the maximum height that `scrolled_window` should keep visible. The
        /// `scrolled_window` will grow up to this height before it starts scrolling
        /// the content.
        /// 
        /// It is a programming error to set the maximum content height to a value
        /// smaller than `GtkScrolledWindow:min`-content-height.
        nonmutating set {
            gtk_scrolled_window_set_max_content_height(scrolled_window_ptr, gint(newValue))
        }
    }

    /// Returns the maximum content width set.
    @inlinable var maxContentWidth: Int {
        /// Returns the maximum content width set.
        get {
            let rv = Int(gtk_scrolled_window_get_max_content_width(scrolled_window_ptr))
            return rv
        }
        /// Sets the maximum width that `scrolled_window` should keep visible. The
        /// `scrolled_window` will grow up to this width before it starts scrolling
        /// the content.
        /// 
        /// It is a programming error to set the maximum content width to a value
        /// smaller than `GtkScrolledWindow:min`-content-width.
        nonmutating set {
            gtk_scrolled_window_set_max_content_width(scrolled_window_ptr, gint(newValue))
        }
    }

    /// Gets the minimal content height of `scrolled_window`, or -1 if not set.
    @inlinable var minContentHeight: Int {
        /// Gets the minimal content height of `scrolled_window`, or -1 if not set.
        get {
            let rv = Int(gtk_scrolled_window_get_min_content_height(scrolled_window_ptr))
            return rv
        }
        /// Sets the minimum height that `scrolled_window` should keep visible.
        /// Note that this can and (usually will) be smaller than the minimum
        /// size of the content.
        /// 
        /// It is a programming error to set the minimum content height to a
        /// value greater than `GtkScrolledWindow:max`-content-height.
        nonmutating set {
            gtk_scrolled_window_set_min_content_height(scrolled_window_ptr, gint(newValue))
        }
    }

    /// Gets the minimum content width of `scrolled_window`, or -1 if not set.
    @inlinable var minContentWidth: Int {
        /// Gets the minimum content width of `scrolled_window`, or -1 if not set.
        get {
            let rv = Int(gtk_scrolled_window_get_min_content_width(scrolled_window_ptr))
            return rv
        }
        /// Sets the minimum width that `scrolled_window` should keep visible.
        /// Note that this can and (usually will) be smaller than the minimum
        /// size of the content.
        /// 
        /// It is a programming error to set the minimum content width to a
        /// value greater than `GtkScrolledWindow:max`-content-width.
        nonmutating set {
            gtk_scrolled_window_set_min_content_width(scrolled_window_ptr, gint(newValue))
        }
    }

    /// Returns whether overlay scrolling is enabled for this scrolled window.
    @inlinable var overlayScrolling: Bool {
        /// Returns whether overlay scrolling is enabled for this scrolled window.
        get {
            let rv = ((gtk_scrolled_window_get_overlay_scrolling(scrolled_window_ptr)) != 0)
            return rv
        }
        /// Enables or disables overlay scrolling for this scrolled window.
        nonmutating set {
            gtk_scrolled_window_set_overlay_scrolling(scrolled_window_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Gets the placement of the contents with respect to the scrollbars
    /// for the scrolled window. See `gtk_scrolled_window_set_placement()`.
    @inlinable var placement: GtkCornerType {
        /// Gets the placement of the contents with respect to the scrollbars
        /// for the scrolled window. See `gtk_scrolled_window_set_placement()`.
        get {
            let rv = gtk_scrolled_window_get_placement(scrolled_window_ptr)
            return rv
        }
        /// Sets the placement of the contents with respect to the scrollbars
        /// for the scrolled window.
        /// 
        /// The default is `GTK_CORNER_TOP_LEFT`, meaning the child is
        /// in the top left, with the scrollbars underneath and to the right.
        /// Other values in `GtkCornerType` are `GTK_CORNER_TOP_RIGHT`,
        /// `GTK_CORNER_BOTTOM_LEFT`, and `GTK_CORNER_BOTTOM_RIGHT`.
        /// 
        /// See also `gtk_scrolled_window_get_placement()` and
        /// `gtk_scrolled_window_unset_placement()`.
        nonmutating set {
            gtk_scrolled_window_set_placement(scrolled_window_ptr, newValue)
        }
    }

    /// Reports whether the natural height of the child will be calculated and propagated
    /// through the scrolled window’s requested natural height.
    @inlinable var propagateNaturalHeight: Bool {
        /// Reports whether the natural height of the child will be calculated and propagated
        /// through the scrolled window’s requested natural height.
        get {
            let rv = ((gtk_scrolled_window_get_propagate_natural_height(scrolled_window_ptr)) != 0)
            return rv
        }
        /// Sets whether the natural height of the child should be calculated and propagated
        /// through the scrolled window’s requested natural height.
        nonmutating set {
            gtk_scrolled_window_set_propagate_natural_height(scrolled_window_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Reports whether the natural width of the child will be calculated and propagated
    /// through the scrolled window’s requested natural width.
    @inlinable var propagateNaturalWidth: Bool {
        /// Reports whether the natural width of the child will be calculated and propagated
        /// through the scrolled window’s requested natural width.
        get {
            let rv = ((gtk_scrolled_window_get_propagate_natural_width(scrolled_window_ptr)) != 0)
            return rv
        }
        /// Sets whether the natural width of the child should be calculated and propagated
        /// through the scrolled window’s requested natural width.
        nonmutating set {
            gtk_scrolled_window_set_propagate_natural_width(scrolled_window_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    @inlinable var vadjustment: AdjustmentRef! {
        /// Returns the vertical scrollbar’s adjustment, used to connect the
        /// vertical scrollbar to the child widget’s vertical scroll functionality.
        get {
            let rv = AdjustmentRef(gconstpointer: gconstpointer(gtk_scrolled_window_get_vadjustment(scrolled_window_ptr)))
            return rv
        }
        /// Sets the `GtkAdjustment` for the vertical scrollbar.
        nonmutating set {
            gtk_scrolled_window_set_vadjustment(scrolled_window_ptr, UnsafeMutablePointer<GtkAdjustment>(newValue?.adjustment_ptr))
        }
    }

    /// Returns the vertical scrollbar of `scrolled_window`.
    @inlinable var vscrollbar: WidgetRef! {
        /// Returns the vertical scrollbar of `scrolled_window`.
        get {
            guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_scrolled_window_get_vscrollbar(scrolled_window_ptr))) else { return nil }
            return rv
        }
    }


}



// MARK: - SearchBar Class

/// The `SearchBarProtocol` protocol exposes the methods and properties of an underlying `GtkSearchBar` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `SearchBar`.
/// Alternatively, use `SearchBarRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkSearchBar` is a container made to have a search entry (possibly
/// with additional connex widgets, such as drop-down menus, or buttons)
/// built-in. The search bar would appear when a search is started through
/// typing on the keyboard, or the application’s search mode is toggled on.
/// 
/// For keyboard presses to start a search, the search bar must be told
/// of a widget to capture key events from through
/// `gtk_search_bar_set_key_capture_widget()`. This widget will typically
/// be the top-level window, or a parent container of the search bar. Common
/// shortcuts such as Ctrl+F should be handled as an application action, or
/// through the menu items.
/// 
/// You will also need to tell the search bar about which entry you
/// are using as your search entry using `gtk_search_bar_connect_entry()`.
/// The following example shows you how to create a more complex search
/// entry.
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// searchbar
/// ╰── revealer
///     ╰── box
///          ├── [child]
///          ╰── [button.close]
/// ```
/// 
/// GtkSearchBar has a main CSS node with name searchbar. It has a child node
/// with name revealer that contains a node with name box. The box node contains both the
/// CSS node of the child widget as well as an optional button node which gets the .close
/// style class applied.
/// 
/// ## Creating a search bar
/// 
/// [A simple example](https://gitlab.gnome.org/GNOME/gtk/tree/master/examples/search-bar.c)
/// 
/// # Accessibility
/// 
/// GtkSearchBar uses the `GTK_ACCESSIBLE_ROLE_SEARCH` role.
public protocol SearchBarProtocol: WidgetProtocol {
        /// Untyped pointer to the underlying `GtkSearchBar` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkSearchBar` instance.
    var search_bar_ptr: UnsafeMutablePointer<GtkSearchBar>! { get }

}

/// The `SearchBarRef` type acts as a lightweight Swift reference to an underlying `GtkSearchBar` instance.
/// It exposes methods that can operate on this data type through `SearchBarProtocol` conformance.
/// Use `SearchBarRef` only as an `unowned` reference to an existing `GtkSearchBar` instance.
///
/// `GtkSearchBar` is a container made to have a search entry (possibly
/// with additional connex widgets, such as drop-down menus, or buttons)
/// built-in. The search bar would appear when a search is started through
/// typing on the keyboard, or the application’s search mode is toggled on.
/// 
/// For keyboard presses to start a search, the search bar must be told
/// of a widget to capture key events from through
/// `gtk_search_bar_set_key_capture_widget()`. This widget will typically
/// be the top-level window, or a parent container of the search bar. Common
/// shortcuts such as Ctrl+F should be handled as an application action, or
/// through the menu items.
/// 
/// You will also need to tell the search bar about which entry you
/// are using as your search entry using `gtk_search_bar_connect_entry()`.
/// The following example shows you how to create a more complex search
/// entry.
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// searchbar
/// ╰── revealer
///     ╰── box
///          ├── [child]
///          ╰── [button.close]
/// ```
/// 
/// GtkSearchBar has a main CSS node with name searchbar. It has a child node
/// with name revealer that contains a node with name box. The box node contains both the
/// CSS node of the child widget as well as an optional button node which gets the .close
/// style class applied.
/// 
/// ## Creating a search bar
/// 
/// [A simple example](https://gitlab.gnome.org/GNOME/gtk/tree/master/examples/search-bar.c)
/// 
/// # Accessibility
/// 
/// GtkSearchBar uses the `GTK_ACCESSIBLE_ROLE_SEARCH` role.
public struct SearchBarRef: SearchBarProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkSearchBar` instance.
    /// For type-safe access, use the generated, typed pointer `search_bar_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension SearchBarRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkSearchBar>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkSearchBar>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkSearchBar>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkSearchBar>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `SearchBarProtocol`
    @inlinable init<T: SearchBarProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: SearchBarProtocol>(_ other: T) -> SearchBarRef { SearchBarRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchBarProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchBarProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchBarProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchBarProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchBarProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a `GtkSearchBar`. You will need to tell it about
    /// which widget is going to be your text entry using
    /// `gtk_search_bar_connect_entry()`.
    @inlinable init() {
        let rv = gtk_search_bar_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `SearchBar` type acts as a reference-counted owner of an underlying `GtkSearchBar` instance.
/// It provides the methods that can operate on this data type through `SearchBarProtocol` conformance.
/// Use `SearchBar` as a strong reference or owner of a `GtkSearchBar` instance.
///
/// `GtkSearchBar` is a container made to have a search entry (possibly
/// with additional connex widgets, such as drop-down menus, or buttons)
/// built-in. The search bar would appear when a search is started through
/// typing on the keyboard, or the application’s search mode is toggled on.
/// 
/// For keyboard presses to start a search, the search bar must be told
/// of a widget to capture key events from through
/// `gtk_search_bar_set_key_capture_widget()`. This widget will typically
/// be the top-level window, or a parent container of the search bar. Common
/// shortcuts such as Ctrl+F should be handled as an application action, or
/// through the menu items.
/// 
/// You will also need to tell the search bar about which entry you
/// are using as your search entry using `gtk_search_bar_connect_entry()`.
/// The following example shows you how to create a more complex search
/// entry.
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// searchbar
/// ╰── revealer
///     ╰── box
///          ├── [child]
///          ╰── [button.close]
/// ```
/// 
/// GtkSearchBar has a main CSS node with name searchbar. It has a child node
/// with name revealer that contains a node with name box. The box node contains both the
/// CSS node of the child widget as well as an optional button node which gets the .close
/// style class applied.
/// 
/// ## Creating a search bar
/// 
/// [A simple example](https://gitlab.gnome.org/GNOME/gtk/tree/master/examples/search-bar.c)
/// 
/// # Accessibility
/// 
/// GtkSearchBar uses the `GTK_ACCESSIBLE_ROLE_SEARCH` role.
open class SearchBar: Widget, SearchBarProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SearchBar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkSearchBar>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SearchBar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkSearchBar>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SearchBar` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SearchBar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SearchBar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkSearchBar>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SearchBar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkSearchBar>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkSearchBar`.
    /// i.e., ownership is transferred to the `SearchBar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkSearchBar>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `SearchBarProtocol`
    /// Will retain `GtkSearchBar`.
    /// - Parameter other: an instance of a related type that implements `SearchBarProtocol`
    @inlinable public init<T: SearchBarProtocol>(searchBar other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchBarProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchBarProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchBarProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchBarProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchBarProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchBarProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchBarProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchBarProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a `GtkSearchBar`. You will need to tell it about
    /// which widget is going to be your text entry using
    /// `gtk_search_bar_connect_entry()`.
    @inlinable public init() {
        let rv = gtk_search_bar_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum SearchBarPropertyName: String, PropertyNameProtocol {
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    case canTarget = "can-target"
    case child = "child"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`. See `gtk_widget_set_cursor()` for details.
    case cursor = "cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    case keyCaptureWidget = "key-capture-widget"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case name = "name"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    case parent = "parent"
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget or `nil` if
    /// the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    /// Whether the search mode is on and the search bar shown.
    /// 
    /// See `gtk_search_bar_set_search_mode()` for details.
    case searchModeEnabled = "search-mode-enabled"
    case sensitive = "sensitive"
    /// Whether to show the close button in the search bar.
    case showCloseButton = "show-close-button"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
}

public extension SearchBarProtocol {
    /// Bind a `SearchBarPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: SearchBarPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a SearchBar property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: SearchBarPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a SearchBar property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: SearchBarPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

// MARK: SearchBar has no signals// MARK: SearchBar Class: SearchBarProtocol extension (methods and fields)
public extension SearchBarProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkSearchBar` instance.
    @inlinable var search_bar_ptr: UnsafeMutablePointer<GtkSearchBar>! { return ptr?.assumingMemoryBound(to: GtkSearchBar.self) }

    /// Connects the `GtkEntry` widget passed as the one to be used in
    /// this search bar. The entry should be a descendant of the search bar.
    /// This is only required if the entry isn’t the direct child of the
    /// search bar (as in our main example).
    @inlinable func connect<EditableT: EditableProtocol>(entry: EditableT) {
        gtk_search_bar_connect_entry(search_bar_ptr, entry.editable_ptr)
    
    }

    /// Gets the child widget of `bar`.
    @inlinable func getChild() -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_search_bar_get_child(search_bar_ptr))) else { return nil }
        return rv
    }

    /// Gets the widget that `bar` is capturing key events from.
    @inlinable func getKeyCaptureWidget() -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_search_bar_get_key_capture_widget(search_bar_ptr))) else { return nil }
        return rv
    }

    /// Returns whether the search mode is on or off.
    @inlinable func getSearchMode() -> Bool {
        let rv = ((gtk_search_bar_get_search_mode(search_bar_ptr)) != 0)
        return rv
    }

    /// Returns whether the close button is shown.
    @inlinable func getShowCloseButton() -> Bool {
        let rv = ((gtk_search_bar_get_show_close_button(search_bar_ptr)) != 0)
        return rv
    }

    /// Sets the child widget of `bar`.
    @inlinable func set(child: WidgetRef? = nil) {
        gtk_search_bar_set_child(search_bar_ptr, child?.widget_ptr)
    
    }
    /// Sets the child widget of `bar`.
    @inlinable func set<WidgetT: WidgetProtocol>(child: WidgetT?) {
        gtk_search_bar_set_child(search_bar_ptr, child?.widget_ptr)
    
    }

    /// Sets `widget` as the widget that `bar` will capture key events from.
    /// 
    /// If key events are handled by the search bar, the bar will
    /// be shown, and the entry populated with the entered text.
    @inlinable func setKeyCapture(widget: WidgetRef? = nil) {
        gtk_search_bar_set_key_capture_widget(search_bar_ptr, widget?.widget_ptr)
    
    }
    /// Sets `widget` as the widget that `bar` will capture key events from.
    /// 
    /// If key events are handled by the search bar, the bar will
    /// be shown, and the entry populated with the entered text.
    @inlinable func setKeyCapture<WidgetT: WidgetProtocol>(widget: WidgetT?) {
        gtk_search_bar_set_key_capture_widget(search_bar_ptr, widget?.widget_ptr)
    
    }

    /// Switches the search mode on or off.
    @inlinable func set(searchMode: Bool) {
        gtk_search_bar_set_search_mode(search_bar_ptr, gboolean((searchMode) ? 1 : 0))
    
    }

    /// Shows or hides the close button. Applications that
    /// already have a “search” toggle button should not show a close
    /// button in their search bar, as it duplicates the role of the
    /// toggle button.
    @inlinable func setShowCloseButton(visible: Bool) {
        gtk_search_bar_set_show_close_button(search_bar_ptr, gboolean((visible) ? 1 : 0))
    
    }
    @inlinable var child: WidgetRef! {
        /// Gets the child widget of `bar`.
        get {
            guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_search_bar_get_child(search_bar_ptr))) else { return nil }
            return rv
        }
        /// Sets the child widget of `bar`.
        nonmutating set {
            gtk_search_bar_set_child(search_bar_ptr, UnsafeMutablePointer<GtkWidget>(newValue?.widget_ptr))
        }
    }

    /// Gets the widget that `bar` is capturing key events from.
    @inlinable var keyCaptureWidget: WidgetRef! {
        /// Gets the widget that `bar` is capturing key events from.
        get {
            guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_search_bar_get_key_capture_widget(search_bar_ptr))) else { return nil }
            return rv
        }
        /// Sets `widget` as the widget that `bar` will capture key events from.
        /// 
        /// If key events are handled by the search bar, the bar will
        /// be shown, and the entry populated with the entered text.
        nonmutating set {
            gtk_search_bar_set_key_capture_widget(search_bar_ptr, UnsafeMutablePointer<GtkWidget>(newValue?.widget_ptr))
        }
    }

    /// Returns whether the search mode is on or off.
    @inlinable var searchMode: Bool {
        /// Returns whether the search mode is on or off.
        get {
            let rv = ((gtk_search_bar_get_search_mode(search_bar_ptr)) != 0)
            return rv
        }
        /// Switches the search mode on or off.
        nonmutating set {
            gtk_search_bar_set_search_mode(search_bar_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns whether the close button is shown.
    @inlinable var showCloseButton: Bool {
        /// Returns whether the close button is shown.
        get {
            let rv = ((gtk_search_bar_get_show_close_button(search_bar_ptr)) != 0)
            return rv
        }
        /// Shows or hides the close button. Applications that
        /// already have a “search” toggle button should not show a close
        /// button in their search bar, as it duplicates the role of the
        /// toggle button.
        nonmutating set {
            gtk_search_bar_set_show_close_button(search_bar_ptr, gboolean((newValue) ? 1 : 0))
        }
    }


}



// MARK: - SearchEntry Class

/// The `SearchEntryProtocol` protocol exposes the methods and properties of an underlying `GtkSearchEntry` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `SearchEntry`.
/// Alternatively, use `SearchEntryRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkSearchEntry` is an entry widget that has been tailored for use
/// as a search entry. The main aPI for interacting with a GtkSearchEntry
/// as entry is the `GtkEditable` interface.
/// 
/// It will show an inactive symbolic “find” icon when the search
/// entry is empty, and a symbolic “clear” icon when there is text.
/// Clicking on the “clear” icon will empty the search entry.
/// 
/// To make filtering appear more reactive, it is a good idea to
/// not react to every change in the entry text immediately, but
/// only after a short delay. To support this, `GtkSearchEntry`
/// emits the `GtkSearchEntry::search`-changed signal which can
/// be used instead of the `GtkEditable::changed` signal.
/// 
/// The `GtkSearchEntry::previous`-match, `GtkSearchEntry::next`-match
/// and `GtkSearchEntry::stop`-search signals can be used to implement
/// moving between search results and ending the search.
/// 
/// Often, GtkSearchEntry will be fed events by means of being
/// placed inside a `GtkSearchBar`. If that is not the case,
/// you can use `gtk_search_entry_set_key_capture_widget()` to let it
/// capture key input from another widget.
/// 
/// # CSS Nodes
/// 
/// (plain Language Example):
/// ```plain
/// entry.search
/// ╰── text
/// ```
/// 
/// GtkSearchEntry has a single CSS node with name entry that carries
/// a .sarch style class, and the text node is a child of that.
/// 
/// # Accessibility
/// 
/// GtkSearchEntry uses the `GTK_ACCESSIBLE_ROLE_SEARCH_BOX` role.
public protocol SearchEntryProtocol: WidgetProtocol, EditableProtocol {
        /// Untyped pointer to the underlying `GtkSearchEntry` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkSearchEntry` instance.
    var search_entry_ptr: UnsafeMutablePointer<GtkSearchEntry>! { get }

}

/// The `SearchEntryRef` type acts as a lightweight Swift reference to an underlying `GtkSearchEntry` instance.
/// It exposes methods that can operate on this data type through `SearchEntryProtocol` conformance.
/// Use `SearchEntryRef` only as an `unowned` reference to an existing `GtkSearchEntry` instance.
///
/// `GtkSearchEntry` is an entry widget that has been tailored for use
/// as a search entry. The main aPI for interacting with a GtkSearchEntry
/// as entry is the `GtkEditable` interface.
/// 
/// It will show an inactive symbolic “find” icon when the search
/// entry is empty, and a symbolic “clear” icon when there is text.
/// Clicking on the “clear” icon will empty the search entry.
/// 
/// To make filtering appear more reactive, it is a good idea to
/// not react to every change in the entry text immediately, but
/// only after a short delay. To support this, `GtkSearchEntry`
/// emits the `GtkSearchEntry::search`-changed signal which can
/// be used instead of the `GtkEditable::changed` signal.
/// 
/// The `GtkSearchEntry::previous`-match, `GtkSearchEntry::next`-match
/// and `GtkSearchEntry::stop`-search signals can be used to implement
/// moving between search results and ending the search.
/// 
/// Often, GtkSearchEntry will be fed events by means of being
/// placed inside a `GtkSearchBar`. If that is not the case,
/// you can use `gtk_search_entry_set_key_capture_widget()` to let it
/// capture key input from another widget.
/// 
/// # CSS Nodes
/// 
/// (plain Language Example):
/// ```plain
/// entry.search
/// ╰── text
/// ```
/// 
/// GtkSearchEntry has a single CSS node with name entry that carries
/// a .sarch style class, and the text node is a child of that.
/// 
/// # Accessibility
/// 
/// GtkSearchEntry uses the `GTK_ACCESSIBLE_ROLE_SEARCH_BOX` role.
public struct SearchEntryRef: SearchEntryProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkSearchEntry` instance.
    /// For type-safe access, use the generated, typed pointer `search_entry_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension SearchEntryRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkSearchEntry>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkSearchEntry>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkSearchEntry>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkSearchEntry>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `SearchEntryProtocol`
    @inlinable init<T: SearchEntryProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: SearchEntryProtocol>(_ other: T) -> SearchEntryRef { SearchEntryRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchEntryProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchEntryProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchEntryProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchEntryProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchEntryProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a `GtkSearchEntry`, with a find icon when the search field is
    /// empty, and a clear icon when it isn't.
    @inlinable init() {
        let rv = gtk_search_entry_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `SearchEntry` type acts as a reference-counted owner of an underlying `GtkSearchEntry` instance.
/// It provides the methods that can operate on this data type through `SearchEntryProtocol` conformance.
/// Use `SearchEntry` as a strong reference or owner of a `GtkSearchEntry` instance.
///
/// `GtkSearchEntry` is an entry widget that has been tailored for use
/// as a search entry. The main aPI for interacting with a GtkSearchEntry
/// as entry is the `GtkEditable` interface.
/// 
/// It will show an inactive symbolic “find” icon when the search
/// entry is empty, and a symbolic “clear” icon when there is text.
/// Clicking on the “clear” icon will empty the search entry.
/// 
/// To make filtering appear more reactive, it is a good idea to
/// not react to every change in the entry text immediately, but
/// only after a short delay. To support this, `GtkSearchEntry`
/// emits the `GtkSearchEntry::search`-changed signal which can
/// be used instead of the `GtkEditable::changed` signal.
/// 
/// The `GtkSearchEntry::previous`-match, `GtkSearchEntry::next`-match
/// and `GtkSearchEntry::stop`-search signals can be used to implement
/// moving between search results and ending the search.
/// 
/// Often, GtkSearchEntry will be fed events by means of being
/// placed inside a `GtkSearchBar`. If that is not the case,
/// you can use `gtk_search_entry_set_key_capture_widget()` to let it
/// capture key input from another widget.
/// 
/// # CSS Nodes
/// 
/// (plain Language Example):
/// ```plain
/// entry.search
/// ╰── text
/// ```
/// 
/// GtkSearchEntry has a single CSS node with name entry that carries
/// a .sarch style class, and the text node is a child of that.
/// 
/// # Accessibility
/// 
/// GtkSearchEntry uses the `GTK_ACCESSIBLE_ROLE_SEARCH_BOX` role.
open class SearchEntry: Widget, SearchEntryProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SearchEntry` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkSearchEntry>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SearchEntry` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkSearchEntry>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SearchEntry` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SearchEntry` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SearchEntry` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkSearchEntry>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SearchEntry` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkSearchEntry>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkSearchEntry`.
    /// i.e., ownership is transferred to the `SearchEntry` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkSearchEntry>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `SearchEntryProtocol`
    /// Will retain `GtkSearchEntry`.
    /// - Parameter other: an instance of a related type that implements `SearchEntryProtocol`
    @inlinable public init<T: SearchEntryProtocol>(searchEntry other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchEntryProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchEntryProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchEntryProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchEntryProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchEntryProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchEntryProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchEntryProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchEntryProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a `GtkSearchEntry`, with a find icon when the search field is
    /// empty, and a clear icon when it isn't.
    @inlinable public init() {
        let rv = gtk_search_entry_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum SearchEntryPropertyName: String, PropertyNameProtocol {
    case activatesDefault = "activates-default"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`. See `gtk_widget_set_cursor()` for details.
    case cursor = "cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case name = "name"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    case parent = "parent"
    case placeholderText = "placeholder-text"
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget or `nil` if
    /// the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
}

public extension SearchEntryProtocol {
    /// Bind a `SearchEntryPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: SearchEntryPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a SearchEntry property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: SearchEntryPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a SearchEntry property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: SearchEntryPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

// MARK: Signals of SearchEntry
public extension SearchEntryProtocol {
    /// The `activate` signal is forwarded from the
    /// `GtkText::activated` signal, which is a keybinding
    /// signal for all forms of the Enter key.
    /// - Note: Representation of signal named `activate`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    @discardableResult
    func onActivate(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SearchEntryRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<SearchEntryRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SearchEntryRef(raw: unownedSelf))
            return output
        }
        return signalConnectData(
            detailedSignal: "activate", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The `next`-match signal is a [keybinding signal](#GtkSignalAction)
    /// which gets emitted when the user initiates a move to the next match
    /// for the current search string.
    /// 
    /// Applications should connect to it, to implement moving between
    /// matches.
    /// 
    /// The default bindings for this signal is Ctrl-g.
    /// - Note: Representation of signal named `next-match`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    @discardableResult
    func onNextMatch(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SearchEntryRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<SearchEntryRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SearchEntryRef(raw: unownedSelf))
            return output
        }
        return signalConnectData(
            detailedSignal: "next-match", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The `previous`-match signal is a [keybinding signal](#GtkSignalAction)
    /// which gets emitted when the user initiates a move to the previous match
    /// for the current search string.
    /// 
    /// Applications should connect to it, to implement moving between
    /// matches.
    /// 
    /// The default bindings for this signal is Ctrl-Shift-g.
    /// - Note: Representation of signal named `previous-match`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    @discardableResult
    func onPreviousMatch(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SearchEntryRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<SearchEntryRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SearchEntryRef(raw: unownedSelf))
            return output
        }
        return signalConnectData(
            detailedSignal: "previous-match", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The `GtkSearchEntry::search`-changed signal is emitted with a short
    /// delay of 150 milliseconds after the last change to the entry text.
    /// - Note: Representation of signal named `search-changed`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    @discardableResult
    func onSearchChanged(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SearchEntryRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<SearchEntryRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SearchEntryRef(raw: unownedSelf))
            return output
        }
        return signalConnectData(
            detailedSignal: "search-changed", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The `search`-started signal gets emitted when the user initiated
    /// a search on the entry.
    /// - Note: Representation of signal named `search-started`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    @discardableResult
    func onSearchStarted(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SearchEntryRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<SearchEntryRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SearchEntryRef(raw: unownedSelf))
            return output
        }
        return signalConnectData(
            detailedSignal: "search-started", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The `stop`-search signal is a [keybinding signal](#GtkSignalAction)
    /// which gets emitted when the user stops a search via keyboard input.
    /// 
    /// Applications should connect to it, to implement hiding the search
    /// entry in this case.
    /// 
    /// The default bindings for this signal is Escape.
    /// - Note: Representation of signal named `stop-search`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    @discardableResult
    func onStopSearch(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SearchEntryRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<SearchEntryRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SearchEntryRef(raw: unownedSelf))
            return output
        }
        return signalConnectData(
            detailedSignal: "stop-search", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::activates-default`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyActivatesDefault(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SearchEntryRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<SearchEntryRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SearchEntryRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::activates-default", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::placeholder-text`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyPlaceholderText(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SearchEntryRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<SearchEntryRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SearchEntryRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::placeholder-text", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
}

// MARK: SearchEntry Class: SearchEntryProtocol extension (methods and fields)
public extension SearchEntryProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkSearchEntry` instance.
    @inlinable var search_entry_ptr: UnsafeMutablePointer<GtkSearchEntry>! { return ptr?.assumingMemoryBound(to: GtkSearchEntry.self) }

    /// Gets the widget that `entry` is capturing key events from.
    @inlinable func getKeyCaptureWidget() -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_search_entry_get_key_capture_widget(search_entry_ptr))) else { return nil }
        return rv
    }

    /// Sets `widget` as the widget that `entry` will capture key events from.
    /// 
    /// Key events are consumed by the search entry to start or
    /// continue a search.
    /// 
    /// If the entry is part of a `GtkSearchBar`, it is preferable
    /// to call `gtk_search_bar_set_key_capture_widget()` instead, which
    /// will reveal the entry in addition to triggering the search entry.
    @inlinable func setKeyCapture(widget: WidgetRef? = nil) {
        gtk_search_entry_set_key_capture_widget(search_entry_ptr, widget?.widget_ptr)
    
    }
    /// Sets `widget` as the widget that `entry` will capture key events from.
    /// 
    /// Key events are consumed by the search entry to start or
    /// continue a search.
    /// 
    /// If the entry is part of a `GtkSearchBar`, it is preferable
    /// to call `gtk_search_bar_set_key_capture_widget()` instead, which
    /// will reveal the entry in addition to triggering the search entry.
    @inlinable func setKeyCapture<WidgetT: WidgetProtocol>(widget: WidgetT?) {
        gtk_search_entry_set_key_capture_widget(search_entry_ptr, widget?.widget_ptr)
    
    }
    /// Gets the widget that `entry` is capturing key events from.
    @inlinable var keyCaptureWidget: WidgetRef! {
        /// Gets the widget that `entry` is capturing key events from.
        get {
            guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_search_entry_get_key_capture_widget(search_entry_ptr))) else { return nil }
            return rv
        }
        /// Sets `widget` as the widget that `entry` will capture key events from.
        /// 
        /// Key events are consumed by the search entry to start or
        /// continue a search.
        /// 
        /// If the entry is part of a `GtkSearchBar`, it is preferable
        /// to call `gtk_search_bar_set_key_capture_widget()` instead, which
        /// will reveal the entry in addition to triggering the search entry.
        nonmutating set {
            gtk_search_entry_set_key_capture_widget(search_entry_ptr, UnsafeMutablePointer<GtkWidget>(newValue?.widget_ptr))
        }
    }


}



// MARK: - SelectionFilterModel Class

/// The `SelectionFilterModelProtocol` protocol exposes the methods and properties of an underlying `GtkSelectionFilterModel` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `SelectionFilterModel`.
/// Alternatively, use `SelectionFilterModelRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkSelectionFilterModel` is a list model that presents the
/// selected items in a `GtkSelectionModel` as its own list model.
public protocol SelectionFilterModelProtocol: GLibObject.ObjectProtocol, GIO.ListModelProtocol {
        /// Untyped pointer to the underlying `GtkSelectionFilterModel` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkSelectionFilterModel` instance.
    var selection_filter_model_ptr: UnsafeMutablePointer<GtkSelectionFilterModel>! { get }

}

/// The `SelectionFilterModelRef` type acts as a lightweight Swift reference to an underlying `GtkSelectionFilterModel` instance.
/// It exposes methods that can operate on this data type through `SelectionFilterModelProtocol` conformance.
/// Use `SelectionFilterModelRef` only as an `unowned` reference to an existing `GtkSelectionFilterModel` instance.
///
/// `GtkSelectionFilterModel` is a list model that presents the
/// selected items in a `GtkSelectionModel` as its own list model.
public struct SelectionFilterModelRef: SelectionFilterModelProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkSelectionFilterModel` instance.
    /// For type-safe access, use the generated, typed pointer `selection_filter_model_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension SelectionFilterModelRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkSelectionFilterModel>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkSelectionFilterModel>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkSelectionFilterModel>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkSelectionFilterModel>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `SelectionFilterModelProtocol`
    @inlinable init<T: SelectionFilterModelProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: SelectionFilterModelProtocol>(_ other: T) -> SelectionFilterModelRef { SelectionFilterModelRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SelectionFilterModelProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SelectionFilterModelProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SelectionFilterModelProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SelectionFilterModelProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SelectionFilterModelProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkSelectionFilterModel` that will include the
    /// selected items from the underlying selection model.
    @inlinable init<SelectionModelT: SelectionModelProtocol>( model: SelectionModelT?) {
        let rv = gtk_selection_filter_model_new(model?.selection_model_ptr)
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `SelectionFilterModel` type acts as a reference-counted owner of an underlying `GtkSelectionFilterModel` instance.
/// It provides the methods that can operate on this data type through `SelectionFilterModelProtocol` conformance.
/// Use `SelectionFilterModel` as a strong reference or owner of a `GtkSelectionFilterModel` instance.
///
/// `GtkSelectionFilterModel` is a list model that presents the
/// selected items in a `GtkSelectionModel` as its own list model.
open class SelectionFilterModel: GLibObject.Object, SelectionFilterModelProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SelectionFilterModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkSelectionFilterModel>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SelectionFilterModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkSelectionFilterModel>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SelectionFilterModel` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SelectionFilterModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SelectionFilterModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkSelectionFilterModel>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SelectionFilterModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkSelectionFilterModel>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkSelectionFilterModel`.
    /// i.e., ownership is transferred to the `SelectionFilterModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkSelectionFilterModel>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `SelectionFilterModelProtocol`
    /// Will retain `GtkSelectionFilterModel`.
    /// - Parameter other: an instance of a related type that implements `SelectionFilterModelProtocol`
    @inlinable public init<T: SelectionFilterModelProtocol>(selectionFilterModel other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SelectionFilterModelProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SelectionFilterModelProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SelectionFilterModelProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SelectionFilterModelProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SelectionFilterModelProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SelectionFilterModelProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SelectionFilterModelProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SelectionFilterModelProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkSelectionFilterModel` that will include the
    /// selected items from the underlying selection model.
    @inlinable public init<SelectionModelT: SelectionModelProtocol>( model: SelectionModelT?) {
        let rv = gtk_selection_filter_model_new(model?.selection_model_ptr)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum SelectionFilterModelPropertyName: String, PropertyNameProtocol {
    /// The model being filtered
    case model = "model"
}

public extension SelectionFilterModelProtocol {
    /// Bind a `SelectionFilterModelPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: SelectionFilterModelPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a SelectionFilterModel property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: SelectionFilterModelPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a SelectionFilterModel property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: SelectionFilterModelPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

// MARK: SelectionFilterModel has no signals// MARK: SelectionFilterModel Class: SelectionFilterModelProtocol extension (methods and fields)
public extension SelectionFilterModelProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkSelectionFilterModel` instance.
    @inlinable var selection_filter_model_ptr: UnsafeMutablePointer<GtkSelectionFilterModel>! { return ptr?.assumingMemoryBound(to: GtkSelectionFilterModel.self) }

    /// Gets the model currently filtered or `nil` if none.
    @inlinable func getModel() -> SelectionModelRef! {
        let rv = SelectionModelRef(gconstpointer: gconstpointer(gtk_selection_filter_model_get_model(selection_filter_model_ptr)))
        return rv
    }

    /// Sets the model to be filtered.
    /// 
    /// Note that GTK makes no effort to ensure that `model` conforms to
    /// the item type of `self`. It assumes that the caller knows what they
    /// are doing and have set up an appropriate filter to ensure that item
    /// types match.
    @inlinable func set(model: SelectionModelRef? = nil) {
        gtk_selection_filter_model_set_model(selection_filter_model_ptr, model?.selection_model_ptr)
    
    }
    /// Sets the model to be filtered.
    /// 
    /// Note that GTK makes no effort to ensure that `model` conforms to
    /// the item type of `self`. It assumes that the caller knows what they
    /// are doing and have set up an appropriate filter to ensure that item
    /// types match.
    @inlinable func set<SelectionModelT: SelectionModelProtocol>(model: SelectionModelT?) {
        gtk_selection_filter_model_set_model(selection_filter_model_ptr, model?.selection_model_ptr)
    
    }
    /// The model being filtered
    @inlinable var model: SelectionModelRef! {
        /// Gets the model currently filtered or `nil` if none.
        get {
            let rv = SelectionModelRef(gconstpointer: gconstpointer(gtk_selection_filter_model_get_model(selection_filter_model_ptr)))
            return rv
        }
        /// Sets the model to be filtered.
        /// 
        /// Note that GTK makes no effort to ensure that `model` conforms to
        /// the item type of `self`. It assumes that the caller knows what they
        /// are doing and have set up an appropriate filter to ensure that item
        /// types match.
        nonmutating set {
            gtk_selection_filter_model_set_model(selection_filter_model_ptr, UnsafeMutablePointer<GtkSelectionModel>(newValue?.selection_model_ptr))
        }
    }


}



// MARK: - Separator Class

/// The `SeparatorProtocol` protocol exposes the methods and properties of an underlying `GtkSeparator` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `Separator`.
/// Alternatively, use `SeparatorRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// GtkSeparator is a horizontal or vertical separator widget, depending on the
/// value of the `GtkOrientable:orientation` property, used to group the widgets
/// within a window. It displays a line with a shadow to make it appear sunken
/// into the interface.
/// 
/// # CSS nodes
/// 
/// GtkSeparator has a single CSS node with name separator. The node
/// gets one of the .horizontal or .vertical style classes.
/// 
/// # Accessibility
/// 
/// GtkSeparator uses the `GTK_ACCESSIBLE_ROLE_SEPARATOR` role.
public protocol SeparatorProtocol: WidgetProtocol, OrientableProtocol {
        /// Untyped pointer to the underlying `GtkSeparator` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkSeparator` instance.
    var separator_ptr: UnsafeMutablePointer<GtkSeparator>! { get }

}

/// The `SeparatorRef` type acts as a lightweight Swift reference to an underlying `GtkSeparator` instance.
/// It exposes methods that can operate on this data type through `SeparatorProtocol` conformance.
/// Use `SeparatorRef` only as an `unowned` reference to an existing `GtkSeparator` instance.
///
/// GtkSeparator is a horizontal or vertical separator widget, depending on the
/// value of the `GtkOrientable:orientation` property, used to group the widgets
/// within a window. It displays a line with a shadow to make it appear sunken
/// into the interface.
/// 
/// # CSS nodes
/// 
/// GtkSeparator has a single CSS node with name separator. The node
/// gets one of the .horizontal or .vertical style classes.
/// 
/// # Accessibility
/// 
/// GtkSeparator uses the `GTK_ACCESSIBLE_ROLE_SEPARATOR` role.
public struct SeparatorRef: SeparatorProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkSeparator` instance.
    /// For type-safe access, use the generated, typed pointer `separator_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension SeparatorRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkSeparator>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkSeparator>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkSeparator>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkSeparator>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `SeparatorProtocol`
    @inlinable init<T: SeparatorProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: SeparatorProtocol>(_ other: T) -> SeparatorRef { SeparatorRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SeparatorProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SeparatorProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SeparatorProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SeparatorProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SeparatorProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkSeparator` with the given orientation.
    @inlinable init( orientation: GtkOrientation) {
        let rv = gtk_separator_new(orientation)
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `Separator` type acts as a reference-counted owner of an underlying `GtkSeparator` instance.
/// It provides the methods that can operate on this data type through `SeparatorProtocol` conformance.
/// Use `Separator` as a strong reference or owner of a `GtkSeparator` instance.
///
/// GtkSeparator is a horizontal or vertical separator widget, depending on the
/// value of the `GtkOrientable:orientation` property, used to group the widgets
/// within a window. It displays a line with a shadow to make it appear sunken
/// into the interface.
/// 
/// # CSS nodes
/// 
/// GtkSeparator has a single CSS node with name separator. The node
/// gets one of the .horizontal or .vertical style classes.
/// 
/// # Accessibility
/// 
/// GtkSeparator uses the `GTK_ACCESSIBLE_ROLE_SEPARATOR` role.
open class Separator: Widget, SeparatorProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Separator` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkSeparator>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Separator` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkSeparator>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Separator` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Separator` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Separator` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkSeparator>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Separator` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkSeparator>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkSeparator`.
    /// i.e., ownership is transferred to the `Separator` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkSeparator>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `SeparatorProtocol`
    /// Will retain `GtkSeparator`.
    /// - Parameter other: an instance of a related type that implements `SeparatorProtocol`
    @inlinable public init<T: SeparatorProtocol>(separator other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SeparatorProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SeparatorProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SeparatorProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SeparatorProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SeparatorProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SeparatorProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SeparatorProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SeparatorProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkSeparator` with the given orientation.
    @inlinable public init( orientation: GtkOrientation) {
        let rv = gtk_separator_new(orientation)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum SeparatorPropertyName: String, PropertyNameProtocol {
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`. See `gtk_widget_set_cursor()` for details.
    case cursor = "cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case name = "name"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    case parent = "parent"
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget or `nil` if
    /// the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
}

public extension SeparatorProtocol {
    /// Bind a `SeparatorPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: SeparatorPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a Separator property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: SeparatorPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a Separator property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: SeparatorPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

// MARK: Separator has no signals// MARK: Separator Class: SeparatorProtocol extension (methods and fields)
public extension SeparatorProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkSeparator` instance.
    @inlinable var separator_ptr: UnsafeMutablePointer<GtkSeparator>! { return ptr?.assumingMemoryBound(to: GtkSeparator.self) }



}



// MARK: - Settings Class

/// The `SettingsProtocol` protocol exposes the methods and properties of an underlying `GtkSettings` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `Settings`.
/// Alternatively, use `SettingsRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// GtkSettings provide a mechanism to share global settings between
/// applications.
/// 
/// On the X window system, this sharing is realized by an
/// [XSettings](http://www.freedesktop.org/wiki/Specifications/xsettings-spec)
/// manager that is usually part of the desktop environment, along with
/// utilities that let the user change these settings.
/// 
/// On Wayland, the settings are obtained either via a settings portal,
/// or by reading desktop settings from DConf.
/// 
/// In the absence of these sharing mechanisms, GTK reads default values for
/// settings from `settings.ini` files in `/etc/gtk-4.0`, `$XDG_CONFIG_DIRS/gtk-4.0`
/// and `$XDG_CONFIG_HOME/gtk-4.0`. These files must be valid key files (see
/// `GKeyFile`), and have a section called Settings. Themes can also provide
/// default values for settings by installing a `settings.ini` file
/// next to their `gtk.css` file.
/// 
/// Applications can override system-wide settings by setting the property
/// of the GtkSettings object with `g_object_set()`. This should be restricted
/// to special cases though; GtkSettings are not meant as an application
/// configuration facility.
/// 
/// There is one GtkSettings instance per display. It can be obtained with
/// `gtk_settings_get_for_display()`, but in many cases, it is more convenient
/// to use `gtk_widget_get_settings()`.
public protocol SettingsProtocol: GLibObject.ObjectProtocol, StyleProviderProtocol {
        /// Untyped pointer to the underlying `GtkSettings` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkSettings` instance.
    var settings_ptr: UnsafeMutablePointer<GtkSettings>! { get }

}

/// The `SettingsRef` type acts as a lightweight Swift reference to an underlying `GtkSettings` instance.
/// It exposes methods that can operate on this data type through `SettingsProtocol` conformance.
/// Use `SettingsRef` only as an `unowned` reference to an existing `GtkSettings` instance.
///
/// GtkSettings provide a mechanism to share global settings between
/// applications.
/// 
/// On the X window system, this sharing is realized by an
/// [XSettings](http://www.freedesktop.org/wiki/Specifications/xsettings-spec)
/// manager that is usually part of the desktop environment, along with
/// utilities that let the user change these settings.
/// 
/// On Wayland, the settings are obtained either via a settings portal,
/// or by reading desktop settings from DConf.
/// 
/// In the absence of these sharing mechanisms, GTK reads default values for
/// settings from `settings.ini` files in `/etc/gtk-4.0`, `$XDG_CONFIG_DIRS/gtk-4.0`
/// and `$XDG_CONFIG_HOME/gtk-4.0`. These files must be valid key files (see
/// `GKeyFile`), and have a section called Settings. Themes can also provide
/// default values for settings by installing a `settings.ini` file
/// next to their `gtk.css` file.
/// 
/// Applications can override system-wide settings by setting the property
/// of the GtkSettings object with `g_object_set()`. This should be restricted
/// to special cases though; GtkSettings are not meant as an application
/// configuration facility.
/// 
/// There is one GtkSettings instance per display. It can be obtained with
/// `gtk_settings_get_for_display()`, but in many cases, it is more convenient
/// to use `gtk_widget_get_settings()`.
public struct SettingsRef: SettingsProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkSettings` instance.
    /// For type-safe access, use the generated, typed pointer `settings_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension SettingsRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkSettings>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkSettings>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkSettings>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkSettings>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `SettingsProtocol`
    @inlinable init<T: SettingsProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: SettingsProtocol>(_ other: T) -> SettingsRef { SettingsRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SettingsProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SettingsProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SettingsProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SettingsProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SettingsProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Gets the `GtkSettings` object for the default display, creating
    /// it if necessary. See `gtk_settings_get_for_display()`.
    @inlinable static func getDefault() -> SettingsRef! {
        guard let rv = SettingsRef(gconstpointer: gconstpointer(gtk_settings_get_default())) else { return nil }
        return rv
    }

    /// Gets the `GtkSettings` object for `display`, creating it if necessary.
    @inlinable static func getFor<DisplayT: Gdk.DisplayProtocol>(display: DisplayT) -> SettingsRef! {
        guard let rv = SettingsRef(gconstpointer: gconstpointer(gtk_settings_get_for_display(display.display_ptr))) else { return nil }
        return rv
    }
}

/// The `Settings` type acts as a reference-counted owner of an underlying `GtkSettings` instance.
/// It provides the methods that can operate on this data type through `SettingsProtocol` conformance.
/// Use `Settings` as a strong reference or owner of a `GtkSettings` instance.
///
/// GtkSettings provide a mechanism to share global settings between
/// applications.
/// 
/// On the X window system, this sharing is realized by an
/// [XSettings](http://www.freedesktop.org/wiki/Specifications/xsettings-spec)
/// manager that is usually part of the desktop environment, along with
/// utilities that let the user change these settings.
/// 
/// On Wayland, the settings are obtained either via a settings portal,
/// or by reading desktop settings from DConf.
/// 
/// In the absence of these sharing mechanisms, GTK reads default values for
/// settings from `settings.ini` files in `/etc/gtk-4.0`, `$XDG_CONFIG_DIRS/gtk-4.0`
/// and `$XDG_CONFIG_HOME/gtk-4.0`. These files must be valid key files (see
/// `GKeyFile`), and have a section called Settings. Themes can also provide
/// default values for settings by installing a `settings.ini` file
/// next to their `gtk.css` file.
/// 
/// Applications can override system-wide settings by setting the property
/// of the GtkSettings object with `g_object_set()`. This should be restricted
/// to special cases though; GtkSettings are not meant as an application
/// configuration facility.
/// 
/// There is one GtkSettings instance per display. It can be obtained with
/// `gtk_settings_get_for_display()`, but in many cases, it is more convenient
/// to use `gtk_widget_get_settings()`.
open class Settings: GLibObject.Object, SettingsProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Settings` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkSettings>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Settings` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkSettings>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Settings` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Settings` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Settings` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkSettings>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Settings` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkSettings>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkSettings`.
    /// i.e., ownership is transferred to the `Settings` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkSettings>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `SettingsProtocol`
    /// Will retain `GtkSettings`.
    /// - Parameter other: an instance of a related type that implements `SettingsProtocol`
    @inlinable public init<T: SettingsProtocol>(settings other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SettingsProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SettingsProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SettingsProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SettingsProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SettingsProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SettingsProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SettingsProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SettingsProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }


    /// Gets the `GtkSettings` object for the default display, creating
    /// it if necessary. See `gtk_settings_get_for_display()`.
    @inlinable public static func getDefault() -> Settings! {
        guard let rv = Settings(gconstpointer: gconstpointer(gtk_settings_get_default())) else { return nil }
        if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
        return rv
    }

    /// Gets the `GtkSettings` object for `display`, creating it if necessary.
    @inlinable public static func getFor<DisplayT: Gdk.DisplayProtocol>(display: DisplayT) -> Settings! {
        guard let rv = Settings(gconstpointer: gconstpointer(gtk_settings_get_for_display(display.display_ptr))) else { return nil }
        if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
        return rv
    }

}

public enum SettingsPropertyName: String, PropertyNameProtocol {
    case gtkAlternativeButtonOrder = "gtk-alternative-button-order"
    /// Controls the direction of the sort indicators in sorted list and tree
    /// views. By default an arrow pointing down means the column is sorted
    /// in ascending order. When set to `true`, this order will be inverted.
    case gtkAlternativeSortArrows = "gtk-alternative-sort-arrows"
    /// Whether the application prefers to use a dark theme. If a GTK theme
    /// includes a dark variant, it will be used instead of the configured
    /// theme.
    /// 
    /// Some applications benefit from minimizing the amount of light pollution that
    /// interferes with the content. Good candidates for dark themes are photo and
    /// video editors that make the actual content get all the attention and minimize
    /// the distraction of the chrome.
    /// 
    /// Dark themes should not be used for documents, where large spaces are white/light
    /// and the dark chrome creates too much contrast (web browser, text editor...).
    case gtkApplicationPreferDarkTheme = "gtk-application-prefer-dark-theme"
    case gtkCursorAspectRatio = "gtk-cursor-aspect-ratio"
    /// Whether the cursor should blink.
    /// 
    /// Also see the `GtkSettings:gtk`-cursor-blink-timeout setting,
    /// which allows more flexible control over cursor blinking.
    case gtkCursorBlink = "gtk-cursor-blink"
    case gtkCursorBlinkTime = "gtk-cursor-blink-time"
    /// Time after which the cursor stops blinking, in seconds.
    /// The timer is reset after each user interaction.
    /// 
    /// Setting this to zero has the same effect as setting
    /// `GtkSettings:gtk`-cursor-blink to `false`.
    case gtkCursorBlinkTimeout = "gtk-cursor-blink-timeout"
    case gtkCursorThemeName = "gtk-cursor-theme-name"
    case gtkCursorThemeSize = "gtk-cursor-theme-size"
    /// This setting determines which buttons should be put in the
    /// titlebar of client-side decorated windows, and whether they
    /// should be placed at the left of right.
    /// 
    /// The format of the string is button names, separated by commas.
    /// A colon separates the buttons that should appear on the left
    /// from those on the right. Recognized button names are minimize,
    /// maximize, close, icon (the window icon) and menu (a menu button
    /// for the fallback app menu).
    /// 
    /// For example, "menu:minimize,maximize,close" specifies a menu
    /// on the left, and minimize, maximize and close buttons on the right.
    /// 
    /// Note that buttons will only be shown when they are meaningful.
    /// E.g. a menu button only appears when the desktop shell does not
    /// show the app menu, and a close button only appears on a window
    /// that can be closed.
    /// 
    /// Also note that the setting can be overridden with the
    /// `GtkHeaderBar:decoration`-layout property.
    case gtkDecorationLayout = "gtk-decoration-layout"
    /// Whether builtin GTK dialogs such as the file chooser, the
    /// color chooser or the font chooser will use a header bar at
    /// the top to show action widgets, or an action area at the bottom.
    /// 
    /// This setting does not affect custom dialogs using GtkDialog
    /// directly, or message dialogs.
    case gtkDialogsUseHeader = "gtk-dialogs-use-header"
    case gtkDndDragThreshold = "gtk-dnd-drag-threshold"
    case gtkDoubleClickDistance = "gtk-double-click-distance"
    case gtkDoubleClickTime = "gtk-double-click-time"
    /// Whether menu items should have visible accelerators which can be
    /// activated.
    case gtkEnableAccels = "gtk-enable-accels"
    case gtkEnableAnimations = "gtk-enable-animations"
    /// Whether to play any event sounds at all.
    /// 
    /// See the [Sound Theme Specifications](http://www.freedesktop.org/wiki/Specifications/sound-theme-spec)
    /// for more information on event sounds and sound themes.
    /// 
    /// GTK itself does not support event sounds, you have to use a loadable
    /// module like the one that comes with libcanberra.
    case gtkEnableEventSounds = "gtk-enable-event-sounds"
    /// Whether to play event sounds as feedback to user input.
    /// 
    /// See the [Sound Theme Specifications](http://www.freedesktop.org/wiki/Specifications/sound-theme-spec)
    /// for more information on event sounds and sound themes.
    /// 
    /// GTK itself does not support event sounds, you have to use a loadable
    /// module like the one that comes with libcanberra.
    case gtkEnableInputFeedbackSounds = "gtk-enable-input-feedback-sounds"
    /// Whether a middle click on a mouse should paste the
    /// 'PRIMARY' clipboard content at the cursor location.
    case gtkEnablePrimaryPaste = "gtk-enable-primary-paste"
    /// How long to show the last input character in hidden
    /// entries. This value is in milliseconds. 0 disables showing the
    /// last char. 600 is a good value for enabling it.
    case gtkEntryPasswordHintTimeout = "gtk-entry-password-hint-timeout"
    case gtkEntrySelectOnFocus = "gtk-entry-select-on-focus"
    /// When `true`, keyboard navigation and other input-related errors
    /// will cause a beep. Since the error bell is implemented using
    /// `gdk_surface_beep()`, the windowing system may offer ways to
    /// configure the error bell in many ways, such as flashing the
    /// window or similar visual effects.
    case gtkErrorBell = "gtk-error-bell"
    /// The default font to use. GTK uses the family name and size from this string.
    case gtkFontName = "gtk-font-name"
    case gtkFontconfigTimestamp = "gtk-fontconfig-timestamp"
    case gtkIconThemeName = "gtk-icon-theme-name"
    /// Which IM (input method) module should be used by default. This is the
    /// input method that will be used if the user has not explicitly chosen
    /// another input method from the IM context menu.
    /// This also can be a colon-separated list of input methods, which GTK
    /// will try in turn until it finds one available on the system.
    /// 
    /// See `GtkIMContext`.
    case gtkImModule = "gtk-im-module"
    /// Whether GTK should make sure that text can be navigated with
    /// a caret, even if it is not editable. This is useful when using
    /// a screen reader.
    case gtkKeynavUseCaret = "gtk-keynav-use-caret"
    case gtkLabelSelectOnFocus = "gtk-label-select-on-focus"
    /// The time for a button or touch press to be considered a "long press".
    case gtkLongPressTime = "gtk-long-press-time"
    /// Whether scrolled windows may use overlaid scrolling indicators.
    /// If this is set to `false`, scrolled windows will have permanent
    /// scrollbars.
    case gtkOverlayScrolling = "gtk-overlay-scrolling"
    /// If the value of this setting is `true`, clicking the primary button in a
    /// `GtkRange` trough will move the slider, and hence set the range’s value, to
    /// the point that you clicked. If it is `false`, a primary click will cause the
    /// slider/value to move by the range’s page-size towards the point clicked.
    /// 
    /// Whichever action you choose for the primary button, the other action will
    /// be available by holding Shift and primary-clicking, or (since GTK 3.22.25)
    /// clicking the middle mouse button.
    case gtkPrimaryButtonWarpsSlider = "gtk-primary-button-warps-slider"
    /// A comma-separated list of print backends to use in the print
    /// dialog. Available print backends depend on the GTK installation,
    /// and may include "file", "cups", "lpr" or "papi".
    case gtkPrintBackends = "gtk-print-backends"
    /// A command to run for displaying the print preview. The command
    /// should contain a ``f`` placeholder, which will get replaced by
    /// the path to the pdf file. The command may also contain a ``s``
    /// placeholder, which will get replaced by the path to a file
    /// containing the print settings in the format produced by
    /// `gtk_print_settings_to_file()`.
    /// 
    /// The preview application is responsible for removing the pdf file
    /// and the print settings file when it is done.
    case gtkPrintPreviewCommand = "gtk-print-preview-command"
    /// Whether GTK should keep track of items inside the recently used
    /// resources list. If set to `false`, the list will always be empty.
    case gtkRecentFilesEnabled = "gtk-recent-files-enabled"
    /// The maximum age, in days, of the items inside the recently used
    /// resources list. Items older than this setting will be excised
    /// from the list. If set to 0, the list will always be empty; if
    /// set to -1, no item will be removed.
    case gtkRecentFilesMaxAge = "gtk-recent-files-max-age"
    case gtkShellShowsAppMenu = "gtk-shell-shows-app-menu"
    case gtkShellShowsDesktop = "gtk-shell-shows-desktop"
    case gtkShellShowsMenubar = "gtk-shell-shows-menubar"
    /// The XDG sound theme to use for event sounds.
    /// 
    /// See the [Sound Theme Specifications](http://www.freedesktop.org/wiki/Specifications/sound-theme-spec)
    /// for more information on event sounds and sound themes.
    /// 
    /// GTK itself does not support event sounds, you have to use a loadable
    /// module like the one that comes with libcanberra.
    case gtkSoundThemeName = "gtk-sound-theme-name"
    case gtkSplitCursor = "gtk-split-cursor"
    case gtkThemeName = "gtk-theme-name"
    /// This setting determines the action to take when a double-click
    /// occurs on the titlebar of client-side decorated windows.
    /// 
    /// Recognized actions are minimize, toggle-maximize, menu, lower
    /// or none.
    case gtkTitlebarDoubleClick = "gtk-titlebar-double-click"
    /// This setting determines the action to take when a middle-click
    /// occurs on the titlebar of client-side decorated windows.
    /// 
    /// Recognized actions are minimize, toggle-maximize, menu, lower
    /// or none.
    case gtkTitlebarMiddleClick = "gtk-titlebar-middle-click"
    /// This setting determines the action to take when a right-click
    /// occurs on the titlebar of client-side decorated windows.
    /// 
    /// Recognized actions are minimize, toggle-maximize, menu, lower
    /// or none.
    case gtkTitlebarRightClick = "gtk-titlebar-right-click"
    case gtkXftAntialias = "gtk-xft-antialias"
    case gtkXftDpi = "gtk-xft-dpi"
    case gtkXftHinting = "gtk-xft-hinting"
    case gtkXftHintstyle = "gtk-xft-hintstyle"
    case gtkXftRgba = "gtk-xft-rgba"
}

public extension SettingsProtocol {
    /// Bind a `SettingsPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: SettingsPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a Settings property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: SettingsPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a Settings property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: SettingsPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

// MARK: Settings has no signals// MARK: Settings Class: SettingsProtocol extension (methods and fields)
public extension SettingsProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkSettings` instance.
    @inlinable var settings_ptr: UnsafeMutablePointer<GtkSettings>! { return ptr?.assumingMemoryBound(to: GtkSettings.self) }

    /// Undoes the effect of calling `g_object_set()` to install an
    /// application-specific value for a setting. After this call,
    /// the setting will again follow the session-wide value for
    /// this setting.
    @inlinable func resetProperty(name: UnsafePointer<CChar>!) {
        gtk_settings_reset_property(settings_ptr, name)
    
    }


}



// MARK: - Shortcut Class

/// The `ShortcutProtocol` protocol exposes the methods and properties of an underlying `GtkShortcut` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `Shortcut`.
/// Alternatively, use `ShortcutRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// GtkShortcut is the low level object used for managing keyboard
/// shortcuts.
/// 
/// It contains a description of how to trigger the shortcut via a
/// `GtkShortcutTrigger` and a way to activate the shortcut on a widget
/// via `GtkShortcutAction`.
/// 
/// The actual work is usually done via `GtkShortcutController`, which
/// decides if and when to activate a shortcut. Using that controller
/// directly however is rarely necessary as various higher level
/// convenience APIs exist on `GtkWidgets` that make it easier to use
/// shortcuts in GTK.
/// 
/// `GtkShortcut` does provide functionality to make it easy for users
/// to work with shortcuts, either by providing informational strings
/// for display purposes or by allowing shortcuts to be configured.
public protocol ShortcutProtocol: GLibObject.ObjectProtocol {
        /// Untyped pointer to the underlying `GtkShortcut` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkShortcut` instance.
    var shortcut_ptr: UnsafeMutablePointer<GtkShortcut>! { get }

}

/// The `ShortcutRef` type acts as a lightweight Swift reference to an underlying `GtkShortcut` instance.
/// It exposes methods that can operate on this data type through `ShortcutProtocol` conformance.
/// Use `ShortcutRef` only as an `unowned` reference to an existing `GtkShortcut` instance.
///
/// GtkShortcut is the low level object used for managing keyboard
/// shortcuts.
/// 
/// It contains a description of how to trigger the shortcut via a
/// `GtkShortcutTrigger` and a way to activate the shortcut on a widget
/// via `GtkShortcutAction`.
/// 
/// The actual work is usually done via `GtkShortcutController`, which
/// decides if and when to activate a shortcut. Using that controller
/// directly however is rarely necessary as various higher level
/// convenience APIs exist on `GtkWidgets` that make it easier to use
/// shortcuts in GTK.
/// 
/// `GtkShortcut` does provide functionality to make it easy for users
/// to work with shortcuts, either by providing informational strings
/// for display purposes or by allowing shortcuts to be configured.
public struct ShortcutRef: ShortcutProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkShortcut` instance.
    /// For type-safe access, use the generated, typed pointer `shortcut_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ShortcutRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkShortcut>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkShortcut>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkShortcut>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkShortcut>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ShortcutProtocol`
    @inlinable init<T: ShortcutProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ShortcutProtocol>(_ other: T) -> ShortcutRef { ShortcutRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkShortcut` that is triggered by `trigger` and then activates
    /// `action`.
    @inlinable init<ShortcutActionT: ShortcutActionProtocol, ShortcutTriggerT: ShortcutTriggerProtocol>( trigger: ShortcutTriggerT?, action: ShortcutActionT?) {
        let rv = gtk_shortcut_new(trigger?.shortcut_trigger_ptr, action?.shortcut_action_ptr)
        ptr = UnsafeMutableRawPointer(rv)
    }


    // *** newWithArguments() is not available because it has a varargs (...) parameter!


    // *** newWithArguments() is not available because it has a varargs (...) parameter!

}

/// The `Shortcut` type acts as a reference-counted owner of an underlying `GtkShortcut` instance.
/// It provides the methods that can operate on this data type through `ShortcutProtocol` conformance.
/// Use `Shortcut` as a strong reference or owner of a `GtkShortcut` instance.
///
/// GtkShortcut is the low level object used for managing keyboard
/// shortcuts.
/// 
/// It contains a description of how to trigger the shortcut via a
/// `GtkShortcutTrigger` and a way to activate the shortcut on a widget
/// via `GtkShortcutAction`.
/// 
/// The actual work is usually done via `GtkShortcutController`, which
/// decides if and when to activate a shortcut. Using that controller
/// directly however is rarely necessary as various higher level
/// convenience APIs exist on `GtkWidgets` that make it easier to use
/// shortcuts in GTK.
/// 
/// `GtkShortcut` does provide functionality to make it easy for users
/// to work with shortcuts, either by providing informational strings
/// for display purposes or by allowing shortcuts to be configured.
open class Shortcut: GLibObject.Object, ShortcutProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Shortcut` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkShortcut>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Shortcut` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkShortcut>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Shortcut` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Shortcut` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Shortcut` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkShortcut>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Shortcut` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkShortcut>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkShortcut`.
    /// i.e., ownership is transferred to the `Shortcut` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkShortcut>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ShortcutProtocol`
    /// Will retain `GtkShortcut`.
    /// - Parameter other: an instance of a related type that implements `ShortcutProtocol`
    @inlinable public init<T: ShortcutProtocol>(shortcut other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkShortcut` that is triggered by `trigger` and then activates
    /// `action`.
    @inlinable public init<ShortcutActionT: ShortcutActionProtocol, ShortcutTriggerT: ShortcutTriggerProtocol>( trigger: ShortcutTriggerT?, action: ShortcutActionT?) {
        let rv = gtk_shortcut_new(trigger?.shortcut_trigger_ptr, action?.shortcut_action_ptr)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


    // *** newWithArguments() is not available because it has a varargs (...) parameter!



    // *** newWithArguments() is not available because it has a varargs (...) parameter!


}

public enum ShortcutPropertyName: String, PropertyNameProtocol {
    /// The action that gets activated by this shortcut.
    case action = "action"
    /// Arguments passed to activation.
    case arguments = "arguments"
    /// The trigger that triggers this shortcut.
    case trigger = "trigger"
}

public extension ShortcutProtocol {
    /// Bind a `ShortcutPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ShortcutPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a Shortcut property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ShortcutPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a Shortcut property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ShortcutPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

// MARK: Shortcut has no signals// MARK: Shortcut Class: ShortcutProtocol extension (methods and fields)
public extension ShortcutProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkShortcut` instance.
    @inlinable var shortcut_ptr: UnsafeMutablePointer<GtkShortcut>! { return ptr?.assumingMemoryBound(to: GtkShortcut.self) }

    /// Gets the action that is activated by this shortcut.
    @inlinable func getAction() -> ShortcutActionRef! {
        let rv = ShortcutActionRef(gconstpointer: gconstpointer(gtk_shortcut_get_action(shortcut_ptr)))
        return rv
    }

    /// Gets the arguments that are passed when activating the shortcut.
    @inlinable func getArguments() -> GLib.VariantRef! {
        let rv = GLib.VariantRef(gtk_shortcut_get_arguments(shortcut_ptr))
        return rv
    }

    /// Gets the trigger used to trigger `self`.
    @inlinable func getTrigger() -> ShortcutTriggerRef! {
        let rv = ShortcutTriggerRef(gconstpointer: gconstpointer(gtk_shortcut_get_trigger(shortcut_ptr)))
        return rv
    }

    /// Sets the new action for `self` to be `action`.
    @inlinable func set(action: ShortcutActionRef? = nil) {
        gtk_shortcut_set_action(shortcut_ptr, action?.shortcut_action_ptr)
    
    }
    /// Sets the new action for `self` to be `action`.
    @inlinable func set<ShortcutActionT: ShortcutActionProtocol>(action: ShortcutActionT?) {
        gtk_shortcut_set_action(shortcut_ptr, action?.shortcut_action_ptr)
    
    }

    /// Sets the arguments to pass when activating the shortcut.
    @inlinable func setArguments(args: GLib.VariantRef? = nil) {
        gtk_shortcut_set_arguments(shortcut_ptr, args?.variant_ptr)
    
    }
    /// Sets the arguments to pass when activating the shortcut.
    @inlinable func setArguments<VariantT: GLib.VariantProtocol>(args: VariantT?) {
        gtk_shortcut_set_arguments(shortcut_ptr, args?.variant_ptr)
    
    }

    /// Sets the new trigger for `self` to be `trigger`.
    @inlinable func set(trigger: ShortcutTriggerRef? = nil) {
        gtk_shortcut_set_trigger(shortcut_ptr, trigger?.shortcut_trigger_ptr)
    
    }
    /// Sets the new trigger for `self` to be `trigger`.
    @inlinable func set<ShortcutTriggerT: ShortcutTriggerProtocol>(trigger: ShortcutTriggerT?) {
        gtk_shortcut_set_trigger(shortcut_ptr, trigger?.shortcut_trigger_ptr)
    
    }
    /// The action that gets activated by this shortcut.
    @inlinable var action: ShortcutActionRef! {
        /// Gets the action that is activated by this shortcut.
        get {
            let rv = ShortcutActionRef(gconstpointer: gconstpointer(gtk_shortcut_get_action(shortcut_ptr)))
            return rv
        }
        /// Sets the new action for `self` to be `action`.
        nonmutating set {
            gtk_shortcut_set_action(shortcut_ptr, UnsafeMutablePointer<GtkShortcutAction>(newValue?.shortcut_action_ptr))
        }
    }

    /// Arguments passed to activation.
    @inlinable var arguments: GLib.VariantRef! {
        /// Gets the arguments that are passed when activating the shortcut.
        get {
            let rv = GLib.VariantRef(gtk_shortcut_get_arguments(shortcut_ptr))
            return rv
        }
        /// Sets the arguments to pass when activating the shortcut.
        nonmutating set {
            gtk_shortcut_set_arguments(shortcut_ptr, UnsafeMutablePointer<GVariant>(newValue?.variant_ptr))
        }
    }

    /// The trigger that triggers this shortcut.
    @inlinable var trigger: ShortcutTriggerRef! {
        /// Gets the trigger used to trigger `self`.
        get {
            let rv = ShortcutTriggerRef(gconstpointer: gconstpointer(gtk_shortcut_get_trigger(shortcut_ptr)))
            return rv
        }
        /// Sets the new trigger for `self` to be `trigger`.
        nonmutating set {
            gtk_shortcut_set_trigger(shortcut_ptr, UnsafeMutablePointer<GtkShortcutTrigger>(newValue?.shortcut_trigger_ptr))
        }
    }


}



// MARK: - ShortcutAction Class

/// The `ShortcutActionProtocol` protocol exposes the methods and properties of an underlying `GtkShortcutAction` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ShortcutAction`.
/// Alternatively, use `ShortcutActionRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkShortcutAction` is the object used to describe what a `GtkShortcut` should
/// do when triggered. To activate a `GtkShortcutAction` manually,
/// `gtk_shortcut_action_activate()` can be called.
/// 
/// `GtkShortcutActions` contain functions that allow easy presentation to end
/// users as well as being printed for debugging.
/// 
/// All `GtkShortcutActions` are immutable, you can only specify their properties
/// during construction. If you want to change a action, you have to replace it
/// with a new one. If you need to pass arguments to an action, these are specified
/// by the higher-level `GtkShortcut` object.
/// 
/// GTK provides various actions:
/// 
///  - `GtkMnemonicAction:` a shortcut action that calls `gtk_widget_mnemonic_activate()`
///  - `GtkCallbackAction:` a shortcut action that invokes a given callback
///  - `GtkSignalAction:` a shortcut action that emits a given signal
///  - `GtkActivateAction:` a shortcut action that calls `gtk_widget_activate()`
///  - `GtkNamedAction:` a shortcut action that calls `gtk_widget_activate_action()`
///  - `GtkNothingAction:` a shortcut action that does nothing
/// 
/// # GtkShortcutAction as GtkBuildable
/// 
/// GtkShortcut
public protocol ShortcutActionProtocol: GLibObject.ObjectProtocol {
        /// Untyped pointer to the underlying `GtkShortcutAction` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkShortcutAction` instance.
    var shortcut_action_ptr: UnsafeMutablePointer<GtkShortcutAction>! { get }

}

/// The `ShortcutActionRef` type acts as a lightweight Swift reference to an underlying `GtkShortcutAction` instance.
/// It exposes methods that can operate on this data type through `ShortcutActionProtocol` conformance.
/// Use `ShortcutActionRef` only as an `unowned` reference to an existing `GtkShortcutAction` instance.
///
/// `GtkShortcutAction` is the object used to describe what a `GtkShortcut` should
/// do when triggered. To activate a `GtkShortcutAction` manually,
/// `gtk_shortcut_action_activate()` can be called.
/// 
/// `GtkShortcutActions` contain functions that allow easy presentation to end
/// users as well as being printed for debugging.
/// 
/// All `GtkShortcutActions` are immutable, you can only specify their properties
/// during construction. If you want to change a action, you have to replace it
/// with a new one. If you need to pass arguments to an action, these are specified
/// by the higher-level `GtkShortcut` object.
/// 
/// GTK provides various actions:
/// 
///  - `GtkMnemonicAction:` a shortcut action that calls `gtk_widget_mnemonic_activate()`
///  - `GtkCallbackAction:` a shortcut action that invokes a given callback
///  - `GtkSignalAction:` a shortcut action that emits a given signal
///  - `GtkActivateAction:` a shortcut action that calls `gtk_widget_activate()`
///  - `GtkNamedAction:` a shortcut action that calls `gtk_widget_activate_action()`
///  - `GtkNothingAction:` a shortcut action that does nothing
/// 
/// # GtkShortcutAction as GtkBuildable
/// 
/// GtkShortcut
public struct ShortcutActionRef: ShortcutActionProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkShortcutAction` instance.
    /// For type-safe access, use the generated, typed pointer `shortcut_action_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ShortcutActionRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkShortcutAction>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkShortcutAction>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkShortcutAction>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkShortcutAction>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ShortcutActionProtocol`
    @inlinable init<T: ShortcutActionProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ShortcutActionProtocol>(_ other: T) -> ShortcutActionRef { ShortcutActionRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutActionProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutActionProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutActionProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutActionProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutActionProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Tries to parse the given string into an action. On
    /// success, the parsed action is returned. When parsing
    /// failed, `nil` is returned.
    /// 
    /// The accepted strings are:
    /// 
    ///   - `nothing`, for `GtkNothingAction`
    ///   - `activate`, for `GtkActivateAction`
    ///   - `mnemonic-activate`, for `GtkMnemonicAction`
    ///   - ``action(NAME)``, for a `GtkNamedAction` for the action named `NAME`
    ///   - ``signal(NAME)``, for a `GtkSignalAction` for the signal `NAME`
    @inlinable init(string: UnsafePointer<CChar>!) {
        let rv = gtk_shortcut_action_parse_string(string)
        ptr = UnsafeMutableRawPointer(rv)
    }
    /// Tries to parse the given string into an action. On
    /// success, the parsed action is returned. When parsing
    /// failed, `nil` is returned.
    /// 
    /// The accepted strings are:
    /// 
    ///   - `nothing`, for `GtkNothingAction`
    ///   - `activate`, for `GtkActivateAction`
    ///   - `mnemonic-activate`, for `GtkMnemonicAction`
    ///   - ``action(NAME)``, for a `GtkNamedAction` for the action named `NAME`
    ///   - ``signal(NAME)``, for a `GtkSignalAction` for the signal `NAME`
    @inlinable static func parse(string: UnsafePointer<CChar>!) -> ShortcutActionRef! {
        guard let rv = ShortcutActionRef(gconstpointer: gconstpointer(gtk_shortcut_action_parse_string(string))) else { return nil }
        return rv
    }
}

/// The `ShortcutAction` type acts as a reference-counted owner of an underlying `GtkShortcutAction` instance.
/// It provides the methods that can operate on this data type through `ShortcutActionProtocol` conformance.
/// Use `ShortcutAction` as a strong reference or owner of a `GtkShortcutAction` instance.
///
/// `GtkShortcutAction` is the object used to describe what a `GtkShortcut` should
/// do when triggered. To activate a `GtkShortcutAction` manually,
/// `gtk_shortcut_action_activate()` can be called.
/// 
/// `GtkShortcutActions` contain functions that allow easy presentation to end
/// users as well as being printed for debugging.
/// 
/// All `GtkShortcutActions` are immutable, you can only specify their properties
/// during construction. If you want to change a action, you have to replace it
/// with a new one. If you need to pass arguments to an action, these are specified
/// by the higher-level `GtkShortcut` object.
/// 
/// GTK provides various actions:
/// 
///  - `GtkMnemonicAction:` a shortcut action that calls `gtk_widget_mnemonic_activate()`
///  - `GtkCallbackAction:` a shortcut action that invokes a given callback
///  - `GtkSignalAction:` a shortcut action that emits a given signal
///  - `GtkActivateAction:` a shortcut action that calls `gtk_widget_activate()`
///  - `GtkNamedAction:` a shortcut action that calls `gtk_widget_activate_action()`
///  - `GtkNothingAction:` a shortcut action that does nothing
/// 
/// # GtkShortcutAction as GtkBuildable
/// 
/// GtkShortcut
open class ShortcutAction: GLibObject.Object, ShortcutActionProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkShortcutAction>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkShortcutAction>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutAction` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkShortcutAction>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkShortcutAction>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkShortcutAction`.
    /// i.e., ownership is transferred to the `ShortcutAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkShortcutAction>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ShortcutActionProtocol`
    /// Will retain `GtkShortcutAction`.
    /// - Parameter other: an instance of a related type that implements `ShortcutActionProtocol`
    @inlinable public init<T: ShortcutActionProtocol>(shortcutAction other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutActionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutActionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutActionProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutActionProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutActionProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutActionProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutActionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutActionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Tries to parse the given string into an action. On
    /// success, the parsed action is returned. When parsing
    /// failed, `nil` is returned.
    /// 
    /// The accepted strings are:
    /// 
    ///   - `nothing`, for `GtkNothingAction`
    ///   - `activate`, for `GtkActivateAction`
    ///   - `mnemonic-activate`, for `GtkMnemonicAction`
    ///   - ``action(NAME)``, for a `GtkNamedAction` for the action named `NAME`
    ///   - ``signal(NAME)``, for a `GtkSignalAction` for the signal `NAME`
    @inlinable public init(string: UnsafePointer<CChar>!) {
        let rv = gtk_shortcut_action_parse_string(string)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Tries to parse the given string into an action. On
    /// success, the parsed action is returned. When parsing
    /// failed, `nil` is returned.
    /// 
    /// The accepted strings are:
    /// 
    ///   - `nothing`, for `GtkNothingAction`
    ///   - `activate`, for `GtkActivateAction`
    ///   - `mnemonic-activate`, for `GtkMnemonicAction`
    ///   - ``action(NAME)``, for a `GtkNamedAction` for the action named `NAME`
    ///   - ``signal(NAME)``, for a `GtkSignalAction` for the signal `NAME`
    @inlinable public static func parse(string: UnsafePointer<CChar>!) -> ShortcutAction! {
        guard let rv = ShortcutAction(gconstpointer: gconstpointer(gtk_shortcut_action_parse_string(string))) else { return nil }
        if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
        return rv
    }

}

// MARK: no ShortcutAction properties

// MARK: ShortcutAction has no signals// MARK: ShortcutAction Class: ShortcutActionProtocol extension (methods and fields)
public extension ShortcutActionProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkShortcutAction` instance.
    @inlinable var shortcut_action_ptr: UnsafeMutablePointer<GtkShortcutAction>! { return ptr?.assumingMemoryBound(to: GtkShortcutAction.self) }

    /// Activates the action on the `widget` with the given `args`.
    /// 
    /// Note that some actions ignore the passed in `flags`, `widget` or `args`.
    /// 
    /// Activation of an action can fail for various reasons. If the action
    /// is not supported by the `widget`, if the `args` don't match the action
    /// or if the activation otherwise had no effect, `false` will be returned.
    @inlinable func activate<WidgetT: WidgetProtocol>(flags: ShortcutActionFlags, widget: WidgetT, args: GLib.VariantRef? = nil) -> Bool {
        let rv = ((gtk_shortcut_action_activate(shortcut_action_ptr, flags.value, widget.widget_ptr, args?.variant_ptr)) != 0)
        return rv
    }
    /// Activates the action on the `widget` with the given `args`.
    /// 
    /// Note that some actions ignore the passed in `flags`, `widget` or `args`.
    /// 
    /// Activation of an action can fail for various reasons. If the action
    /// is not supported by the `widget`, if the `args` don't match the action
    /// or if the activation otherwise had no effect, `false` will be returned.
    @inlinable func activate<VariantT: GLib.VariantProtocol, WidgetT: WidgetProtocol>(flags: ShortcutActionFlags, widget: WidgetT, args: VariantT?) -> Bool {
        let rv = ((gtk_shortcut_action_activate(shortcut_action_ptr, flags.value, widget.widget_ptr, args?.variant_ptr)) != 0)
        return rv
    }

    /// Prints the given action into a string for the developer.
    /// This is meant for debugging and logging.
    /// 
    /// The form of the representation may change at any time and is
    /// not guaranteed to stay identical.
    @inlinable func print<StringTypeT: StringProtocol>(string: StringTypeT) {
        gtk_shortcut_action_print(shortcut_action_ptr, string.gstring_ptr)
    
    }

    /// Prints the given action into a human-readable string.
    /// This is a small wrapper around `gtk_shortcut_action_print()` to help
    /// when debugging.
    @inlinable func toString() -> String! {
        let rv = gtk_shortcut_action_to_string(shortcut_action_ptr).map({ String(cString: $0) })
        return rv
    }


}



// MARK: - ShortcutController Class

/// The `ShortcutControllerProtocol` protocol exposes the methods and properties of an underlying `GtkShortcutController` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ShortcutController`.
/// Alternatively, use `ShortcutControllerRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkShortcutController` is an event controller that manages shortcuts.
/// 
/// Most common shortcuts are using this controller implicitly, e.g. by
/// adding a mnemonic underline to a `GtkLabel`, or by installing a key
/// binding using `gtk_widget_class_add_binding()`, or by adding accelerators
/// to global actions using `gtk_application_set_accels_for_action()`.
/// 
/// But it is possible to create your own shortcut controller, and add
/// shortcuts to it.
/// 
/// `GtkShortcutController` implements `GListModel` for querying the shortcuts that
/// have been added to it.
/// 
/// # GtkShortcutController as a GtkBuildable
/// 
/// GtkShortcutControllers can be creates in ui files to set up shortcuts
/// in the same place as the widgets.
/// 
/// An example of a UI definition fragment with GtkShortcutController:
/// ```
///   <object class='GtkButton'>
///     <child>
///       <object class='GtkShortcutController'>
///         <property name='scope'>managed</property>
///         <child>
///           <object class='GtkShortcut'>
///             <property name='trigger'>&amp;lt;Control&amp;gt;k</property>
///             <property name='action'>activate</property>
///           </object>
///         </child>
///       </object>
///     </child>
///   </object>
/// ```
/// 
/// This example creates a `GtkActivateAction` for triggering the `activate`
/// signal of the GtkButton. See `gtk_shortcut_action_parse_string()` for the syntax
/// for other kinds of `GtkShortcutAction`. See `gtk_shortcut_trigger_parse_string()`
/// to learn more about the syntax for triggers.
public protocol ShortcutControllerProtocol: EventControllerProtocol, GIO.ListModelProtocol, BuildableProtocol {
        /// Untyped pointer to the underlying `GtkShortcutController` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkShortcutController` instance.
    var shortcut_controller_ptr: UnsafeMutablePointer<GtkShortcutController>! { get }

}

/// The `ShortcutControllerRef` type acts as a lightweight Swift reference to an underlying `GtkShortcutController` instance.
/// It exposes methods that can operate on this data type through `ShortcutControllerProtocol` conformance.
/// Use `ShortcutControllerRef` only as an `unowned` reference to an existing `GtkShortcutController` instance.
///
/// `GtkShortcutController` is an event controller that manages shortcuts.
/// 
/// Most common shortcuts are using this controller implicitly, e.g. by
/// adding a mnemonic underline to a `GtkLabel`, or by installing a key
/// binding using `gtk_widget_class_add_binding()`, or by adding accelerators
/// to global actions using `gtk_application_set_accels_for_action()`.
/// 
/// But it is possible to create your own shortcut controller, and add
/// shortcuts to it.
/// 
/// `GtkShortcutController` implements `GListModel` for querying the shortcuts that
/// have been added to it.
/// 
/// # GtkShortcutController as a GtkBuildable
/// 
/// GtkShortcutControllers can be creates in ui files to set up shortcuts
/// in the same place as the widgets.
/// 
/// An example of a UI definition fragment with GtkShortcutController:
/// ```
///   <object class='GtkButton'>
///     <child>
///       <object class='GtkShortcutController'>
///         <property name='scope'>managed</property>
///         <child>
///           <object class='GtkShortcut'>
///             <property name='trigger'>&amp;lt;Control&amp;gt;k</property>
///             <property name='action'>activate</property>
///           </object>
///         </child>
///       </object>
///     </child>
///   </object>
/// ```
/// 
/// This example creates a `GtkActivateAction` for triggering the `activate`
/// signal of the GtkButton. See `gtk_shortcut_action_parse_string()` for the syntax
/// for other kinds of `GtkShortcutAction`. See `gtk_shortcut_trigger_parse_string()`
/// to learn more about the syntax for triggers.
public struct ShortcutControllerRef: ShortcutControllerProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkShortcutController` instance.
    /// For type-safe access, use the generated, typed pointer `shortcut_controller_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ShortcutControllerRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkShortcutController>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkShortcutController>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkShortcutController>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkShortcutController>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ShortcutControllerProtocol`
    @inlinable init<T: ShortcutControllerProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ShortcutControllerProtocol>(_ other: T) -> ShortcutControllerRef { ShortcutControllerRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutControllerProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutControllerProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutControllerProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutControllerProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutControllerProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new shortcut controller.
    @inlinable init() {
        let rv = gtk_shortcut_controller_new()
        ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new shortcut controller that takes its shortcuts from
    /// the given list model.
    /// 
    /// A controller created by this function does not let you add or
    /// remove individual shortcuts using the shortcut controller api,
    /// but you can change the contents of the model.
    @inlinable init<ListModelT: GIO.ListModelProtocol>(model: ListModelT) {
        let rv = gtk_shortcut_controller_new_for_model(model.list_model_ptr)
        ptr = UnsafeMutableRawPointer(rv)
    }
    /// Creates a new shortcut controller that takes its shortcuts from
    /// the given list model.
    /// 
    /// A controller created by this function does not let you add or
    /// remove individual shortcuts using the shortcut controller api,
    /// but you can change the contents of the model.
    @inlinable static func newFor<ListModelT: GIO.ListModelProtocol>(model: ListModelT) -> EventControllerRef! {
        guard let rv = EventControllerRef(gconstpointer: gconstpointer(gtk_shortcut_controller_new_for_model(model.list_model_ptr))) else { return nil }
        return rv
    }
}

/// The `ShortcutController` type acts as a reference-counted owner of an underlying `GtkShortcutController` instance.
/// It provides the methods that can operate on this data type through `ShortcutControllerProtocol` conformance.
/// Use `ShortcutController` as a strong reference or owner of a `GtkShortcutController` instance.
///
/// `GtkShortcutController` is an event controller that manages shortcuts.
/// 
/// Most common shortcuts are using this controller implicitly, e.g. by
/// adding a mnemonic underline to a `GtkLabel`, or by installing a key
/// binding using `gtk_widget_class_add_binding()`, or by adding accelerators
/// to global actions using `gtk_application_set_accels_for_action()`.
/// 
/// But it is possible to create your own shortcut controller, and add
/// shortcuts to it.
/// 
/// `GtkShortcutController` implements `GListModel` for querying the shortcuts that
/// have been added to it.
/// 
/// # GtkShortcutController as a GtkBuildable
/// 
/// GtkShortcutControllers can be creates in ui files to set up shortcuts
/// in the same place as the widgets.
/// 
/// An example of a UI definition fragment with GtkShortcutController:
/// ```
///   <object class='GtkButton'>
///     <child>
///       <object class='GtkShortcutController'>
///         <property name='scope'>managed</property>
///         <child>
///           <object class='GtkShortcut'>
///             <property name='trigger'>&amp;lt;Control&amp;gt;k</property>
///             <property name='action'>activate</property>
///           </object>
///         </child>
///       </object>
///     </child>
///   </object>
/// ```
/// 
/// This example creates a `GtkActivateAction` for triggering the `activate`
/// signal of the GtkButton. See `gtk_shortcut_action_parse_string()` for the syntax
/// for other kinds of `GtkShortcutAction`. See `gtk_shortcut_trigger_parse_string()`
/// to learn more about the syntax for triggers.
open class ShortcutController: EventController, ShortcutControllerProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutController` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkShortcutController>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutController` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkShortcutController>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutController` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutController` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutController` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkShortcutController>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutController` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkShortcutController>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkShortcutController`.
    /// i.e., ownership is transferred to the `ShortcutController` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkShortcutController>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ShortcutControllerProtocol`
    /// Will retain `GtkShortcutController`.
    /// - Parameter other: an instance of a related type that implements `ShortcutControllerProtocol`
    @inlinable public init<T: ShortcutControllerProtocol>(shortcutController other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutControllerProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutControllerProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutControllerProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutControllerProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutControllerProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutControllerProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutControllerProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutControllerProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new shortcut controller.
    @inlinable public init() {
        let rv = gtk_shortcut_controller_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new shortcut controller that takes its shortcuts from
    /// the given list model.
    /// 
    /// A controller created by this function does not let you add or
    /// remove individual shortcuts using the shortcut controller api,
    /// but you can change the contents of the model.
    @inlinable public init<ListModelT: GIO.ListModelProtocol>(model: ListModelT) {
        let rv = gtk_shortcut_controller_new_for_model(model.list_model_ptr)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new shortcut controller that takes its shortcuts from
    /// the given list model.
    /// 
    /// A controller created by this function does not let you add or
    /// remove individual shortcuts using the shortcut controller api,
    /// but you can change the contents of the model.
    @inlinable public static func newFor<ListModelT: GIO.ListModelProtocol>(model: ListModelT) -> EventController! {
        guard let rv = EventController(gconstpointer: gconstpointer(gtk_shortcut_controller_new_for_model(model.list_model_ptr))) else { return nil }
        if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
        return rv
    }

}

public enum ShortcutControllerPropertyName: String, PropertyNameProtocol {
    /// The modifiers that need to be pressed to allow mnemonics activation.
    case mnemonicModifiers = "mnemonic-modifiers"
    /// A list model to take shortcuts from
    case model = "model"
    /// The name for this controller, typically used for debugging purposes.
    case name = "name"
    /// The limit for which events this controller will handle.
    case propagationLimit = "propagation-limit"
    /// The propagation phase at which this controller will handle events.
    case propagationPhase = "propagation-phase"
    /// What scope the shortcuts will be handled in.
    case scope = "scope"
    /// The widget receiving the `GdkEvents` that the controller will handle.
    case widget = "widget"
}

public extension ShortcutControllerProtocol {
    /// Bind a `ShortcutControllerPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ShortcutControllerPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ShortcutController property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ShortcutControllerPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ShortcutController property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ShortcutControllerPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

// MARK: ShortcutController has no signals// MARK: ShortcutController Class: ShortcutControllerProtocol extension (methods and fields)
public extension ShortcutControllerProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkShortcutController` instance.
    @inlinable var shortcut_controller_ptr: UnsafeMutablePointer<GtkShortcutController>! { return ptr?.assumingMemoryBound(to: GtkShortcutController.self) }

    /// Adds `shortcut` to the list of shortcuts handled by `self`.
    /// 
    /// If this controller uses an external shortcut list, this
    /// function does nothing.
    @inlinable func add<ShortcutT: ShortcutProtocol>(shortcut: ShortcutT) {
        gtk_shortcut_controller_add_shortcut(shortcut_controller_ptr, shortcut.shortcut_ptr)
    
    }

    /// Gets the mnemonics modifiers for when this controller activates its shortcuts. See
    /// `gtk_shortcut_controller_set_mnemonics_modifiers()` for details.
    @inlinable func getMnemonicsModifiers() -> Gdk.ModifierType {
        let rv = Gdk.ModifierType(gtk_shortcut_controller_get_mnemonics_modifiers(shortcut_controller_ptr))
        return rv
    }

    /// Gets the scope for when this controller activates its shortcuts. See
    /// `gtk_shortcut_controller_set_scope()` for details.
    @inlinable func getScope() -> GtkShortcutScope {
        let rv = gtk_shortcut_controller_get_scope(shortcut_controller_ptr)
        return rv
    }

    /// Removes `shortcut` from the list of shortcuts handled by `self`.
    /// 
    /// If `shortcut` had not been added to `controller` or this controller
    /// uses an external shortcut list, this function does nothing.
    @inlinable func remove<ShortcutT: ShortcutProtocol>(shortcut: ShortcutT) {
        gtk_shortcut_controller_remove_shortcut(shortcut_controller_ptr, shortcut.shortcut_ptr)
    
    }

    /// Sets the controller to have the given `mnemonics_modifiers`.
    /// 
    /// The mnemonics modifiers determines which modifiers need to be pressed to allow
    /// activation of shortcuts with mnemonics triggers.
    /// 
    /// GTK normally uses the Alt modifier for mnemonics, except in `GtkPopoverMenus`,
    /// where mnemonics can be triggered without any modifiers. It should be very
    /// rarely necessary to change this, and doing so is likely to interfere with
    /// other shortcuts.
    /// 
    /// This value is only relevant for local shortcut controllers. Global and managed
    /// shortcut controllers will have their shortcuts activated from other places which
    /// have their own modifiers for activating mnemonics.
    @inlinable func setMnemonics(modifiers: Gdk.ModifierType) {
        gtk_shortcut_controller_set_mnemonics_modifiers(shortcut_controller_ptr, modifiers.value)
    
    }

    /// Sets the controller to have the given `scope`.
    /// 
    /// The scope allows shortcuts to be activated outside of the normal
    /// event propagation. In particular, it allows installing global
    /// keyboard shortcuts that can be activated even when a widget does
    /// not have focus.
    /// 
    /// With `GTK_SHORTCUT_SCOPE_LOCAL`, shortcuts will only be activated
    /// when the widget has focus.
    @inlinable func set(scope: GtkShortcutScope) {
        gtk_shortcut_controller_set_scope(shortcut_controller_ptr, scope)
    
    }
    /// Gets the mnemonics modifiers for when this controller activates its shortcuts. See
    /// `gtk_shortcut_controller_set_mnemonics_modifiers()` for details.
    @inlinable var mnemonicsModifiers: Gdk.ModifierType {
        /// Gets the mnemonics modifiers for when this controller activates its shortcuts. See
        /// `gtk_shortcut_controller_set_mnemonics_modifiers()` for details.
        get {
            let rv = Gdk.ModifierType(gtk_shortcut_controller_get_mnemonics_modifiers(shortcut_controller_ptr))
            return rv
        }
        /// Sets the controller to have the given `mnemonics_modifiers`.
        /// 
        /// The mnemonics modifiers determines which modifiers need to be pressed to allow
        /// activation of shortcuts with mnemonics triggers.
        /// 
        /// GTK normally uses the Alt modifier for mnemonics, except in `GtkPopoverMenus`,
        /// where mnemonics can be triggered without any modifiers. It should be very
        /// rarely necessary to change this, and doing so is likely to interfere with
        /// other shortcuts.
        /// 
        /// This value is only relevant for local shortcut controllers. Global and managed
        /// shortcut controllers will have their shortcuts activated from other places which
        /// have their own modifiers for activating mnemonics.
        nonmutating set {
            gtk_shortcut_controller_set_mnemonics_modifiers(shortcut_controller_ptr, newValue.value)
        }
    }

    /// What scope the shortcuts will be handled in.
    @inlinable var scope: GtkShortcutScope {
        /// Gets the scope for when this controller activates its shortcuts. See
        /// `gtk_shortcut_controller_set_scope()` for details.
        get {
            let rv = gtk_shortcut_controller_get_scope(shortcut_controller_ptr)
            return rv
        }
        /// Sets the controller to have the given `scope`.
        /// 
        /// The scope allows shortcuts to be activated outside of the normal
        /// event propagation. In particular, it allows installing global
        /// keyboard shortcuts that can be activated even when a widget does
        /// not have focus.
        /// 
        /// With `GTK_SHORTCUT_SCOPE_LOCAL`, shortcuts will only be activated
        /// when the widget has focus.
        nonmutating set {
            gtk_shortcut_controller_set_scope(shortcut_controller_ptr, newValue)
        }
    }


}



// MARK: - ShortcutLabel Class

/// The `ShortcutLabelProtocol` protocol exposes the methods and properties of an underlying `GtkShortcutLabel` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ShortcutLabel`.
/// Alternatively, use `ShortcutLabelRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkShortcutLabel` is a widget that represents a single keyboard shortcut or gesture
/// in the user interface.
public protocol ShortcutLabelProtocol: WidgetProtocol {
        /// Untyped pointer to the underlying `GtkShortcutLabel` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkShortcutLabel` instance.
    var shortcut_label_ptr: UnsafeMutablePointer<GtkShortcutLabel>! { get }

}

/// The `ShortcutLabelRef` type acts as a lightweight Swift reference to an underlying `GtkShortcutLabel` instance.
/// It exposes methods that can operate on this data type through `ShortcutLabelProtocol` conformance.
/// Use `ShortcutLabelRef` only as an `unowned` reference to an existing `GtkShortcutLabel` instance.
///
/// `GtkShortcutLabel` is a widget that represents a single keyboard shortcut or gesture
/// in the user interface.
public struct ShortcutLabelRef: ShortcutLabelProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkShortcutLabel` instance.
    /// For type-safe access, use the generated, typed pointer `shortcut_label_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ShortcutLabelRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkShortcutLabel>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkShortcutLabel>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkShortcutLabel>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkShortcutLabel>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ShortcutLabelProtocol`
    @inlinable init<T: ShortcutLabelProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ShortcutLabelProtocol>(_ other: T) -> ShortcutLabelRef { ShortcutLabelRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutLabelProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutLabelProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutLabelProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutLabelProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutLabelProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkShortcutLabel` with `accelerator` set.
    @inlinable init( accelerator: UnsafePointer<CChar>!) {
        let rv = gtk_shortcut_label_new(accelerator)
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `ShortcutLabel` type acts as a reference-counted owner of an underlying `GtkShortcutLabel` instance.
/// It provides the methods that can operate on this data type through `ShortcutLabelProtocol` conformance.
/// Use `ShortcutLabel` as a strong reference or owner of a `GtkShortcutLabel` instance.
///
/// `GtkShortcutLabel` is a widget that represents a single keyboard shortcut or gesture
/// in the user interface.
open class ShortcutLabel: Widget, ShortcutLabelProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutLabel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkShortcutLabel>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutLabel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkShortcutLabel>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutLabel` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutLabel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutLabel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkShortcutLabel>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutLabel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkShortcutLabel>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkShortcutLabel`.
    /// i.e., ownership is transferred to the `ShortcutLabel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkShortcutLabel>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ShortcutLabelProtocol`
    /// Will retain `GtkShortcutLabel`.
    /// - Parameter other: an instance of a related type that implements `ShortcutLabelProtocol`
    @inlinable public init<T: ShortcutLabelProtocol>(shortcutLabel other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutLabelProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutLabelProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutLabelProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutLabelProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutLabelProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutLabelProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutLabelProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutLabelProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkShortcutLabel` with `accelerator` set.
    @inlinable public init( accelerator: UnsafePointer<CChar>!) {
        let rv = gtk_shortcut_label_new(accelerator)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum ShortcutLabelPropertyName: String, PropertyNameProtocol {
    /// The accelerator that `self` displays. See `GtkShortcutsShortcut:accelerator`
    /// for the accepted syntax.
    case accelerator = "accelerator"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`. See `gtk_widget_set_cursor()` for details.
    case cursor = "cursor"
    /// The text that is displayed when no accelerator is set.
    case disabledText = "disabled-text"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case name = "name"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    case parent = "parent"
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget or `nil` if
    /// the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
}

public extension ShortcutLabelProtocol {
    /// Bind a `ShortcutLabelPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ShortcutLabelPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ShortcutLabel property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ShortcutLabelPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ShortcutLabel property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ShortcutLabelPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

// MARK: ShortcutLabel has no signals// MARK: ShortcutLabel Class: ShortcutLabelProtocol extension (methods and fields)
public extension ShortcutLabelProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkShortcutLabel` instance.
    @inlinable var shortcut_label_ptr: UnsafeMutablePointer<GtkShortcutLabel>! { return ptr?.assumingMemoryBound(to: GtkShortcutLabel.self) }

    /// Retrieves the current accelerator of `self`.
    @inlinable func getAccelerator() -> String! {
        let rv = gtk_shortcut_label_get_accelerator(shortcut_label_ptr).map({ String(cString: $0) })
        return rv
    }

    /// Retrieves the text that is displayed when no accelerator is set.
    @inlinable func getDisabledText() -> String! {
        let rv = gtk_shortcut_label_get_disabled_text(shortcut_label_ptr).map({ String(cString: $0) })
        return rv
    }

    /// Sets the accelerator to be displayed by `self`.
    @inlinable func set(accelerator: UnsafePointer<CChar>!) {
        gtk_shortcut_label_set_accelerator(shortcut_label_ptr, accelerator)
    
    }

    /// Sets the text to be displayed by `self` when no accelerator is set.
    @inlinable func set(disabledText: UnsafePointer<CChar>!) {
        gtk_shortcut_label_set_disabled_text(shortcut_label_ptr, disabledText)
    
    }
    /// The accelerator that `self` displays. See `GtkShortcutsShortcut:accelerator`
    /// for the accepted syntax.
    @inlinable var accelerator: String! {
        /// Retrieves the current accelerator of `self`.
        get {
            let rv = gtk_shortcut_label_get_accelerator(shortcut_label_ptr).map({ String(cString: $0) })
            return rv
        }
        /// Sets the accelerator to be displayed by `self`.
        nonmutating set {
            gtk_shortcut_label_set_accelerator(shortcut_label_ptr, newValue)
        }
    }

    /// Retrieves the text that is displayed when no accelerator is set.
    @inlinable var disabledText: String! {
        /// Retrieves the text that is displayed when no accelerator is set.
        get {
            let rv = gtk_shortcut_label_get_disabled_text(shortcut_label_ptr).map({ String(cString: $0) })
            return rv
        }
        /// Sets the text to be displayed by `self` when no accelerator is set.
        nonmutating set {
            gtk_shortcut_label_set_disabled_text(shortcut_label_ptr, newValue)
        }
    }


}



// MARK: - ShortcutTrigger Class

/// The `ShortcutTriggerProtocol` protocol exposes the methods and properties of an underlying `GtkShortcutTrigger` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ShortcutTrigger`.
/// Alternatively, use `ShortcutTriggerRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkShortcutTrigger` is the object used to track if a `GtkShortcut` should be
/// activated. For this purpose, `gtk_shortcut_trigger_trigger()` can be called
/// on a `GdkEvent`.
/// 
/// `GtkShortcutTriggers` contain functions that allow easy presentation to end
/// users as well as being printed for debugging.
/// 
/// All `GtkShortcutTriggers` are immutable, you can only specify their properties
/// during construction. If you want to change a trigger, you have to replace it
/// with a new one.
public protocol ShortcutTriggerProtocol: GLibObject.ObjectProtocol {
        /// Untyped pointer to the underlying `GtkShortcutTrigger` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkShortcutTrigger` instance.
    var shortcut_trigger_ptr: UnsafeMutablePointer<GtkShortcutTrigger>! { get }

}

/// The `ShortcutTriggerRef` type acts as a lightweight Swift reference to an underlying `GtkShortcutTrigger` instance.
/// It exposes methods that can operate on this data type through `ShortcutTriggerProtocol` conformance.
/// Use `ShortcutTriggerRef` only as an `unowned` reference to an existing `GtkShortcutTrigger` instance.
///
/// `GtkShortcutTrigger` is the object used to track if a `GtkShortcut` should be
/// activated. For this purpose, `gtk_shortcut_trigger_trigger()` can be called
/// on a `GdkEvent`.
/// 
/// `GtkShortcutTriggers` contain functions that allow easy presentation to end
/// users as well as being printed for debugging.
/// 
/// All `GtkShortcutTriggers` are immutable, you can only specify their properties
/// during construction. If you want to change a trigger, you have to replace it
/// with a new one.
public struct ShortcutTriggerRef: ShortcutTriggerProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkShortcutTrigger` instance.
    /// For type-safe access, use the generated, typed pointer `shortcut_trigger_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ShortcutTriggerRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkShortcutTrigger>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkShortcutTrigger>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkShortcutTrigger>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkShortcutTrigger>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ShortcutTriggerProtocol`
    @inlinable init<T: ShortcutTriggerProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ShortcutTriggerProtocol>(_ other: T) -> ShortcutTriggerRef { ShortcutTriggerRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutTriggerProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutTriggerProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutTriggerProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutTriggerProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutTriggerProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Tries to parse the given string into a trigger. On success,
    /// the parsed trigger is returned. When parsing failed, `nil` is
    /// returned.
    /// 
    /// The accepted strings are:
    /// 
    ///   - `never`, for `GtkNeverTrigger`
    ///   - a string parsed by `gtk_accelerator_parse()`, for a `GtkKeyvalTrigger`, e.g. `<Control>C`
    ///   - underscore, followed by a single character, for MnemonicTrigger, e.g. `_l`
    ///   - two valid trigger strings, separated by a `|` character, for a
    ///     `GtkAlternativeTrigger:` `<Control>q|<Control>w`
    /// 
    /// Note that you will have to escape the `<` and `>` characters when specifying
    /// triggers in XML files, such as GtkBuilder ui files. Use `&lt;` instead of
    /// `<` and `&gt;` instead of `>`.
    @inlinable init(string: UnsafePointer<CChar>!) {
        let rv = gtk_shortcut_trigger_parse_string(string)
        ptr = UnsafeMutableRawPointer(rv)
    }
    /// Tries to parse the given string into a trigger. On success,
    /// the parsed trigger is returned. When parsing failed, `nil` is
    /// returned.
    /// 
    /// The accepted strings are:
    /// 
    ///   - `never`, for `GtkNeverTrigger`
    ///   - a string parsed by `gtk_accelerator_parse()`, for a `GtkKeyvalTrigger`, e.g. `<Control>C`
    ///   - underscore, followed by a single character, for MnemonicTrigger, e.g. `_l`
    ///   - two valid trigger strings, separated by a `|` character, for a
    ///     `GtkAlternativeTrigger:` `<Control>q|<Control>w`
    /// 
    /// Note that you will have to escape the `<` and `>` characters when specifying
    /// triggers in XML files, such as GtkBuilder ui files. Use `&lt;` instead of
    /// `<` and `&gt;` instead of `>`.
    @inlinable static func parse(string: UnsafePointer<CChar>!) -> ShortcutTriggerRef! {
        guard let rv = ShortcutTriggerRef(gconstpointer: gconstpointer(gtk_shortcut_trigger_parse_string(string))) else { return nil }
        return rv
    }
}

/// The `ShortcutTrigger` type acts as a reference-counted owner of an underlying `GtkShortcutTrigger` instance.
/// It provides the methods that can operate on this data type through `ShortcutTriggerProtocol` conformance.
/// Use `ShortcutTrigger` as a strong reference or owner of a `GtkShortcutTrigger` instance.
///
/// `GtkShortcutTrigger` is the object used to track if a `GtkShortcut` should be
/// activated. For this purpose, `gtk_shortcut_trigger_trigger()` can be called
/// on a `GdkEvent`.
/// 
/// `GtkShortcutTriggers` contain functions that allow easy presentation to end
/// users as well as being printed for debugging.
/// 
/// All `GtkShortcutTriggers` are immutable, you can only specify their properties
/// during construction. If you want to change a trigger, you have to replace it
/// with a new one.
open class ShortcutTrigger: GLibObject.Object, ShortcutTriggerProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutTrigger` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkShortcutTrigger>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutTrigger` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkShortcutTrigger>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutTrigger` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutTrigger` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutTrigger` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkShortcutTrigger>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutTrigger` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkShortcutTrigger>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkShortcutTrigger`.
    /// i.e., ownership is transferred to the `ShortcutTrigger` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkShortcutTrigger>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ShortcutTriggerProtocol`
    /// Will retain `GtkShortcutTrigger`.
    /// - Parameter other: an instance of a related type that implements `ShortcutTriggerProtocol`
    @inlinable public init<T: ShortcutTriggerProtocol>(shortcutTrigger other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutTriggerProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutTriggerProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutTriggerProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutTriggerProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutTriggerProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutTriggerProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutTriggerProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutTriggerProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Tries to parse the given string into a trigger. On success,
    /// the parsed trigger is returned. When parsing failed, `nil` is
    /// returned.
    /// 
    /// The accepted strings are:
    /// 
    ///   - `never`, for `GtkNeverTrigger`
    ///   - a string parsed by `gtk_accelerator_parse()`, for a `GtkKeyvalTrigger`, e.g. `<Control>C`
    ///   - underscore, followed by a single character, for MnemonicTrigger, e.g. `_l`
    ///   - two valid trigger strings, separated by a `|` character, for a
    ///     `GtkAlternativeTrigger:` `<Control>q|<Control>w`
    /// 
    /// Note that you will have to escape the `<` and `>` characters when specifying
    /// triggers in XML files, such as GtkBuilder ui files. Use `&lt;` instead of
    /// `<` and `&gt;` instead of `>`.
    @inlinable public init(string: UnsafePointer<CChar>!) {
        let rv = gtk_shortcut_trigger_parse_string(string)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Tries to parse the given string into a trigger. On success,
    /// the parsed trigger is returned. When parsing failed, `nil` is
    /// returned.
    /// 
    /// The accepted strings are:
    /// 
    ///   - `never`, for `GtkNeverTrigger`
    ///   - a string parsed by `gtk_accelerator_parse()`, for a `GtkKeyvalTrigger`, e.g. `<Control>C`
    ///   - underscore, followed by a single character, for MnemonicTrigger, e.g. `_l`
    ///   - two valid trigger strings, separated by a `|` character, for a
    ///     `GtkAlternativeTrigger:` `<Control>q|<Control>w`
    /// 
    /// Note that you will have to escape the `<` and `>` characters when specifying
    /// triggers in XML files, such as GtkBuilder ui files. Use `&lt;` instead of
    /// `<` and `&gt;` instead of `>`.
    @inlinable public static func parse(string: UnsafePointer<CChar>!) -> ShortcutTrigger! {
        guard let rv = ShortcutTrigger(gconstpointer: gconstpointer(gtk_shortcut_trigger_parse_string(string))) else { return nil }
        if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
        return rv
    }

}

// MARK: no ShortcutTrigger properties

// MARK: ShortcutTrigger has no signals// MARK: ShortcutTrigger Class: ShortcutTriggerProtocol extension (methods and fields)
public extension ShortcutTriggerProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkShortcutTrigger` instance.
    @inlinable var shortcut_trigger_ptr: UnsafeMutablePointer<GtkShortcutTrigger>! { return ptr?.assumingMemoryBound(to: GtkShortcutTrigger.self) }

    /// The types of `trigger1` and `trigger2` are `gconstpointer` only to allow
    /// use of this function as a `GCompareFunc`. They must each be a
    /// `GtkShortcutTrigger`.
    @inlinable func compare<ShortcutTriggerT: ShortcutTriggerProtocol>(trigger2: ShortcutTriggerT) -> Int {
        let rv = Int(gtk_shortcut_trigger_compare(shortcut_trigger_ptr, trigger2.shortcut_trigger_ptr))
        return rv
    }

    /// Checks if `trigger1` and `trigger2` trigger under the same conditions.
    /// 
    /// The types of `one` and `two` are `gconstpointer` only to allow use of this
    /// function with `GHashTable`. They must each be a `GtkShortcutTrigger`.
    @inlinable func equal<ShortcutTriggerT: ShortcutTriggerProtocol>(trigger2: ShortcutTriggerT) -> Bool {
        let rv = ((gtk_shortcut_trigger_equal(shortcut_trigger_ptr, trigger2.shortcut_trigger_ptr)) != 0)
        return rv
    }

    /// Generates a hash value for a `GtkShortcutTrigger`.
    /// 
    /// The output of this function is guaranteed to be the same for a given
    /// value only per-process.  It may change between different processor
    /// architectures or even different versions of GTK.  Do not use this
    /// function as a basis for building protocols or file formats.
    /// 
    /// The types of `trigger` is `gconstpointer` only to allow use of this
    /// function with `GHashTable`. They must each be a `GtkShortcutTrigger`.
    @inlinable func hash() -> Int {
        let rv = Int(gtk_shortcut_trigger_hash(shortcut_trigger_ptr))
        return rv
    }

    /// Prints the given trigger into a string for the developer.
    /// This is meant for debugging and logging.
    /// 
    /// The form of the representation may change at any time
    /// and is not guaranteed to stay identical.
    @inlinable func print<StringTypeT: StringProtocol>(string: StringTypeT) {
        gtk_shortcut_trigger_print(shortcut_trigger_ptr, string.gstring_ptr)
    
    }

    /// Prints the given trigger into a string. This function is
    /// returning a translated string for presentation to end users
    /// for example in menu items or in help texts.
    /// 
    /// The `display` in use may influence the resulting string in
    /// various forms, such as resolving hardware keycodes or by
    /// causing display-specific modifier names.
    /// 
    /// The form of the representation may change at any time and is
    /// not guaranteed to stay identical.
    @inlinable func printLabel<DisplayT: Gdk.DisplayProtocol, StringTypeT: StringProtocol>(display: DisplayT, string: StringTypeT) -> Bool {
        let rv = ((gtk_shortcut_trigger_print_label(shortcut_trigger_ptr, display.display_ptr, string.gstring_ptr)) != 0)
        return rv
    }

    /// Gets textual representation for the given trigger. This
    /// function is returning a translated string for presentation
    /// to end users for example in menu items or in help texts.
    /// 
    /// The `display` in use may influence the resulting string in
    /// various forms, such as resolving hardware keycodes or by
    /// causing display-specific modifier names.
    /// 
    /// The form of the representation may change at any time and is
    /// not guaranteed to stay identical.
    @inlinable func toLabel<DisplayT: Gdk.DisplayProtocol>(display: DisplayT) -> String! {
        let rv = gtk_shortcut_trigger_to_label(shortcut_trigger_ptr, display.display_ptr).map({ String(cString: $0) })
        return rv
    }

    /// Prints the given trigger into a human-readable string.
    /// This is a small wrapper around `gtk_shortcut_trigger_print()`
    /// to help when debugging.
    @inlinable func toString() -> String! {
        let rv = gtk_shortcut_trigger_to_string(shortcut_trigger_ptr).map({ String(cString: $0) })
        return rv
    }

    /// Checks if the given `event` triggers `self`.
    @inlinable func trigger<EventT: Gdk.EventProtocol>(event: EventT, enableMnemonics: Bool) -> GdkKeyMatch {
        let rv = gtk_shortcut_trigger_trigger(shortcut_trigger_ptr, event.event_ptr, gboolean((enableMnemonics) ? 1 : 0))
        return rv
    }


}



// MARK: - ShortcutsGroup Class

/// The `ShortcutsGroupProtocol` protocol exposes the methods and properties of an underlying `GtkShortcutsGroup` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ShortcutsGroup`.
/// Alternatively, use `ShortcutsGroupRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A GtkShortcutsGroup represents a group of related keyboard shortcuts
/// or gestures. The group has a title. It may optionally be associated with
/// a view of the application, which can be used to show only relevant shortcuts
/// depending on the application context.
/// 
/// This widget is only meant to be used with `GtkShortcutsWindow`.
public protocol ShortcutsGroupProtocol: BoxProtocol {
        /// Untyped pointer to the underlying `GtkShortcutsGroup` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkShortcutsGroup` instance.
    var shortcuts_group_ptr: UnsafeMutablePointer<GtkShortcutsGroup>! { get }

}

/// The `ShortcutsGroupRef` type acts as a lightweight Swift reference to an underlying `GtkShortcutsGroup` instance.
/// It exposes methods that can operate on this data type through `ShortcutsGroupProtocol` conformance.
/// Use `ShortcutsGroupRef` only as an `unowned` reference to an existing `GtkShortcutsGroup` instance.
///
/// A GtkShortcutsGroup represents a group of related keyboard shortcuts
/// or gestures. The group has a title. It may optionally be associated with
/// a view of the application, which can be used to show only relevant shortcuts
/// depending on the application context.
/// 
/// This widget is only meant to be used with `GtkShortcutsWindow`.
public struct ShortcutsGroupRef: ShortcutsGroupProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkShortcutsGroup` instance.
    /// For type-safe access, use the generated, typed pointer `shortcuts_group_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ShortcutsGroupRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkShortcutsGroup>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkShortcutsGroup>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkShortcutsGroup>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkShortcutsGroup>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ShortcutsGroupProtocol`
    @inlinable init<T: ShortcutsGroupProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ShortcutsGroupProtocol>(_ other: T) -> ShortcutsGroupRef { ShortcutsGroupRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsGroupProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsGroupProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsGroupProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsGroupProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsGroupProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `ShortcutsGroup` type acts as a reference-counted owner of an underlying `GtkShortcutsGroup` instance.
/// It provides the methods that can operate on this data type through `ShortcutsGroupProtocol` conformance.
/// Use `ShortcutsGroup` as a strong reference or owner of a `GtkShortcutsGroup` instance.
///
/// A GtkShortcutsGroup represents a group of related keyboard shortcuts
/// or gestures. The group has a title. It may optionally be associated with
/// a view of the application, which can be used to show only relevant shortcuts
/// depending on the application context.
/// 
/// This widget is only meant to be used with `GtkShortcutsWindow`.
open class ShortcutsGroup: Box, ShortcutsGroupProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsGroup` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkShortcutsGroup>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsGroup` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkShortcutsGroup>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsGroup` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsGroup` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsGroup` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkShortcutsGroup>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsGroup` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkShortcutsGroup>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkShortcutsGroup`.
    /// i.e., ownership is transferred to the `ShortcutsGroup` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkShortcutsGroup>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ShortcutsGroupProtocol`
    /// Will retain `GtkShortcutsGroup`.
    /// - Parameter other: an instance of a related type that implements `ShortcutsGroupProtocol`
    @inlinable public init<T: ShortcutsGroupProtocol>(shortcutsGroup other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsGroupProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsGroupProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsGroupProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsGroupProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsGroupProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsGroupProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsGroupProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsGroupProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum ShortcutsGroupPropertyName: String, PropertyNameProtocol {
    /// The size group for the accelerator portion of shortcuts in this group.
    /// 
    /// This is used internally by GTK, and must not be modified by applications.
    case accelSizeGroup = "accel-size-group"
    case baselinePosition = "baseline-position"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`. See `gtk_widget_set_cursor()` for details.
    case cursor = "cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// A rough measure for the number of lines in this group.
    /// 
    /// This is used internally by GTK, and is not useful for applications.
    case height = "height"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    case homogeneous = "homogeneous"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case name = "name"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    case parent = "parent"
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget or `nil` if
    /// the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    case spacing = "spacing"
    /// The title for this group of shortcuts.
    case title = "title"
    /// The size group for the textual portion of shortcuts in this group.
    /// 
    /// This is used internally by GTK, and must not be modified by applications.
    case titleSizeGroup = "title-size-group"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    /// An optional view that the shortcuts in this group are relevant for.
    /// The group will be hidden if the `GtkShortcutsWindow:view`-name property
    /// does not match the view of this group.
    /// 
    /// Set this to `nil` to make the group always visible.
    case view = "view"
    case visible = "visible"
    case widthRequest = "width-request"
}

public extension ShortcutsGroupProtocol {
    /// Bind a `ShortcutsGroupPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ShortcutsGroupPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ShortcutsGroup property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ShortcutsGroupPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ShortcutsGroup property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ShortcutsGroupPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

// MARK: ShortcutsGroup has no signals// MARK: ShortcutsGroup Class: ShortcutsGroupProtocol extension (methods and fields)
public extension ShortcutsGroupProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkShortcutsGroup` instance.
    @inlinable var shortcuts_group_ptr: UnsafeMutablePointer<GtkShortcutsGroup>! { return ptr?.assumingMemoryBound(to: GtkShortcutsGroup.self) }



}



// MARK: - ShortcutsSection Class

/// The `ShortcutsSectionProtocol` protocol exposes the methods and properties of an underlying `GtkShortcutsSection` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ShortcutsSection`.
/// Alternatively, use `ShortcutsSectionRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A GtkShortcutsSection collects all the keyboard shortcuts and gestures
/// for a major application mode. If your application needs multiple sections,
/// you should give each section a unique `GtkShortcutsSection:section`-name and
/// a `GtkShortcutsSection:title` that can be shown in the section selector of
/// the GtkShortcutsWindow.
/// 
/// The `GtkShortcutsSection:max`-height property can be used to influence how
/// the groups in the section are distributed over pages and columns.
/// 
/// This widget is only meant to be used with `GtkShortcutsWindow`.
public protocol ShortcutsSectionProtocol: BoxProtocol {
        /// Untyped pointer to the underlying `GtkShortcutsSection` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkShortcutsSection` instance.
    var shortcuts_section_ptr: UnsafeMutablePointer<GtkShortcutsSection>! { get }

}

/// The `ShortcutsSectionRef` type acts as a lightweight Swift reference to an underlying `GtkShortcutsSection` instance.
/// It exposes methods that can operate on this data type through `ShortcutsSectionProtocol` conformance.
/// Use `ShortcutsSectionRef` only as an `unowned` reference to an existing `GtkShortcutsSection` instance.
///
/// A GtkShortcutsSection collects all the keyboard shortcuts and gestures
/// for a major application mode. If your application needs multiple sections,
/// you should give each section a unique `GtkShortcutsSection:section`-name and
/// a `GtkShortcutsSection:title` that can be shown in the section selector of
/// the GtkShortcutsWindow.
/// 
/// The `GtkShortcutsSection:max`-height property can be used to influence how
/// the groups in the section are distributed over pages and columns.
/// 
/// This widget is only meant to be used with `GtkShortcutsWindow`.
public struct ShortcutsSectionRef: ShortcutsSectionProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkShortcutsSection` instance.
    /// For type-safe access, use the generated, typed pointer `shortcuts_section_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ShortcutsSectionRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkShortcutsSection>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkShortcutsSection>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkShortcutsSection>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkShortcutsSection>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ShortcutsSectionProtocol`
    @inlinable init<T: ShortcutsSectionProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ShortcutsSectionProtocol>(_ other: T) -> ShortcutsSectionRef { ShortcutsSectionRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsSectionProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsSectionProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsSectionProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsSectionProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsSectionProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `ShortcutsSection` type acts as a reference-counted owner of an underlying `GtkShortcutsSection` instance.
/// It provides the methods that can operate on this data type through `ShortcutsSectionProtocol` conformance.
/// Use `ShortcutsSection` as a strong reference or owner of a `GtkShortcutsSection` instance.
///
/// A GtkShortcutsSection collects all the keyboard shortcuts and gestures
/// for a major application mode. If your application needs multiple sections,
/// you should give each section a unique `GtkShortcutsSection:section`-name and
/// a `GtkShortcutsSection:title` that can be shown in the section selector of
/// the GtkShortcutsWindow.
/// 
/// The `GtkShortcutsSection:max`-height property can be used to influence how
/// the groups in the section are distributed over pages and columns.
/// 
/// This widget is only meant to be used with `GtkShortcutsWindow`.
open class ShortcutsSection: Box, ShortcutsSectionProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsSection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkShortcutsSection>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsSection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkShortcutsSection>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsSection` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsSection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsSection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkShortcutsSection>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsSection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkShortcutsSection>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkShortcutsSection`.
    /// i.e., ownership is transferred to the `ShortcutsSection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkShortcutsSection>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ShortcutsSectionProtocol`
    /// Will retain `GtkShortcutsSection`.
    /// - Parameter other: an instance of a related type that implements `ShortcutsSectionProtocol`
    @inlinable public init<T: ShortcutsSectionProtocol>(shortcutsSection other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsSectionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsSectionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsSectionProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsSectionProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsSectionProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsSectionProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsSectionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsSectionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum ShortcutsSectionPropertyName: String, PropertyNameProtocol {
    case baselinePosition = "baseline-position"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`. See `gtk_widget_set_cursor()` for details.
    case cursor = "cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    case homogeneous = "homogeneous"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    /// The maximum number of lines to allow per column. This property can
    /// be used to influence how the groups in this section are distributed
    /// across pages and columns. The default value of 15 should work in
    /// most cases.
    case maxHeight = "max-height"
    case name = "name"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    case parent = "parent"
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget or `nil` if
    /// the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    /// A unique name to identify this section among the sections
    /// added to the GtkShortcutsWindow. Setting the `GtkShortcutsWindow:section`-name
    /// property to this string will make this section shown in the
    /// GtkShortcutsWindow.
    case sectionName = "section-name"
    case sensitive = "sensitive"
    case spacing = "spacing"
    /// The string to show in the section selector of the GtkShortcutsWindow
    /// for this section. If there is only one section, you don't need to
    /// set a title, since the section selector will not be shown in this case.
    case title = "title"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    /// A view name to filter the groups in this section by.
    /// See `GtkShortcutsGroup:view`.
    /// 
    /// Applications are expected to use the `GtkShortcutsWindow:view`-name
    /// property for this purpose.
    case viewName = "view-name"
    case visible = "visible"
    case widthRequest = "width-request"
}

public extension ShortcutsSectionProtocol {
    /// Bind a `ShortcutsSectionPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ShortcutsSectionPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ShortcutsSection property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ShortcutsSectionPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ShortcutsSection property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ShortcutsSectionPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

// MARK: Signals of ShortcutsSection
public extension ShortcutsSectionProtocol {
    /// - Note: Representation of signal named `change-current-page`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter object: none
    @discardableResult
    func onChangeCurrentPage(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ShortcutsSectionRef, _ object: Int) -> Bool ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ShortcutsSectionRef, Int, Bool>
        let cCallback: @convention(c) (gpointer, gint, gpointer) -> gboolean = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call(ShortcutsSectionRef(raw: unownedSelf), Int(arg1))
            return gboolean((output) ? 1 : 0)
        }
        return signalConnectData(
            detailedSignal: "change-current-page", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::max-height`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyMaxHeight(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ShortcutsSectionRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ShortcutsSectionRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ShortcutsSectionRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::max-height", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::section-name`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifySectionName(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ShortcutsSectionRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ShortcutsSectionRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ShortcutsSectionRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::section-name", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::title`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyTitle(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ShortcutsSectionRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ShortcutsSectionRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ShortcutsSectionRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::title", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::view-name`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyViewName(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ShortcutsSectionRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ShortcutsSectionRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ShortcutsSectionRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::view-name", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
}

// MARK: ShortcutsSection Class: ShortcutsSectionProtocol extension (methods and fields)
public extension ShortcutsSectionProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkShortcutsSection` instance.
    @inlinable var shortcuts_section_ptr: UnsafeMutablePointer<GtkShortcutsSection>! { return ptr?.assumingMemoryBound(to: GtkShortcutsSection.self) }



}



// MARK: - ShortcutsShortcut Class

/// The `ShortcutsShortcutProtocol` protocol exposes the methods and properties of an underlying `GtkShortcutsShortcut` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ShortcutsShortcut`.
/// Alternatively, use `ShortcutsShortcutRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A GtkShortcutsShortcut represents a single keyboard shortcut or gesture
/// with a short text. This widget is only meant to be used with `GtkShortcutsWindow`.
public protocol ShortcutsShortcutProtocol: WidgetProtocol {
        /// Untyped pointer to the underlying `GtkShortcutsShortcut` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkShortcutsShortcut` instance.
    var shortcuts_shortcut_ptr: UnsafeMutablePointer<GtkShortcutsShortcut>! { get }

}

/// The `ShortcutsShortcutRef` type acts as a lightweight Swift reference to an underlying `GtkShortcutsShortcut` instance.
/// It exposes methods that can operate on this data type through `ShortcutsShortcutProtocol` conformance.
/// Use `ShortcutsShortcutRef` only as an `unowned` reference to an existing `GtkShortcutsShortcut` instance.
///
/// A GtkShortcutsShortcut represents a single keyboard shortcut or gesture
/// with a short text. This widget is only meant to be used with `GtkShortcutsWindow`.
public struct ShortcutsShortcutRef: ShortcutsShortcutProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkShortcutsShortcut` instance.
    /// For type-safe access, use the generated, typed pointer `shortcuts_shortcut_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ShortcutsShortcutRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkShortcutsShortcut>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkShortcutsShortcut>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkShortcutsShortcut>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkShortcutsShortcut>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ShortcutsShortcutProtocol`
    @inlinable init<T: ShortcutsShortcutProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ShortcutsShortcutProtocol>(_ other: T) -> ShortcutsShortcutRef { ShortcutsShortcutRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsShortcutProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsShortcutProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsShortcutProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsShortcutProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsShortcutProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `ShortcutsShortcut` type acts as a reference-counted owner of an underlying `GtkShortcutsShortcut` instance.
/// It provides the methods that can operate on this data type through `ShortcutsShortcutProtocol` conformance.
/// Use `ShortcutsShortcut` as a strong reference or owner of a `GtkShortcutsShortcut` instance.
///
/// A GtkShortcutsShortcut represents a single keyboard shortcut or gesture
/// with a short text. This widget is only meant to be used with `GtkShortcutsWindow`.
open class ShortcutsShortcut: Widget, ShortcutsShortcutProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsShortcut` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkShortcutsShortcut>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsShortcut` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkShortcutsShortcut>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsShortcut` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsShortcut` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsShortcut` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkShortcutsShortcut>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsShortcut` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkShortcutsShortcut>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkShortcutsShortcut`.
    /// i.e., ownership is transferred to the `ShortcutsShortcut` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkShortcutsShortcut>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ShortcutsShortcutProtocol`
    /// Will retain `GtkShortcutsShortcut`.
    /// - Parameter other: an instance of a related type that implements `ShortcutsShortcutProtocol`
    @inlinable public init<T: ShortcutsShortcutProtocol>(shortcutsShortcut other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsShortcutProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsShortcutProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsShortcutProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsShortcutProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsShortcutProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsShortcutProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsShortcutProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsShortcutProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum ShortcutsShortcutPropertyName: String, PropertyNameProtocol {
    /// The size group for the accelerator portion of this shortcut.
    /// 
    /// This is used internally by GTK, and must not be modified by applications.
    case accelSizeGroup = "accel-size-group"
    /// The `accelerator(s)` represented by this object. This property is used
    /// if `GtkShortcutsShortcut:shortcut`-type is set to `GTK_SHORTCUT_ACCELERATOR`.
    /// 
    /// The syntax of this property is (an extension of) the syntax understood by
    /// `gtk_accelerator_parse()`. Multiple accelerators can be specified by separating
    /// them with a space, but keep in mind that the available width is limited.
    /// It is also possible to specify ranges of shortcuts, using ... between the keys.
    /// Sequences of keys can be specified using a + or & between the keys.
    /// 
    /// Examples:
    /// - A single shortcut: <ctl><alt>delete
    /// - Two alternative shortcuts: <shift>a Home
    /// - A range of shortcuts: <alt>1...<alt>9
    /// - Several keys pressed together: Control_L&Control_R
    /// - A sequence of shortcuts or keys: <ctl>c+<ctl>x
    /// 
    /// Use + instead of & when the keys may (or have to be) pressed sequentially (e.g
    /// use t+t for 'press the t key twice').
    /// 
    /// Note that <, > and & need to be escaped as &lt;, &gt; and &amp; when used
    /// in .ui files.
    case accelerator = "accelerator"
    /// A detailed action name. If this is set for a shortcut
    /// of type `GTK_SHORTCUT_ACCELERATOR`, then GTK will use
    /// the accelerators that are associated with the action
    /// via `gtk_application_set_accels_for_action()`, and setting
    /// `GtkShortcutsShortcut:accelerator` is not necessary.
    case actionName = "action-name"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`. See `gtk_widget_set_cursor()` for details.
    case cursor = "cursor"
    /// The text direction for which this shortcut is active. If the shortcut
    /// is used regardless of the text direction, set this property to
    /// `GTK_TEXT_DIR_NONE`.
    case direction = "direction"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    /// An icon to represent the shortcut or gesture. This property is used if
    /// `GtkShortcutsShortcut:shortcut`-type is set to `GTK_SHORTCUT_GESTURE`.
    /// For the other predefined gesture types, GTK provides an icon on its own.
    case icon = "icon"
    /// `true` if an icon has been set.
    case iconSet = "icon-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case name = "name"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    case parent = "parent"
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget or `nil` if
    /// the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    /// The type of shortcut that is represented.
    case shortcutType = "shortcut-type"
    /// The subtitle for the shortcut or gesture.
    /// 
    /// This is typically used for gestures and should be a short, one-line
    /// text that describes the gesture itself. For the predefined gesture
    /// types, GTK provides a subtitle on its own.
    case subtitle = "subtitle"
    /// `true` if a subtitle has been set.
    case subtitleSet = "subtitle-set"
    /// The textual description for the shortcut or gesture represented by
    /// this object. This should be a short string that can fit in a single line.
    case title = "title"
    /// The size group for the textual portion of this shortcut.
    /// 
    /// This is used internally by GTK, and must not be modified by applications.
    case titleSizeGroup = "title-size-group"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
}

public extension ShortcutsShortcutProtocol {
    /// Bind a `ShortcutsShortcutPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ShortcutsShortcutPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ShortcutsShortcut property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ShortcutsShortcutPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ShortcutsShortcut property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ShortcutsShortcutPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

// MARK: ShortcutsShortcut has no signals// MARK: ShortcutsShortcut Class: ShortcutsShortcutProtocol extension (methods and fields)
public extension ShortcutsShortcutProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkShortcutsShortcut` instance.
    @inlinable var shortcuts_shortcut_ptr: UnsafeMutablePointer<GtkShortcutsShortcut>! { return ptr?.assumingMemoryBound(to: GtkShortcutsShortcut.self) }



}



// MARK: - ShortcutsWindow Class

/// The `ShortcutsWindowProtocol` protocol exposes the methods and properties of an underlying `GtkShortcutsWindow` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ShortcutsWindow`.
/// Alternatively, use `ShortcutsWindowRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A GtkShortcutsWindow shows brief information about the keyboard shortcuts
/// and gestures of an application. The shortcuts can be grouped, and you can
/// have multiple sections in this window, corresponding to the major modes of
/// your application.
/// 
/// Additionally, the shortcuts can be filtered by the current view, to avoid
/// showing information that is not relevant in the current application context.
/// 
/// The recommended way to construct a GtkShortcutsWindow is with GtkBuilder,
/// by populating a `GtkShortcutsWindow` with one or more `GtkShortcutsSection`
/// objects, which contain `GtkShortcutsGroups` that in turn contain objects of
/// class `GtkShortcutsShortcut`.
/// 
/// # A simple example:
/// 
/// ![](gedit-shortcuts.png)
/// 
/// This example has as single section. As you can see, the shortcut groups
/// are arranged in columns, and spread across several pages if there are too
/// many to find on a single page.
/// 
/// The .ui file for this example can be found [here](https://gitlab.gnome.org/GNOME/gtk/tree/master/demos/gtk-demo/shortcuts-gedit.ui).
/// 
/// # An example with multiple views:
/// 
/// ![](clocks-shortcuts.png)
/// 
/// This example shows a `GtkShortcutsWindow` that has been configured to show only
/// the shortcuts relevant to the "stopwatch" view.
/// 
/// The .ui file for this example can be found [here](https://gitlab.gnome.org/GNOME/gtk/tree/master/demos/gtk-demo/shortcuts-clocks.ui).
/// 
/// # An example with multiple sections:
/// 
/// ![](builder-shortcuts.png)
/// 
/// This example shows a `GtkShortcutsWindow` with two sections, "Editor Shortcuts"
/// and "Terminal Shortcuts".
/// 
/// The .ui file for this example can be found [here](https://gitlab.gnome.org/GNOME/gtk/tree/master/demos/gtk-demo/shortcuts-builder.ui).
public protocol ShortcutsWindowProtocol: WindowProtocol {
        /// Untyped pointer to the underlying `GtkShortcutsWindow` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkShortcutsWindow` instance.
    var shortcuts_window_ptr: UnsafeMutablePointer<GtkShortcutsWindow>! { get }

}

/// The `ShortcutsWindowRef` type acts as a lightweight Swift reference to an underlying `GtkShortcutsWindow` instance.
/// It exposes methods that can operate on this data type through `ShortcutsWindowProtocol` conformance.
/// Use `ShortcutsWindowRef` only as an `unowned` reference to an existing `GtkShortcutsWindow` instance.
///
/// A GtkShortcutsWindow shows brief information about the keyboard shortcuts
/// and gestures of an application. The shortcuts can be grouped, and you can
/// have multiple sections in this window, corresponding to the major modes of
/// your application.
/// 
/// Additionally, the shortcuts can be filtered by the current view, to avoid
/// showing information that is not relevant in the current application context.
/// 
/// The recommended way to construct a GtkShortcutsWindow is with GtkBuilder,
/// by populating a `GtkShortcutsWindow` with one or more `GtkShortcutsSection`
/// objects, which contain `GtkShortcutsGroups` that in turn contain objects of
/// class `GtkShortcutsShortcut`.
/// 
/// # A simple example:
/// 
/// ![](gedit-shortcuts.png)
/// 
/// This example has as single section. As you can see, the shortcut groups
/// are arranged in columns, and spread across several pages if there are too
/// many to find on a single page.
/// 
/// The .ui file for this example can be found [here](https://gitlab.gnome.org/GNOME/gtk/tree/master/demos/gtk-demo/shortcuts-gedit.ui).
/// 
/// # An example with multiple views:
/// 
/// ![](clocks-shortcuts.png)
/// 
/// This example shows a `GtkShortcutsWindow` that has been configured to show only
/// the shortcuts relevant to the "stopwatch" view.
/// 
/// The .ui file for this example can be found [here](https://gitlab.gnome.org/GNOME/gtk/tree/master/demos/gtk-demo/shortcuts-clocks.ui).
/// 
/// # An example with multiple sections:
/// 
/// ![](builder-shortcuts.png)
/// 
/// This example shows a `GtkShortcutsWindow` with two sections, "Editor Shortcuts"
/// and "Terminal Shortcuts".
/// 
/// The .ui file for this example can be found [here](https://gitlab.gnome.org/GNOME/gtk/tree/master/demos/gtk-demo/shortcuts-builder.ui).
public struct ShortcutsWindowRef: ShortcutsWindowProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkShortcutsWindow` instance.
    /// For type-safe access, use the generated, typed pointer `shortcuts_window_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ShortcutsWindowRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkShortcutsWindow>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkShortcutsWindow>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkShortcutsWindow>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkShortcutsWindow>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ShortcutsWindowProtocol`
    @inlinable init<T: ShortcutsWindowProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ShortcutsWindowProtocol>(_ other: T) -> ShortcutsWindowRef { ShortcutsWindowRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsWindowProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsWindowProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsWindowProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsWindowProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsWindowProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `ShortcutsWindow` type acts as a reference-counted owner of an underlying `GtkShortcutsWindow` instance.
/// It provides the methods that can operate on this data type through `ShortcutsWindowProtocol` conformance.
/// Use `ShortcutsWindow` as a strong reference or owner of a `GtkShortcutsWindow` instance.
///
/// A GtkShortcutsWindow shows brief information about the keyboard shortcuts
/// and gestures of an application. The shortcuts can be grouped, and you can
/// have multiple sections in this window, corresponding to the major modes of
/// your application.
/// 
/// Additionally, the shortcuts can be filtered by the current view, to avoid
/// showing information that is not relevant in the current application context.
/// 
/// The recommended way to construct a GtkShortcutsWindow is with GtkBuilder,
/// by populating a `GtkShortcutsWindow` with one or more `GtkShortcutsSection`
/// objects, which contain `GtkShortcutsGroups` that in turn contain objects of
/// class `GtkShortcutsShortcut`.
/// 
/// # A simple example:
/// 
/// ![](gedit-shortcuts.png)
/// 
/// This example has as single section. As you can see, the shortcut groups
/// are arranged in columns, and spread across several pages if there are too
/// many to find on a single page.
/// 
/// The .ui file for this example can be found [here](https://gitlab.gnome.org/GNOME/gtk/tree/master/demos/gtk-demo/shortcuts-gedit.ui).
/// 
/// # An example with multiple views:
/// 
/// ![](clocks-shortcuts.png)
/// 
/// This example shows a `GtkShortcutsWindow` that has been configured to show only
/// the shortcuts relevant to the "stopwatch" view.
/// 
/// The .ui file for this example can be found [here](https://gitlab.gnome.org/GNOME/gtk/tree/master/demos/gtk-demo/shortcuts-clocks.ui).
/// 
/// # An example with multiple sections:
/// 
/// ![](builder-shortcuts.png)
/// 
/// This example shows a `GtkShortcutsWindow` with two sections, "Editor Shortcuts"
/// and "Terminal Shortcuts".
/// 
/// The .ui file for this example can be found [here](https://gitlab.gnome.org/GNOME/gtk/tree/master/demos/gtk-demo/shortcuts-builder.ui).
open class ShortcutsWindow: Window, ShortcutsWindowProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsWindow` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkShortcutsWindow>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsWindow` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkShortcutsWindow>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsWindow` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsWindow` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsWindow` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkShortcutsWindow>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsWindow` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkShortcutsWindow>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkShortcutsWindow`.
    /// i.e., ownership is transferred to the `ShortcutsWindow` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkShortcutsWindow>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ShortcutsWindowProtocol`
    /// Will retain `GtkShortcutsWindow`.
    /// - Parameter other: an instance of a related type that implements `ShortcutsWindowProtocol`
    @inlinable public init<T: ShortcutsWindowProtocol>(shortcutsWindow other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsWindowProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsWindowProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsWindowProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsWindowProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsWindowProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsWindowProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsWindowProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsWindowProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum ShortcutsWindowPropertyName: String, PropertyNameProtocol {
    /// The `GtkApplication` associated with the window.
    /// 
    /// The application will be kept alive for at least as long as it
    /// has any windows associated with it (see `g_application_hold()`
    /// for a way to keep it alive without windows).
    /// 
    /// Normally, the connection between the application and the window
    /// will remain until the window is destroyed, but you can explicitly
    /// remove it by setting the :application property to `nil`.
    case application = "application"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    case canTarget = "can-target"
    case child = "child"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`. See `gtk_widget_set_cursor()` for details.
    case cursor = "cursor"
    /// Whether the window should be decorated by the window manager.
    case decorated = "decorated"
    case defaultHeight = "default-height"
    case defaultWidget = "default-widget"
    case defaultWidth = "default-width"
    /// Whether the window frame should have a close button.
    case deletable = "deletable"
    case destroyWithParent = "destroy-with-parent"
    case display = "display"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether 'focus rectangles' are currently visible in this window.
    /// 
    /// This property is maintained by GTK based on user input
    /// and should not be set by applications.
    case focusVisible = "focus-visible"
    case focusWidget = "focus-widget"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// Whether the window is fullscreen.
    /// 
    /// Setting this property is the equivalent of calling `gtk_window_fullscreen()`
    /// and `gtk_window_unfullscreen()`; either operation is asynchronous, which
    /// means you will need to connect to the `GObject::notify` signal in order to
    /// know whether the operation was successful.
    case fullscreened = "fullscreened"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    case hideOnClose = "hide-on-close"
    /// The :icon-name property specifies the name of the themed icon to
    /// use as the window icon. See `GtkIconTheme` for more details.
    case iconName = "icon-name"
    case isActive = "is-active"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    /// Whether the window is maximized.
    /// 
    /// Setting this property is the equivalent of calling `gtk_window_maximize()`
    /// and `gtk_window_unmaximize()`; either operation is asynchronous, which
    /// means you will need to connect to the `GObject::notify` signal in order to
    /// know whether the operation was successful.
    case maximized = "maximized"
    /// Whether mnemonics are currently visible in this window.
    /// 
    /// This property is maintained by GTK based on user input,
    /// and should not be set by applications.
    case mnemonicsVisible = "mnemonics-visible"
    case modal = "modal"
    case name = "name"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    case parent = "parent"
    case receivesDefault = "receives-default"
    case resizable = "resizable"
    /// The `GtkRoot` widget of the widget tree containing this widget or `nil` if
    /// the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    /// The name of the section to show.
    /// 
    /// This should be the section-name of one of the `GtkShortcutsSection`
    /// objects that are in this shortcuts window.
    case sectionName = "section-name"
    case sensitive = "sensitive"
    /// The :startup-id is a write-only property for setting window's
    /// startup notification identifier. See `gtk_window_set_startup_id()`
    /// for more details.
    case startupId = "startup-id"
    case title = "title"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// The transient parent of the window. See `gtk_window_set_transient_for()` for
    /// more details about transient windows.
    case transientFor = "transient-for"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    /// The view name by which to filter the contents.
    /// 
    /// This should correspond to the `GtkShortcutsGroup:view` property of some of
    /// the `GtkShortcutsGroup` objects that are inside this shortcuts window.
    /// 
    /// Set this to `nil` to show all groups.
    case viewName = "view-name"
    case visible = "visible"
    case widthRequest = "width-request"
}

public extension ShortcutsWindowProtocol {
    /// Bind a `ShortcutsWindowPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ShortcutsWindowPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ShortcutsWindow property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ShortcutsWindowPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ShortcutsWindow property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ShortcutsWindowPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

// MARK: Signals of ShortcutsWindow
public extension ShortcutsWindowProtocol {
    /// The `close` signal is a
    /// [keybinding signal](#GtkSignalAction)
    /// which gets emitted when the user uses a keybinding to close
    /// the window.
    /// 
    /// The default binding for this signal is the Escape key.
    /// - Note: Representation of signal named `close`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    @discardableResult
    func onClose(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ShortcutsWindowRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<ShortcutsWindowRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ShortcutsWindowRef(raw: unownedSelf))
            return output
        }
        return signalConnectData(
            detailedSignal: "close", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The `search` signal is a
    /// [keybinding signal](#GtkSignalAction)
    /// which gets emitted when the user uses a keybinding to start a search.
    /// 
    /// The default binding for this signal is Control-F.
    /// - Note: Representation of signal named `search`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    @discardableResult
    func onSearch(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ShortcutsWindowRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<ShortcutsWindowRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ShortcutsWindowRef(raw: unownedSelf))
            return output
        }
        return signalConnectData(
            detailedSignal: "search", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::section-name`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifySectionName(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ShortcutsWindowRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ShortcutsWindowRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ShortcutsWindowRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::section-name", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::view-name`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyViewName(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ShortcutsWindowRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ShortcutsWindowRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ShortcutsWindowRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::view-name", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
}

// MARK: ShortcutsWindow Class: ShortcutsWindowProtocol extension (methods and fields)
public extension ShortcutsWindowProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkShortcutsWindow` instance.
    @inlinable var shortcuts_window_ptr: UnsafeMutablePointer<GtkShortcutsWindow>! { return ptr?.assumingMemoryBound(to: GtkShortcutsWindow.self) }



}



// MARK: - SignalAction Class

/// The `SignalActionProtocol` protocol exposes the methods and properties of an underlying `GtkSignalAction` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `SignalAction`.
/// Alternatively, use `SignalActionRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A `GtkShortcutAction` that emits a signal.
/// 
/// Signals that are used in this way are referred to as keybinding signals,
/// and they are expected to be defined with the `G_SIGNAL_ACTION` flag.
public protocol SignalActionProtocol: ShortcutActionProtocol {
        /// Untyped pointer to the underlying `GtkSignalAction` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkSignalAction` instance.
    var signal_action_ptr: UnsafeMutablePointer<GtkSignalAction>! { get }

}

/// The `SignalActionRef` type acts as a lightweight Swift reference to an underlying `GtkSignalAction` instance.
/// It exposes methods that can operate on this data type through `SignalActionProtocol` conformance.
/// Use `SignalActionRef` only as an `unowned` reference to an existing `GtkSignalAction` instance.
///
/// A `GtkShortcutAction` that emits a signal.
/// 
/// Signals that are used in this way are referred to as keybinding signals,
/// and they are expected to be defined with the `G_SIGNAL_ACTION` flag.
public struct SignalActionRef: SignalActionProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkSignalAction` instance.
    /// For type-safe access, use the generated, typed pointer `signal_action_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension SignalActionRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkSignalAction>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkSignalAction>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkSignalAction>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkSignalAction>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `SignalActionProtocol`
    @inlinable init<T: SignalActionProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: SignalActionProtocol>(_ other: T) -> SignalActionRef { SignalActionRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalActionProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalActionProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalActionProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalActionProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalActionProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `SignalAction` type acts as a reference-counted owner of an underlying `GtkSignalAction` instance.
/// It provides the methods that can operate on this data type through `SignalActionProtocol` conformance.
/// Use `SignalAction` as a strong reference or owner of a `GtkSignalAction` instance.
///
/// A `GtkShortcutAction` that emits a signal.
/// 
/// Signals that are used in this way are referred to as keybinding signals,
/// and they are expected to be defined with the `G_SIGNAL_ACTION` flag.
open class SignalAction: ShortcutAction, SignalActionProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SignalAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkSignalAction>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SignalAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkSignalAction>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SignalAction` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SignalAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SignalAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkSignalAction>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SignalAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkSignalAction>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkSignalAction`.
    /// i.e., ownership is transferred to the `SignalAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkSignalAction>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `SignalActionProtocol`
    /// Will retain `GtkSignalAction`.
    /// - Parameter other: an instance of a related type that implements `SignalActionProtocol`
    @inlinable public init<T: SignalActionProtocol>(signalAction other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalActionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalActionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalActionProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalActionProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalActionProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalActionProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalActionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalActionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum SignalActionPropertyName: String, PropertyNameProtocol {
    /// The name of the signal to emit.
    case signalName = "signal-name"
}

public extension SignalActionProtocol {
    /// Bind a `SignalActionPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: SignalActionPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a SignalAction property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: SignalActionPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a SignalAction property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: SignalActionPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

// MARK: SignalAction has no signals// MARK: SignalAction Class: SignalActionProtocol extension (methods and fields)
public extension SignalActionProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkSignalAction` instance.
    @inlinable var signal_action_ptr: UnsafeMutablePointer<GtkSignalAction>! { return ptr?.assumingMemoryBound(to: GtkSignalAction.self) }

    /// Returns the name of the signal that will be emitted.
    @inlinable func getSignalName() -> String! {
        let rv = gtk_signal_action_get_signal_name(signal_action_ptr).map({ String(cString: $0) })
        return rv
    }
    /// Returns the name of the signal that will be emitted.
    @inlinable var signalName: String! {
        /// Returns the name of the signal that will be emitted.
        get {
            let rv = gtk_signal_action_get_signal_name(signal_action_ptr).map({ String(cString: $0) })
            return rv
        }
    }


}



// MARK: - SignalListItemFactory Class

/// The `SignalListItemFactoryProtocol` protocol exposes the methods and properties of an underlying `GtkSignalListItemFactory` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `SignalListItemFactory`.
/// Alternatively, use `SignalListItemFactoryRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkSignalListItemFactory` is a `GtkListItemFactory` that provides signals
/// that user code can connect to to manage listitems.
/// Signals are emitted for every listitem in the same order:
/// 
///  1. `GtkSignalListItemFactory::setup` is emitted to set up permanent things
///  on the listitem. This usually means constructing the widgets used in the
///  row and adding them to the listitem.
/// 
///  2. `GtkSignalListItemFactory::bind` is emitted to bind the item passed via
///  `GtkListItem:item` to the widgets that have been created in step 1 or to
///  add item-specific widgets. Signals are connected to listen to changes -
///  both to changes in the item to update the widgets or to changes in the
///  widgets to update the item. After this signal has been called, the
///  listitem may be shown in a list widget.
/// 
///  3. `GtkSignalListItemFactory::unbind` is emitted to undo everything done
///  in step 2. Usually this means disconnecting signal handlers. Once this
///  signal has been called, the listitem will no longer be used in a list
///  widget.
/// 
///  4. `GtkSignalListItemFactory::bind` and `GtkSignalListItemFactory::unbind`
///  may be emitted multiple times again to bind the listitem for use with
///  new items. By reusing listitems, potentially costly setup can be
///  avoided. However, it means code needs to make sure to properly clean
///  up the listitem in step 3 so that no information from the previous
///  use leaks into the next use.
/// 
/// 5. `GtkSignalListItemFactory::teardown` is emitted to allow undoing the
/// effects of `GtkSignalListItemFactory::setup`. After this signal was emitted
/// on a listitem, the listitem will be destroyed and not be used again.
/// 
/// Note that during the signal emissions, changing properties on the
/// `GtkListItems` passed will not trigger notify signals as the listitem's
/// notifications are frozen. See `g_object_freeze_notify()` for details.
/// 
/// For tracking changes in other properties in the `GtkListItem`, the
/// `GtkListItem::notify` signal is recommended. The signal can be connected
/// in the `GtkSignalListItemFactory::setup` signal and removed again during
/// `GtkSignalListItemFactory::teardown`.
public protocol SignalListItemFactoryProtocol: ListItemFactoryProtocol {
        /// Untyped pointer to the underlying `GtkSignalListItemFactory` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkSignalListItemFactory` instance.
    var signal_list_item_factory_ptr: UnsafeMutablePointer<GtkSignalListItemFactory>! { get }

}

/// The `SignalListItemFactoryRef` type acts as a lightweight Swift reference to an underlying `GtkSignalListItemFactory` instance.
/// It exposes methods that can operate on this data type through `SignalListItemFactoryProtocol` conformance.
/// Use `SignalListItemFactoryRef` only as an `unowned` reference to an existing `GtkSignalListItemFactory` instance.
///
/// `GtkSignalListItemFactory` is a `GtkListItemFactory` that provides signals
/// that user code can connect to to manage listitems.
/// Signals are emitted for every listitem in the same order:
/// 
///  1. `GtkSignalListItemFactory::setup` is emitted to set up permanent things
///  on the listitem. This usually means constructing the widgets used in the
///  row and adding them to the listitem.
/// 
///  2. `GtkSignalListItemFactory::bind` is emitted to bind the item passed via
///  `GtkListItem:item` to the widgets that have been created in step 1 or to
///  add item-specific widgets. Signals are connected to listen to changes -
///  both to changes in the item to update the widgets or to changes in the
///  widgets to update the item. After this signal has been called, the
///  listitem may be shown in a list widget.
/// 
///  3. `GtkSignalListItemFactory::unbind` is emitted to undo everything done
///  in step 2. Usually this means disconnecting signal handlers. Once this
///  signal has been called, the listitem will no longer be used in a list
///  widget.
/// 
///  4. `GtkSignalListItemFactory::bind` and `GtkSignalListItemFactory::unbind`
///  may be emitted multiple times again to bind the listitem for use with
///  new items. By reusing listitems, potentially costly setup can be
///  avoided. However, it means code needs to make sure to properly clean
///  up the listitem in step 3 so that no information from the previous
///  use leaks into the next use.
/// 
/// 5. `GtkSignalListItemFactory::teardown` is emitted to allow undoing the
/// effects of `GtkSignalListItemFactory::setup`. After this signal was emitted
/// on a listitem, the listitem will be destroyed and not be used again.
/// 
/// Note that during the signal emissions, changing properties on the
/// `GtkListItems` passed will not trigger notify signals as the listitem's
/// notifications are frozen. See `g_object_freeze_notify()` for details.
/// 
/// For tracking changes in other properties in the `GtkListItem`, the
/// `GtkListItem::notify` signal is recommended. The signal can be connected
/// in the `GtkSignalListItemFactory::setup` signal and removed again during
/// `GtkSignalListItemFactory::teardown`.
public struct SignalListItemFactoryRef: SignalListItemFactoryProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkSignalListItemFactory` instance.
    /// For type-safe access, use the generated, typed pointer `signal_list_item_factory_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension SignalListItemFactoryRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkSignalListItemFactory>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkSignalListItemFactory>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkSignalListItemFactory>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkSignalListItemFactory>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `SignalListItemFactoryProtocol`
    @inlinable init<T: SignalListItemFactoryProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: SignalListItemFactoryProtocol>(_ other: T) -> SignalListItemFactoryRef { SignalListItemFactoryRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalListItemFactoryProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalListItemFactoryProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalListItemFactoryProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalListItemFactoryProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalListItemFactoryProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkSignalListItemFactory`. You need to connect signal
    /// handlers before you use it.
    @inlinable init() {
        let rv = gtk_signal_list_item_factory_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `SignalListItemFactory` type acts as a reference-counted owner of an underlying `GtkSignalListItemFactory` instance.
/// It provides the methods that can operate on this data type through `SignalListItemFactoryProtocol` conformance.
/// Use `SignalListItemFactory` as a strong reference or owner of a `GtkSignalListItemFactory` instance.
///
/// `GtkSignalListItemFactory` is a `GtkListItemFactory` that provides signals
/// that user code can connect to to manage listitems.
/// Signals are emitted for every listitem in the same order:
/// 
///  1. `GtkSignalListItemFactory::setup` is emitted to set up permanent things
///  on the listitem. This usually means constructing the widgets used in the
///  row and adding them to the listitem.
/// 
///  2. `GtkSignalListItemFactory::bind` is emitted to bind the item passed via
///  `GtkListItem:item` to the widgets that have been created in step 1 or to
///  add item-specific widgets. Signals are connected to listen to changes -
///  both to changes in the item to update the widgets or to changes in the
///  widgets to update the item. After this signal has been called, the
///  listitem may be shown in a list widget.
/// 
///  3. `GtkSignalListItemFactory::unbind` is emitted to undo everything done
///  in step 2. Usually this means disconnecting signal handlers. Once this
///  signal has been called, the listitem will no longer be used in a list
///  widget.
/// 
///  4. `GtkSignalListItemFactory::bind` and `GtkSignalListItemFactory::unbind`
///  may be emitted multiple times again to bind the listitem for use with
///  new items. By reusing listitems, potentially costly setup can be
///  avoided. However, it means code needs to make sure to properly clean
///  up the listitem in step 3 so that no information from the previous
///  use leaks into the next use.
/// 
/// 5. `GtkSignalListItemFactory::teardown` is emitted to allow undoing the
/// effects of `GtkSignalListItemFactory::setup`. After this signal was emitted
/// on a listitem, the listitem will be destroyed and not be used again.
/// 
/// Note that during the signal emissions, changing properties on the
/// `GtkListItems` passed will not trigger notify signals as the listitem's
/// notifications are frozen. See `g_object_freeze_notify()` for details.
/// 
/// For tracking changes in other properties in the `GtkListItem`, the
/// `GtkListItem::notify` signal is recommended. The signal can be connected
/// in the `GtkSignalListItemFactory::setup` signal and removed again during
/// `GtkSignalListItemFactory::teardown`.
open class SignalListItemFactory: ListItemFactory, SignalListItemFactoryProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SignalListItemFactory` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkSignalListItemFactory>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SignalListItemFactory` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkSignalListItemFactory>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SignalListItemFactory` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SignalListItemFactory` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SignalListItemFactory` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkSignalListItemFactory>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SignalListItemFactory` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkSignalListItemFactory>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkSignalListItemFactory`.
    /// i.e., ownership is transferred to the `SignalListItemFactory` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkSignalListItemFactory>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `SignalListItemFactoryProtocol`
    /// Will retain `GtkSignalListItemFactory`.
    /// - Parameter other: an instance of a related type that implements `SignalListItemFactoryProtocol`
    @inlinable public init<T: SignalListItemFactoryProtocol>(signalListItemFactory other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalListItemFactoryProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalListItemFactoryProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalListItemFactoryProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalListItemFactoryProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalListItemFactoryProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalListItemFactoryProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalListItemFactoryProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalListItemFactoryProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkSignalListItemFactory`. You need to connect signal
    /// handlers before you use it.
    @inlinable public init() {
        let rv = gtk_signal_list_item_factory_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

// MARK: no SignalListItemFactory properties

// MARK: Signals of SignalListItemFactory
public extension SignalListItemFactoryProtocol {
    /// The `bind` signal is emitted when a new `GtkListItem:item` has been set
    /// on the `listitem` and should be bound for use.
    /// 
    /// After this signal was emitted, the listitem might be shown in a `GtkListView`
    /// or other list widget.
    /// 
    /// The `GtkSignalListItemFactory::unbind` signal is the opposite of this signal
    /// and can be used to undo everything done in this signal.
    /// - Note: Representation of signal named `bind`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter listitem: The `GtkListItem` to bind
    @discardableResult
    func onBind(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SignalListItemFactoryRef, _ listitem: ListItemRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<SignalListItemFactoryRef, ListItemRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SignalListItemFactoryRef(raw: unownedSelf), ListItemRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "bind", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The `setup` signal is emitted when a new listitem has been created and
    /// needs to be setup for use. It is the first signal emitted for every listitem.
    /// 
    /// The `GtkSignalListItemFactory::teardown` signal is the opposite of this signal
    /// and can be used to undo everything done in this signal.
    /// - Note: Representation of signal named `setup`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter listitem: The `GtkListItem` to set up
    @discardableResult
    func onSetup(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SignalListItemFactoryRef, _ listitem: ListItemRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<SignalListItemFactoryRef, ListItemRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SignalListItemFactoryRef(raw: unownedSelf), ListItemRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "setup", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The `teardown` signal is emitted when a listitem is about to be destroyed.
    /// It is the last signal ever emitted for this `listitem`.
    /// 
    /// This signal is the opposite of the `GtkSignalListItemFactory::setup` signal
    /// and should be used to undo everything done in that signal.
    /// - Note: Representation of signal named `teardown`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter listitem: The `GtkListItem` to teardown
    @discardableResult
    func onTeardown(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SignalListItemFactoryRef, _ listitem: ListItemRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<SignalListItemFactoryRef, ListItemRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SignalListItemFactoryRef(raw: unownedSelf), ListItemRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "teardown", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The `unbind` signal is emitted when a listitem has been removed from use
    /// in a list widget and its new `GtkListItem:item` is about to be unset.
    /// 
    /// This signal is the opposite of the `GtkSignalListItemFactory::bind` signal
    /// and should be used to undo everything done in that signal.
    /// - Note: Representation of signal named `unbind`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter listitem: The `GtkListItem` to unbind
    @discardableResult
    func onUnbind(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SignalListItemFactoryRef, _ listitem: ListItemRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<SignalListItemFactoryRef, ListItemRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SignalListItemFactoryRef(raw: unownedSelf), ListItemRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "unbind", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    
}

// MARK: SignalListItemFactory Class: SignalListItemFactoryProtocol extension (methods and fields)
public extension SignalListItemFactoryProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkSignalListItemFactory` instance.
    @inlinable var signal_list_item_factory_ptr: UnsafeMutablePointer<GtkSignalListItemFactory>! { return ptr?.assumingMemoryBound(to: GtkSignalListItemFactory.self) }



}



// MARK: - SingleSelection Class

/// The `SingleSelectionProtocol` protocol exposes the methods and properties of an underlying `GtkSingleSelection` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `SingleSelection`.
/// Alternatively, use `SingleSelectionRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// GtkSingleSelection is an implementation of the `GtkSelectionModel` interface
/// that allows selecting a single element. It is the default selection method
/// used by list widgets in GTK.
/// 
/// Note that the selection is *persistent* -- if the selected item is removed
/// and re-added in the same `GListModel::items`-changed emission, it stays selected.
/// In particular, this means that changing the sort order of an underlying sort
/// model will preserve the selection.
public protocol SingleSelectionProtocol: GLibObject.ObjectProtocol, GIO.ListModelProtocol, SelectionModelProtocol {
        /// Untyped pointer to the underlying `GtkSingleSelection` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkSingleSelection` instance.
    var single_selection_ptr: UnsafeMutablePointer<GtkSingleSelection>! { get }

}

/// The `SingleSelectionRef` type acts as a lightweight Swift reference to an underlying `GtkSingleSelection` instance.
/// It exposes methods that can operate on this data type through `SingleSelectionProtocol` conformance.
/// Use `SingleSelectionRef` only as an `unowned` reference to an existing `GtkSingleSelection` instance.
///
/// GtkSingleSelection is an implementation of the `GtkSelectionModel` interface
/// that allows selecting a single element. It is the default selection method
/// used by list widgets in GTK.
/// 
/// Note that the selection is *persistent* -- if the selected item is removed
/// and re-added in the same `GListModel::items`-changed emission, it stays selected.
/// In particular, this means that changing the sort order of an underlying sort
/// model will preserve the selection.
public struct SingleSelectionRef: SingleSelectionProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkSingleSelection` instance.
    /// For type-safe access, use the generated, typed pointer `single_selection_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension SingleSelectionRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkSingleSelection>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkSingleSelection>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkSingleSelection>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkSingleSelection>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `SingleSelectionProtocol`
    @inlinable init<T: SingleSelectionProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: SingleSelectionProtocol>(_ other: T) -> SingleSelectionRef { SingleSelectionRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SingleSelectionProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SingleSelectionProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SingleSelectionProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SingleSelectionProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SingleSelectionProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new selection to handle `model`.
    @inlinable init<ListModelT: GIO.ListModelProtocol>( model: ListModelT?) {
        let rv = gtk_single_selection_new(model?.list_model_ptr)
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `SingleSelection` type acts as a reference-counted owner of an underlying `GtkSingleSelection` instance.
/// It provides the methods that can operate on this data type through `SingleSelectionProtocol` conformance.
/// Use `SingleSelection` as a strong reference or owner of a `GtkSingleSelection` instance.
///
/// GtkSingleSelection is an implementation of the `GtkSelectionModel` interface
/// that allows selecting a single element. It is the default selection method
/// used by list widgets in GTK.
/// 
/// Note that the selection is *persistent* -- if the selected item is removed
/// and re-added in the same `GListModel::items`-changed emission, it stays selected.
/// In particular, this means that changing the sort order of an underlying sort
/// model will preserve the selection.
open class SingleSelection: GLibObject.Object, SingleSelectionProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SingleSelection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkSingleSelection>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SingleSelection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkSingleSelection>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SingleSelection` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SingleSelection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SingleSelection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkSingleSelection>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SingleSelection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkSingleSelection>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkSingleSelection`.
    /// i.e., ownership is transferred to the `SingleSelection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkSingleSelection>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `SingleSelectionProtocol`
    /// Will retain `GtkSingleSelection`.
    /// - Parameter other: an instance of a related type that implements `SingleSelectionProtocol`
    @inlinable public init<T: SingleSelectionProtocol>(singleSelection other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SingleSelectionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SingleSelectionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SingleSelectionProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SingleSelectionProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SingleSelectionProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SingleSelectionProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SingleSelectionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SingleSelectionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new selection to handle `model`.
    @inlinable public init<ListModelT: GIO.ListModelProtocol>( model: ListModelT?) {
        let rv = gtk_single_selection_new(model?.list_model_ptr)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum SingleSelectionPropertyName: String, PropertyNameProtocol {
    /// If the selection will always select an item
    case autoselect = "autoselect"
    /// If unselecting the selected item is allowed
    case canUnselect = "can-unselect"
    /// The model being managed
    case model = "model"
    /// Position of the selected item
    case selected = "selected"
    /// The selected item
    case selectedItem = "selected-item"
}

public extension SingleSelectionProtocol {
    /// Bind a `SingleSelectionPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: SingleSelectionPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a SingleSelection property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: SingleSelectionPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a SingleSelection property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: SingleSelectionPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

// MARK: SingleSelection has no signals// MARK: SingleSelection Class: SingleSelectionProtocol extension (methods and fields)
public extension SingleSelectionProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkSingleSelection` instance.
    @inlinable var single_selection_ptr: UnsafeMutablePointer<GtkSingleSelection>! { return ptr?.assumingMemoryBound(to: GtkSingleSelection.self) }

    /// Checks if autoselect has been enabled or disabled via
    /// `gtk_single_selection_set_autoselect()`.
    @inlinable func getAutoselect() -> Bool {
        let rv = ((gtk_single_selection_get_autoselect(single_selection_ptr)) != 0)
        return rv
    }

    /// If `true`, `gtk_selection_model_unselect_item()` is supported and allows
    /// unselecting the selected item.
    @inlinable func getCanUnselect() -> Bool {
        let rv = ((gtk_single_selection_get_can_unselect(single_selection_ptr)) != 0)
        return rv
    }

    /// Gets the model that `self` is wrapping.
    @inlinable func getModel() -> GIO.ListModelRef! {
        let rv = GIO.ListModelRef(gtk_single_selection_get_model(single_selection_ptr))
        return rv
    }

    /// Gets the position of the selected item. If no item is selected,
    /// `GTK_INVALID_LIST_POSITION` is returned.
    @inlinable func getSelected() -> Int {
        let rv = Int(gtk_single_selection_get_selected(single_selection_ptr))
        return rv
    }

    /// Gets the selected item.
    /// 
    /// If no item is selected, `nil` is returned.
    @inlinable func getSelectedItem() -> gpointer! {
        let rv = gtk_single_selection_get_selected_item(single_selection_ptr)
        return rv
    }

    /// If `autoselect` is `true`, `self` will enforce that an item is always
    /// selected. It will select a new item when the currently selected
    /// item is deleted and it will disallow unselecting the current item.
    @inlinable func set(autoselect: Bool) {
        gtk_single_selection_set_autoselect(single_selection_ptr, gboolean((autoselect) ? 1 : 0))
    
    }

    /// If `true`, unselecting the current item via
    /// `gtk_selection_model_unselect_item()` is supported.
    /// 
    /// Note that setting `GtkSingleSelection:autoselect` will cause the
    /// unselecting to not work, so it practically makes no sense to set
    /// both at the same time the same time.
    @inlinable func set(canUnselect: Bool) {
        gtk_single_selection_set_can_unselect(single_selection_ptr, gboolean((canUnselect) ? 1 : 0))
    
    }

    /// Sets the model that `self` should wrap. If `model` is `nil`, `self`
    /// will be empty.
    @inlinable func set(model: GIO.ListModelRef? = nil) {
        gtk_single_selection_set_model(single_selection_ptr, model?.list_model_ptr)
    
    }
    /// Sets the model that `self` should wrap. If `model` is `nil`, `self`
    /// will be empty.
    @inlinable func set<ListModelT: GIO.ListModelProtocol>(model: ListModelT?) {
        gtk_single_selection_set_model(single_selection_ptr, model?.list_model_ptr)
    
    }

    /// Selects the item at the given position.
    /// 
    /// If the list does not have an item at `position` or
    /// `GTK_INVALID_LIST_POSITION` is given, the behavior depends on the
    /// value of the `GtkSingleSelection:autoselect` property: If it is set,
    /// no change will occur and the old item will stay selected. If it is
    /// unset, the selection will be unset and no item will be selected.
    @inlinable func setSelected(position: Int) {
        gtk_single_selection_set_selected(single_selection_ptr, guint(position))
    
    }
    /// If the selection will always select an item
    @inlinable var autoselect: Bool {
        /// Checks if autoselect has been enabled or disabled via
        /// `gtk_single_selection_set_autoselect()`.
        get {
            let rv = ((gtk_single_selection_get_autoselect(single_selection_ptr)) != 0)
            return rv
        }
        /// If `autoselect` is `true`, `self` will enforce that an item is always
        /// selected. It will select a new item when the currently selected
        /// item is deleted and it will disallow unselecting the current item.
        nonmutating set {
            gtk_single_selection_set_autoselect(single_selection_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// If `true`, `gtk_selection_model_unselect_item()` is supported and allows
    /// unselecting the selected item.
    @inlinable var canUnselect: Bool {
        /// If `true`, `gtk_selection_model_unselect_item()` is supported and allows
        /// unselecting the selected item.
        get {
            let rv = ((gtk_single_selection_get_can_unselect(single_selection_ptr)) != 0)
            return rv
        }
        /// If `true`, unselecting the current item via
        /// `gtk_selection_model_unselect_item()` is supported.
        /// 
        /// Note that setting `GtkSingleSelection:autoselect` will cause the
        /// unselecting to not work, so it practically makes no sense to set
        /// both at the same time the same time.
        nonmutating set {
            gtk_single_selection_set_can_unselect(single_selection_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// The model being managed
    @inlinable var model: GIO.ListModelRef! {
        /// Gets the model that `self` is wrapping.
        get {
            let rv = GIO.ListModelRef(gtk_single_selection_get_model(single_selection_ptr))
            return rv
        }
        /// Sets the model that `self` should wrap. If `model` is `nil`, `self`
        /// will be empty.
        nonmutating set {
            gtk_single_selection_set_model(single_selection_ptr, UnsafeMutablePointer<GListModel>(newValue?.list_model_ptr))
        }
    }

    /// Position of the selected item
    @inlinable var selected: Int {
        /// Gets the position of the selected item. If no item is selected,
        /// `GTK_INVALID_LIST_POSITION` is returned.
        get {
            let rv = Int(gtk_single_selection_get_selected(single_selection_ptr))
            return rv
        }
        /// Selects the item at the given position.
        /// 
        /// If the list does not have an item at `position` or
        /// `GTK_INVALID_LIST_POSITION` is given, the behavior depends on the
        /// value of the `GtkSingleSelection:autoselect` property: If it is set,
        /// no change will occur and the old item will stay selected. If it is
        /// unset, the selection will be unset and no item will be selected.
        nonmutating set {
            gtk_single_selection_set_selected(single_selection_ptr, guint(newValue))
        }
    }

    /// Gets the selected item.
    /// 
    /// If no item is selected, `nil` is returned.
    @inlinable var selectedItem: gpointer! {
        /// Gets the selected item.
        /// 
        /// If no item is selected, `nil` is returned.
        get {
            let rv = gtk_single_selection_get_selected_item(single_selection_ptr)
            return rv
        }
    }


}



// MARK: - SizeGroup Class

/// The `SizeGroupProtocol` protocol exposes the methods and properties of an underlying `GtkSizeGroup` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `SizeGroup`.
/// Alternatively, use `SizeGroupRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkSizeGroup` provides a mechanism for grouping a number of widgets
/// together so they all request the same amount of space.  This is
/// typically useful when you want a column of widgets to have the same
/// size, but you can’t use a `GtkGrid` widget.
/// 
/// In detail, the size requested for each widget in a `GtkSizeGroup` is
/// the maximum of the sizes that would have been requested for each
/// widget in the size group if they were not in the size group. The mode
/// of the size group (see `gtk_size_group_set_mode()`) determines whether
/// this applies to the horizontal size, the vertical size, or both sizes.
/// 
/// Note that size groups only affect the amount of space requested, not
/// the size that the widgets finally receive. If you want the widgets in
/// a `GtkSizeGroup` to actually be the same size, you need to pack them in
/// such a way that they get the size they request and not more. For
/// example, if you are packing your widgets into a table, you would not
/// include the `GTK_FILL` flag.
/// 
/// `GtkSizeGroup` objects are referenced by each widget in the size group,
/// so once you have added all widgets to a `GtkSizeGroup`, you can drop
/// the initial reference to the size group with `g_object_unref()`. If the
/// widgets in the size group are subsequently destroyed, then they will
/// be removed from the size group and drop their references on the size
/// group; when all widgets have been removed, the size group will be
/// freed.
/// 
/// Widgets can be part of multiple size groups; GTK will compute the
/// horizontal size of a widget from the horizontal requisition of all
/// widgets that can be reached from the widget by a chain of size groups
/// of type `GTK_SIZE_GROUP_HORIZONTAL` or `GTK_SIZE_GROUP_BOTH`, and the
/// vertical size from the vertical requisition of all widgets that can be
/// reached from the widget by a chain of size groups of type
/// `GTK_SIZE_GROUP_VERTICAL` or `GTK_SIZE_GROUP_BOTH`.
/// 
/// Note that only non-contextual sizes of every widget are ever consulted
/// by size groups (since size groups have no knowledge of what size a widget
/// will be allocated in one dimension, it cannot derive how much height
/// a widget will receive for a given width). When grouping widgets that
/// trade height for width in mode `GTK_SIZE_GROUP_VERTICAL` or `GTK_SIZE_GROUP_BOTH:`
/// the height for the minimum width will be the requested height for all
/// widgets in the group. The same is of course true when horizontally grouping
/// width for height widgets.
/// 
/// Widgets that trade height-for-width should set a reasonably large minimum width
/// by way of `GtkLabel:width`-chars for instance. Widgets with static sizes as well
/// as widgets that grow (such as ellipsizing text) need no such considerations.
/// 
/// # GtkSizeGroup as GtkBuildable
/// 
/// Size groups can be specified in a UI definition by placing an <object>
/// element with `class="GtkSizeGroup"` somewhere in the UI definition. The
/// widgets that belong to the size group are specified by a <widgets> element
/// that may contain multiple <widget> elements, one for each member of the
/// size group. The ”name” attribute gives the id of the widget.
/// 
/// An example of a UI definition fragment with GtkSizeGroup:
/// ```
/// <object class="GtkSizeGroup">
///   <property name="mode">horizontal</property>
///   <widgets>
///     <widget name="radio1"/>
///     <widget name="radio2"/>
///   </widgets>
/// </object>
/// ```
/// 
public protocol SizeGroupProtocol: GLibObject.ObjectProtocol, BuildableProtocol {
        /// Untyped pointer to the underlying `GtkSizeGroup` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkSizeGroup` instance.
    var size_group_ptr: UnsafeMutablePointer<GtkSizeGroup>! { get }

}

/// The `SizeGroupRef` type acts as a lightweight Swift reference to an underlying `GtkSizeGroup` instance.
/// It exposes methods that can operate on this data type through `SizeGroupProtocol` conformance.
/// Use `SizeGroupRef` only as an `unowned` reference to an existing `GtkSizeGroup` instance.
///
/// `GtkSizeGroup` provides a mechanism for grouping a number of widgets
/// together so they all request the same amount of space.  This is
/// typically useful when you want a column of widgets to have the same
/// size, but you can’t use a `GtkGrid` widget.
/// 
/// In detail, the size requested for each widget in a `GtkSizeGroup` is
/// the maximum of the sizes that would have been requested for each
/// widget in the size group if they were not in the size group. The mode
/// of the size group (see `gtk_size_group_set_mode()`) determines whether
/// this applies to the horizontal size, the vertical size, or both sizes.
/// 
/// Note that size groups only affect the amount of space requested, not
/// the size that the widgets finally receive. If you want the widgets in
/// a `GtkSizeGroup` to actually be the same size, you need to pack them in
/// such a way that they get the size they request and not more. For
/// example, if you are packing your widgets into a table, you would not
/// include the `GTK_FILL` flag.
/// 
/// `GtkSizeGroup` objects are referenced by each widget in the size group,
/// so once you have added all widgets to a `GtkSizeGroup`, you can drop
/// the initial reference to the size group with `g_object_unref()`. If the
/// widgets in the size group are subsequently destroyed, then they will
/// be removed from the size group and drop their references on the size
/// group; when all widgets have been removed, the size group will be
/// freed.
/// 
/// Widgets can be part of multiple size groups; GTK will compute the
/// horizontal size of a widget from the horizontal requisition of all
/// widgets that can be reached from the widget by a chain of size groups
/// of type `GTK_SIZE_GROUP_HORIZONTAL` or `GTK_SIZE_GROUP_BOTH`, and the
/// vertical size from the vertical requisition of all widgets that can be
/// reached from the widget by a chain of size groups of type
/// `GTK_SIZE_GROUP_VERTICAL` or `GTK_SIZE_GROUP_BOTH`.
/// 
/// Note that only non-contextual sizes of every widget are ever consulted
/// by size groups (since size groups have no knowledge of what size a widget
/// will be allocated in one dimension, it cannot derive how much height
/// a widget will receive for a given width). When grouping widgets that
/// trade height for width in mode `GTK_SIZE_GROUP_VERTICAL` or `GTK_SIZE_GROUP_BOTH:`
/// the height for the minimum width will be the requested height for all
/// widgets in the group. The same is of course true when horizontally grouping
/// width for height widgets.
/// 
/// Widgets that trade height-for-width should set a reasonably large minimum width
/// by way of `GtkLabel:width`-chars for instance. Widgets with static sizes as well
/// as widgets that grow (such as ellipsizing text) need no such considerations.
/// 
/// # GtkSizeGroup as GtkBuildable
/// 
/// Size groups can be specified in a UI definition by placing an <object>
/// element with `class="GtkSizeGroup"` somewhere in the UI definition. The
/// widgets that belong to the size group are specified by a <widgets> element
/// that may contain multiple <widget> elements, one for each member of the
/// size group. The ”name” attribute gives the id of the widget.
/// 
/// An example of a UI definition fragment with GtkSizeGroup:
/// ```
/// <object class="GtkSizeGroup">
///   <property name="mode">horizontal</property>
///   <widgets>
///     <widget name="radio1"/>
///     <widget name="radio2"/>
///   </widgets>
/// </object>
/// ```
/// 
public struct SizeGroupRef: SizeGroupProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkSizeGroup` instance.
    /// For type-safe access, use the generated, typed pointer `size_group_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension SizeGroupRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkSizeGroup>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkSizeGroup>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkSizeGroup>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkSizeGroup>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `SizeGroupProtocol`
    @inlinable init<T: SizeGroupProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: SizeGroupProtocol>(_ other: T) -> SizeGroupRef { SizeGroupRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SizeGroupProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SizeGroupProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SizeGroupProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SizeGroupProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SizeGroupProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Create a new `GtkSizeGroup`.
    @inlinable init( mode: GtkSizeGroupMode) {
        let rv = gtk_size_group_new(mode)
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `SizeGroup` type acts as a reference-counted owner of an underlying `GtkSizeGroup` instance.
/// It provides the methods that can operate on this data type through `SizeGroupProtocol` conformance.
/// Use `SizeGroup` as a strong reference or owner of a `GtkSizeGroup` instance.
///
/// `GtkSizeGroup` provides a mechanism for grouping a number of widgets
/// together so they all request the same amount of space.  This is
/// typically useful when you want a column of widgets to have the same
/// size, but you can’t use a `GtkGrid` widget.
/// 
/// In detail, the size requested for each widget in a `GtkSizeGroup` is
/// the maximum of the sizes that would have been requested for each
/// widget in the size group if they were not in the size group. The mode
/// of the size group (see `gtk_size_group_set_mode()`) determines whether
/// this applies to the horizontal size, the vertical size, or both sizes.
/// 
/// Note that size groups only affect the amount of space requested, not
/// the size that the widgets finally receive. If you want the widgets in
/// a `GtkSizeGroup` to actually be the same size, you need to pack them in
/// such a way that they get the size they request and not more. For
/// example, if you are packing your widgets into a table, you would not
/// include the `GTK_FILL` flag.
/// 
/// `GtkSizeGroup` objects are referenced by each widget in the size group,
/// so once you have added all widgets to a `GtkSizeGroup`, you can drop
/// the initial reference to the size group with `g_object_unref()`. If the
/// widgets in the size group are subsequently destroyed, then they will
/// be removed from the size group and drop their references on the size
/// group; when all widgets have been removed, the size group will be
/// freed.
/// 
/// Widgets can be part of multiple size groups; GTK will compute the
/// horizontal size of a widget from the horizontal requisition of all
/// widgets that can be reached from the widget by a chain of size groups
/// of type `GTK_SIZE_GROUP_HORIZONTAL` or `GTK_SIZE_GROUP_BOTH`, and the
/// vertical size from the vertical requisition of all widgets that can be
/// reached from the widget by a chain of size groups of type
/// `GTK_SIZE_GROUP_VERTICAL` or `GTK_SIZE_GROUP_BOTH`.
/// 
/// Note that only non-contextual sizes of every widget are ever consulted
/// by size groups (since size groups have no knowledge of what size a widget
/// will be allocated in one dimension, it cannot derive how much height
/// a widget will receive for a given width). When grouping widgets that
/// trade height for width in mode `GTK_SIZE_GROUP_VERTICAL` or `GTK_SIZE_GROUP_BOTH:`
/// the height for the minimum width will be the requested height for all
/// widgets in the group. The same is of course true when horizontally grouping
/// width for height widgets.
/// 
/// Widgets that trade height-for-width should set a reasonably large minimum width
/// by way of `GtkLabel:width`-chars for instance. Widgets with static sizes as well
/// as widgets that grow (such as ellipsizing text) need no such considerations.
/// 
/// # GtkSizeGroup as GtkBuildable
/// 
/// Size groups can be specified in a UI definition by placing an <object>
/// element with `class="GtkSizeGroup"` somewhere in the UI definition. The
/// widgets that belong to the size group are specified by a <widgets> element
/// that may contain multiple <widget> elements, one for each member of the
/// size group. The ”name” attribute gives the id of the widget.
/// 
/// An example of a UI definition fragment with GtkSizeGroup:
/// ```
/// <object class="GtkSizeGroup">
///   <property name="mode">horizontal</property>
///   <widgets>
///     <widget name="radio1"/>
///     <widget name="radio2"/>
///   </widgets>
/// </object>
/// ```
/// 
open class SizeGroup: GLibObject.Object, SizeGroupProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SizeGroup` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkSizeGroup>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SizeGroup` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkSizeGroup>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SizeGroup` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SizeGroup` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SizeGroup` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkSizeGroup>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SizeGroup` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkSizeGroup>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkSizeGroup`.
    /// i.e., ownership is transferred to the `SizeGroup` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkSizeGroup>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `SizeGroupProtocol`
    /// Will retain `GtkSizeGroup`.
    /// - Parameter other: an instance of a related type that implements `SizeGroupProtocol`
    @inlinable public init<T: SizeGroupProtocol>(sizeGroup other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SizeGroupProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SizeGroupProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SizeGroupProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SizeGroupProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SizeGroupProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SizeGroupProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SizeGroupProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SizeGroupProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Create a new `GtkSizeGroup`.
    @inlinable public init( mode: GtkSizeGroupMode) {
        let rv = gtk_size_group_new(mode)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum SizeGroupPropertyName: String, PropertyNameProtocol {
    case mode = "mode"
}

public extension SizeGroupProtocol {
    /// Bind a `SizeGroupPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: SizeGroupPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a SizeGroup property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: SizeGroupPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a SizeGroup property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: SizeGroupPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

// MARK: SizeGroup has no signals// MARK: SizeGroup Class: SizeGroupProtocol extension (methods and fields)
public extension SizeGroupProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkSizeGroup` instance.
    @inlinable var size_group_ptr: UnsafeMutablePointer<GtkSizeGroup>! { return ptr?.assumingMemoryBound(to: GtkSizeGroup.self) }

    /// Adds a widget to a `GtkSizeGroup`. In the future, the requisition
    /// of the widget will be determined as the maximum of its requisition
    /// and the requisition of the other widgets in the size group.
    /// Whether this applies horizontally, vertically, or in both directions
    /// depends on the mode of the size group. See `gtk_size_group_set_mode()`.
    /// 
    /// When the widget is destroyed or no longer referenced elsewhere, it will
    /// be removed from the size group.
    @inlinable func add<WidgetT: WidgetProtocol>(widget: WidgetT) {
        gtk_size_group_add_widget(size_group_ptr, widget.widget_ptr)
    
    }

    /// Gets the current mode of the size group. See `gtk_size_group_set_mode()`.
    @inlinable func getMode() -> GtkSizeGroupMode {
        let rv = gtk_size_group_get_mode(size_group_ptr)
        return rv
    }

    /// Returns the list of widgets associated with `size_group`.
    @inlinable func getWidgets() -> GLib.SListRef! {
        let rv = GLib.SListRef(gtk_size_group_get_widgets(size_group_ptr))
        return rv
    }

    /// Removes a widget from a `GtkSizeGroup`.
    @inlinable func remove<WidgetT: WidgetProtocol>(widget: WidgetT) {
        gtk_size_group_remove_widget(size_group_ptr, widget.widget_ptr)
    
    }

    /// Sets the `GtkSizeGroupMode` of the size group. The mode of the size
    /// group determines whether the widgets in the size group should
    /// all have the same horizontal requisition (`GTK_SIZE_GROUP_HORIZONTAL`)
    /// all have the same vertical requisition (`GTK_SIZE_GROUP_VERTICAL`),
    /// or should all have the same requisition in both directions
    /// (`GTK_SIZE_GROUP_BOTH`).
    @inlinable func set(mode: GtkSizeGroupMode) {
        gtk_size_group_set_mode(size_group_ptr, mode)
    
    }
    @inlinable var mode: GtkSizeGroupMode {
        /// Gets the current mode of the size group. See `gtk_size_group_set_mode()`.
        get {
            let rv = gtk_size_group_get_mode(size_group_ptr)
            return rv
        }
        /// Sets the `GtkSizeGroupMode` of the size group. The mode of the size
        /// group determines whether the widgets in the size group should
        /// all have the same horizontal requisition (`GTK_SIZE_GROUP_HORIZONTAL`)
        /// all have the same vertical requisition (`GTK_SIZE_GROUP_VERTICAL`),
        /// or should all have the same requisition in both directions
        /// (`GTK_SIZE_GROUP_BOTH`).
        nonmutating set {
            gtk_size_group_set_mode(size_group_ptr, newValue)
        }
    }

    /// Returns the list of widgets associated with `size_group`.
    @inlinable var widgets: GLib.SListRef! {
        /// Returns the list of widgets associated with `size_group`.
        get {
            let rv = GLib.SListRef(gtk_size_group_get_widgets(size_group_ptr))
            return rv
        }
    }

    @inlinable var parentInstance: GObject {
        get {
            let rv = size_group_ptr.pointee.parent_instance
            return rv
        }
    }

}



// MARK: - SliceListModel Class

/// The `SliceListModelProtocol` protocol exposes the methods and properties of an underlying `GtkSliceListModel` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `SliceListModel`.
/// Alternatively, use `SliceListModelRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkSliceListModel` is a list model that takes a list model and presents a
/// slice of that model.
/// 
/// This is useful when implementing paging by setting the size to the number
/// of elements per page and updating the offset whenever a different page is
/// opened.
public protocol SliceListModelProtocol: GLibObject.ObjectProtocol, GIO.ListModelProtocol {
        /// Untyped pointer to the underlying `GtkSliceListModel` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkSliceListModel` instance.
    var slice_list_model_ptr: UnsafeMutablePointer<GtkSliceListModel>! { get }

}

/// The `SliceListModelRef` type acts as a lightweight Swift reference to an underlying `GtkSliceListModel` instance.
/// It exposes methods that can operate on this data type through `SliceListModelProtocol` conformance.
/// Use `SliceListModelRef` only as an `unowned` reference to an existing `GtkSliceListModel` instance.
///
/// `GtkSliceListModel` is a list model that takes a list model and presents a
/// slice of that model.
/// 
/// This is useful when implementing paging by setting the size to the number
/// of elements per page and updating the offset whenever a different page is
/// opened.
public struct SliceListModelRef: SliceListModelProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkSliceListModel` instance.
    /// For type-safe access, use the generated, typed pointer `slice_list_model_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension SliceListModelRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkSliceListModel>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkSliceListModel>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkSliceListModel>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkSliceListModel>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `SliceListModelProtocol`
    @inlinable init<T: SliceListModelProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: SliceListModelProtocol>(_ other: T) -> SliceListModelRef { SliceListModelRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SliceListModelProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SliceListModelProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SliceListModelProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SliceListModelProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SliceListModelProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new slice model that presents the slice from `offset` to
    /// `offset` + `size` our of the given `model`.
    @inlinable init<ListModelT: GIO.ListModelProtocol>( model: ListModelT?, offset: Int, size: Int) {
        let rv = gtk_slice_list_model_new(model?.list_model_ptr, guint(offset), guint(size))
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `SliceListModel` type acts as a reference-counted owner of an underlying `GtkSliceListModel` instance.
/// It provides the methods that can operate on this data type through `SliceListModelProtocol` conformance.
/// Use `SliceListModel` as a strong reference or owner of a `GtkSliceListModel` instance.
///
/// `GtkSliceListModel` is a list model that takes a list model and presents a
/// slice of that model.
/// 
/// This is useful when implementing paging by setting the size to the number
/// of elements per page and updating the offset whenever a different page is
/// opened.
open class SliceListModel: GLibObject.Object, SliceListModelProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SliceListModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkSliceListModel>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SliceListModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkSliceListModel>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SliceListModel` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SliceListModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SliceListModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkSliceListModel>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SliceListModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkSliceListModel>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkSliceListModel`.
    /// i.e., ownership is transferred to the `SliceListModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkSliceListModel>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `SliceListModelProtocol`
    /// Will retain `GtkSliceListModel`.
    /// - Parameter other: an instance of a related type that implements `SliceListModelProtocol`
    @inlinable public init<T: SliceListModelProtocol>(sliceListModel other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SliceListModelProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SliceListModelProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SliceListModelProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SliceListModelProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SliceListModelProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SliceListModelProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SliceListModelProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SliceListModelProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new slice model that presents the slice from `offset` to
    /// `offset` + `size` our of the given `model`.
    @inlinable public init<ListModelT: GIO.ListModelProtocol>( model: ListModelT?, offset: Int, size: Int) {
        let rv = gtk_slice_list_model_new(model?.list_model_ptr, guint(offset), guint(size))
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum SliceListModelPropertyName: String, PropertyNameProtocol {
    /// Child model to take slice from
    case model = "model"
    /// Offset of slice
    case offset = "offset"
    /// Maximum size of slice
    case size = "size"
}

public extension SliceListModelProtocol {
    /// Bind a `SliceListModelPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: SliceListModelPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a SliceListModel property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: SliceListModelPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a SliceListModel property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: SliceListModelPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

// MARK: SliceListModel has no signals// MARK: SliceListModel Class: SliceListModelProtocol extension (methods and fields)
public extension SliceListModelProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkSliceListModel` instance.
    @inlinable var slice_list_model_ptr: UnsafeMutablePointer<GtkSliceListModel>! { return ptr?.assumingMemoryBound(to: GtkSliceListModel.self) }

    /// Gets the model that is currently being used or `nil` if none.
    @inlinable func getModel() -> GIO.ListModelRef! {
        let rv = GIO.ListModelRef(gtk_slice_list_model_get_model(slice_list_model_ptr))
        return rv
    }

    /// Gets the offset set via `gtk_slice_list_model_set_offset()`
    @inlinable func getOffset() -> Int {
        let rv = Int(gtk_slice_list_model_get_offset(slice_list_model_ptr))
        return rv
    }

    /// Gets the size set via `gtk_slice_list_model_set_size()`.
    @inlinable func getSize() -> Int {
        let rv = Int(gtk_slice_list_model_get_size(slice_list_model_ptr))
        return rv
    }

    /// Sets the model to show a slice of. The model's item type must conform
    /// to `self`'s item type.
    @inlinable func set(model: GIO.ListModelRef? = nil) {
        gtk_slice_list_model_set_model(slice_list_model_ptr, model?.list_model_ptr)
    
    }
    /// Sets the model to show a slice of. The model's item type must conform
    /// to `self`'s item type.
    @inlinable func set<ListModelT: GIO.ListModelProtocol>(model: ListModelT?) {
        gtk_slice_list_model_set_model(slice_list_model_ptr, model?.list_model_ptr)
    
    }

    /// Sets the offset into the original model for this slice.
    /// 
    /// If the offset is too large for the sliced model,
    /// `self` will end up empty.
    @inlinable func set(offset: Int) {
        gtk_slice_list_model_set_offset(slice_list_model_ptr, guint(offset))
    
    }

    /// Sets the maximum size. `self` will never have more items
    /// than `size`.
    /// 
    /// It can however have fewer items if the offset is too large or
    /// the model sliced from doesn't have enough items.
    @inlinable func set(size: Int) {
        gtk_slice_list_model_set_size(slice_list_model_ptr, guint(size))
    
    }
    /// Child model to take slice from
    @inlinable var model: GIO.ListModelRef! {
        /// Gets the model that is currently being used or `nil` if none.
        get {
            let rv = GIO.ListModelRef(gtk_slice_list_model_get_model(slice_list_model_ptr))
            return rv
        }
        /// Sets the model to show a slice of. The model's item type must conform
        /// to `self`'s item type.
        nonmutating set {
            gtk_slice_list_model_set_model(slice_list_model_ptr, UnsafeMutablePointer<GListModel>(newValue?.list_model_ptr))
        }
    }

    /// Offset of slice
    @inlinable var offset: Int {
        /// Gets the offset set via `gtk_slice_list_model_set_offset()`
        get {
            let rv = Int(gtk_slice_list_model_get_offset(slice_list_model_ptr))
            return rv
        }
        /// Sets the offset into the original model for this slice.
        /// 
        /// If the offset is too large for the sliced model,
        /// `self` will end up empty.
        nonmutating set {
            gtk_slice_list_model_set_offset(slice_list_model_ptr, guint(newValue))
        }
    }

    /// Maximum size of slice
    @inlinable var size: Int {
        /// Gets the size set via `gtk_slice_list_model_set_size()`.
        get {
            let rv = Int(gtk_slice_list_model_get_size(slice_list_model_ptr))
            return rv
        }
        /// Sets the maximum size. `self` will never have more items
        /// than `size`.
        /// 
        /// It can however have fewer items if the offset is too large or
        /// the model sliced from doesn't have enough items.
        nonmutating set {
            gtk_slice_list_model_set_size(slice_list_model_ptr, guint(newValue))
        }
    }


}



// MARK: - Snapshot Class

/// The `SnapshotProtocol` protocol exposes the methods and properties of an underlying `GtkSnapshot` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `Snapshot`.
/// Alternatively, use `SnapshotRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// GtkSnapshot is an auxiliary object that assists in creating `GskRenderNodes`
/// in the `GdkPaintableInterface.snapshot``()` vfunc. It functions in a similar way to
/// a cairo context, and maintains a stack of render nodes and their associated
/// transformations.
/// 
/// The node at the top of the stack is the the one that gtk_snapshot_append_…
/// functions operate on. Use the gtk_snapshot_push_… functions and `gtk_snapshot_pop()`
/// to change the current node.
/// 
/// The typical way to obtain a GtkSnapshot object is as an argument to
/// the `GtkWidgetClass.snapshot``()` vfunc. If you need to create your own GtkSnapshot,
/// use `gtk_snapshot_new()`.
public protocol SnapshotProtocol: Gdk.SnapshotProtocol {
        /// Untyped pointer to the underlying `GtkSnapshot` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkSnapshot` instance.
    var snapshot_ptr: UnsafeMutablePointer<GtkSnapshot>! { get }

}

/// The `SnapshotRef` type acts as a lightweight Swift reference to an underlying `GtkSnapshot` instance.
/// It exposes methods that can operate on this data type through `SnapshotProtocol` conformance.
/// Use `SnapshotRef` only as an `unowned` reference to an existing `GtkSnapshot` instance.
///
/// GtkSnapshot is an auxiliary object that assists in creating `GskRenderNodes`
/// in the `GdkPaintableInterface.snapshot``()` vfunc. It functions in a similar way to
/// a cairo context, and maintains a stack of render nodes and their associated
/// transformations.
/// 
/// The node at the top of the stack is the the one that gtk_snapshot_append_…
/// functions operate on. Use the gtk_snapshot_push_… functions and `gtk_snapshot_pop()`
/// to change the current node.
/// 
/// The typical way to obtain a GtkSnapshot object is as an argument to
/// the `GtkWidgetClass.snapshot``()` vfunc. If you need to create your own GtkSnapshot,
/// use `gtk_snapshot_new()`.
public struct SnapshotRef: SnapshotProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkSnapshot` instance.
    /// For type-safe access, use the generated, typed pointer `snapshot_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension SnapshotRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkSnapshot>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkSnapshot>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkSnapshot>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkSnapshot>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `SnapshotProtocol`
    @inlinable init<T: SnapshotProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: SnapshotProtocol>(_ other: T) -> SnapshotRef { SnapshotRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SnapshotProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SnapshotProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SnapshotProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SnapshotProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SnapshotProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkSnapshot`.
    @inlinable init() {
        let rv = gtk_snapshot_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `Snapshot` type acts as a reference-counted owner of an underlying `GtkSnapshot` instance.
/// It provides the methods that can operate on this data type through `SnapshotProtocol` conformance.
/// Use `Snapshot` as a strong reference or owner of a `GtkSnapshot` instance.
///
/// GtkSnapshot is an auxiliary object that assists in creating `GskRenderNodes`
/// in the `GdkPaintableInterface.snapshot``()` vfunc. It functions in a similar way to
/// a cairo context, and maintains a stack of render nodes and their associated
/// transformations.
/// 
/// The node at the top of the stack is the the one that gtk_snapshot_append_…
/// functions operate on. Use the gtk_snapshot_push_… functions and `gtk_snapshot_pop()`
/// to change the current node.
/// 
/// The typical way to obtain a GtkSnapshot object is as an argument to
/// the `GtkWidgetClass.snapshot``()` vfunc. If you need to create your own GtkSnapshot,
/// use `gtk_snapshot_new()`.
open class Snapshot: Gdk.Snapshot, SnapshotProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Snapshot` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init(_ op: UnsafeMutablePointer<GtkSnapshot>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Snapshot` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init(_ op: UnsafePointer<GtkSnapshot>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Snapshot` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Snapshot` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Snapshot` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(_ op: UnsafePointer<GtkSnapshot>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Snapshot` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(_ op: UnsafeMutablePointer<GtkSnapshot>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkSnapshot`.
    /// i.e., ownership is transferred to the `Snapshot` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init(retaining op: UnsafeMutablePointer<GtkSnapshot>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `SnapshotProtocol`
    /// Will retain `GtkSnapshot`.
    /// - Parameter other: an instance of a related type that implements `SnapshotProtocol`
    @inlinable public init<T: SnapshotProtocol>(_ other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SnapshotProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SnapshotProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SnapshotProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SnapshotProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SnapshotProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SnapshotProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SnapshotProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SnapshotProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkSnapshot`.
    @inlinable public init() {
        let rv = gtk_snapshot_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

// MARK: no Snapshot properties

// MARK: Snapshot has no signals// MARK: Snapshot Class: SnapshotProtocol extension (methods and fields)
public extension SnapshotProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkSnapshot` instance.
    @inlinable var snapshot_ptr: UnsafeMutablePointer<GtkSnapshot>! { return ptr?.assumingMemoryBound(to: GtkSnapshot.self) }

    /// Appends a stroked border rectangle inside the given `outline`. The
    /// 4 sides of the border can have different widths and colors.
    @inlinable func appendBorder(outline: UnsafePointer<GskRoundedRect>!, borderWidth: UnsafePointer<CFloat>!, borderColor: UnsafePointer<GdkRGBA>!) {
        gtk_snapshot_append_border(snapshot_ptr, outline, borderWidth, borderColor)
    
    }

    /// Creates a new render node and appends it to the current render
    /// node of `snapshot`, without changing the current node.
    @inlinable func appendCairo(bounds: UnsafePointer<graphene_rect_t>!) -> Cairo.ContextRef! {
        let rv = Cairo.ContextRef(gtk_snapshot_append_cairo(snapshot_ptr, bounds))
        return rv
    }

    /// Creates a new render node drawing the `color` into the given `bounds` and appends it
    /// to the current render node of `snapshot`.
    /// 
    /// You should try to avoid calling this function if `color` is transparent.
    @inlinable func append<RGBAT: Gdk.RGBAProtocol>(color: RGBAT, bounds: UnsafePointer<graphene_rect_t>!) {
        gtk_snapshot_append_color(snapshot_ptr, color.rgba_ptr, bounds)
    
    }

    /// Appends a conic gradient node with the given stops to `snapshot`.
    @inlinable func appendConicGradient(bounds: UnsafePointer<graphene_rect_t>!, center: UnsafePointer<graphene_point_t>!, rotation: CFloat, stops: UnsafePointer<GskColorStop>!, nStops: Int) {
        gtk_snapshot_append_conic_gradient(snapshot_ptr, bounds, center, rotation, stops, gsize(nStops))
    
    }

    /// Appends an inset shadow into the box given by `outline`.
    @inlinable func appendInsetShadow<RGBAT: Gdk.RGBAProtocol>(outline: UnsafePointer<GskRoundedRect>!, color: RGBAT, dx: CFloat, dy: CFloat, spread: CFloat, blurRadius: CFloat) {
        gtk_snapshot_append_inset_shadow(snapshot_ptr, outline, color.rgba_ptr, dx, dy, spread, blurRadius)
    
    }

    @inlinable func append<LayoutT: Pango.LayoutProtocol, RGBAT: Gdk.RGBAProtocol>(layout: LayoutT, color: RGBAT) {
        gtk_snapshot_append_layout(snapshot_ptr, layout.layout_ptr, color.rgba_ptr)
    
    }

    /// Appends a linear gradient node with the given stops to `snapshot`.
    @inlinable func appendLinearGradient(bounds: UnsafePointer<graphene_rect_t>!, startPoint: UnsafePointer<graphene_point_t>!, endPoint: UnsafePointer<graphene_point_t>!, stops: UnsafePointer<GskColorStop>!, nStops: Int) {
        gtk_snapshot_append_linear_gradient(snapshot_ptr, bounds, startPoint, endPoint, stops, gsize(nStops))
    
    }

    /// Appends `node` to the current render node of `snapshot`,
    /// without changing the current node. If `snapshot` does
    /// not have a current node yet, `node` will become the
    /// initial node.
    @inlinable func append(node: UnsafeMutablePointer<GskRenderNode>!) {
        gtk_snapshot_append_node(snapshot_ptr, node)
    
    }

    /// Appends an outset shadow node around the box given by `outline`.
    @inlinable func appendOutsetShadow<RGBAT: Gdk.RGBAProtocol>(outline: UnsafePointer<GskRoundedRect>!, color: RGBAT, dx: CFloat, dy: CFloat, spread: CFloat, blurRadius: CFloat) {
        gtk_snapshot_append_outset_shadow(snapshot_ptr, outline, color.rgba_ptr, dx, dy, spread, blurRadius)
    
    }

    /// Appends a radial gradient node with the given stops to `snapshot`.
    @inlinable func appendRadialGradient(bounds: UnsafePointer<graphene_rect_t>!, center: UnsafePointer<graphene_point_t>!, hradius: CFloat, vradius: CFloat, start: CFloat, end: CFloat, stops: UnsafePointer<GskColorStop>!, nStops: Int) {
        gtk_snapshot_append_radial_gradient(snapshot_ptr, bounds, center, hradius, vradius, start, end, stops, gsize(nStops))
    
    }

    /// Appends a repeating linear gradient node with the given stops to `snapshot`.
    @inlinable func appendRepeatingLinearGradient(bounds: UnsafePointer<graphene_rect_t>!, startPoint: UnsafePointer<graphene_point_t>!, endPoint: UnsafePointer<graphene_point_t>!, stops: UnsafePointer<GskColorStop>!, nStops: Int) {
        gtk_snapshot_append_repeating_linear_gradient(snapshot_ptr, bounds, startPoint, endPoint, stops, gsize(nStops))
    
    }

    /// Appends a repeating radial gradient node with the given stops to `snapshot`.
    @inlinable func appendRepeatingRadialGradient(bounds: UnsafePointer<graphene_rect_t>!, center: UnsafePointer<graphene_point_t>!, hradius: CFloat, vradius: CFloat, start: CFloat, end: CFloat, stops: UnsafePointer<GskColorStop>!, nStops: Int) {
        gtk_snapshot_append_repeating_radial_gradient(snapshot_ptr, bounds, center, hradius, vradius, start, end, stops, gsize(nStops))
    
    }

    /// Creates a new render node drawing the `texture` into the given `bounds` and appends it
    /// to the current render node of `snapshot`.
    @inlinable func append<TextureT: Gdk.TextureProtocol>(texture: TextureT, bounds: UnsafePointer<graphene_rect_t>!) {
        gtk_snapshot_append_texture(snapshot_ptr, texture.texture_ptr, bounds)
    
    }

    /// Returns the node that was constructed by `snapshot`
    /// and frees `snapshot`.
    @inlinable func freeToNode() -> UnsafeMutablePointer<GskRenderNode>! {
        let rv = gtk_snapshot_free_to_node(snapshot_ptr)
        return rv
    }

    /// Returns a paintable for the node that was
    /// constructed by `snapshot` and frees `snapshot`.
    @inlinable func freeToPaintable(size: UnsafePointer<graphene_size_t>? = nil) -> Gdk.PaintableRef! {
        let rv = Gdk.PaintableRef(gtk_snapshot_free_to_paintable(snapshot_ptr, size))
        return rv
    }

    /// Removes the top element from the stack of render nodes and
    /// adds it to the nearest GskGLShaderNode below it. This must be called the
    /// same number of times as the number of textures is needed for the
    /// shader in `gtk_snapshot_push_gl_shader()`.
    @inlinable func glShaderPopTexture() {
        gtk_snapshot_gl_shader_pop_texture(snapshot_ptr)
    
    }

    /// Applies a perspective projection transform.
    /// 
    /// See `gsk_transform_perspective()` for a discussion on the details.
    @inlinable func perspective(depth: CFloat) {
        gtk_snapshot_perspective(snapshot_ptr, depth)
    
    }

    /// Removes the top element from the stack of render nodes,
    /// and appends it to the node underneath it.
    @inlinable func pop() {
        gtk_snapshot_pop(snapshot_ptr)
    
    }

    /// Blends together 2 images with the given blend mode.
    /// 
    /// Until the first call to `gtk_snapshot_pop()`, the bottom image for the
    /// blend operation will be recorded. After that call, the top image to
    /// be blended will be recorded until the second call to `gtk_snapshot_pop()`.
    /// 
    /// Calling this function requires 2 subsequent calls to `gtk_snapshot_pop()`.
    @inlinable func pushBlend(blendMode: GskBlendMode) {
        gtk_snapshot_push_blend(snapshot_ptr, blendMode)
    
    }

    /// Blurs an image.
    /// 
    /// The image is recorded until the next call to `gtk_snapshot_pop()`.
    @inlinable func pushBlur(radius: CDouble) {
        gtk_snapshot_push_blur(snapshot_ptr, radius)
    
    }

    /// Clips an image to a rectangle.
    /// 
    /// The image is recorded until the next call to `gtk_snapshot_pop()`.
    @inlinable func pushClip(bounds: UnsafePointer<graphene_rect_t>!) {
        gtk_snapshot_push_clip(snapshot_ptr, bounds)
    
    }

    /// Modifies the colors of an image by applying an affine transformation
    /// in RGB space.
    /// 
    /// The image is recorded until the next call to `gtk_snapshot_pop()`.
    @inlinable func push(colorMatrix: UnsafePointer<graphene_matrix_t>!, colorOffset: UnsafePointer<graphene_vec4_t>!) {
        gtk_snapshot_push_color_matrix(snapshot_ptr, colorMatrix, colorOffset)
    
    }

    /// Snapshots a cross-fade operation between two images with the
    /// given `progress`.
    /// 
    /// Until the first call to `gtk_snapshot_pop()`, the start image
    /// will be snapshot. After that call, the end image will be recorded
    /// until the second call to `gtk_snapshot_pop()`.
    /// 
    /// Calling this function requires 2 calls to `gtk_snapshot_pop()`.
    @inlinable func pushCrossFade(progress: CDouble) {
        gtk_snapshot_push_cross_fade(snapshot_ptr, progress)
    
    }


    // *** pushDebug() is not available because it has a varargs (...) parameter!


    /// Push a `GskGLShaderNode` with a specific `GskGLShader` and a set of uniform values
    /// to use while rendering. Additionally this takes a list of `n_children` other nodes
    /// which will be passed to the `GskGLShaderNode`.
    /// 
    /// The `take_args` argument is a block of data to use for uniform
    /// arguments, as per types and offsets defined by the `shader`. Normally this is
    /// generated by `gsk_gl_shader_format_args()` or `GskGLShaderArgBuilder`.
    /// The snapshotter takes ownership of `take_args`, so the caller should not free it
    /// after this.
    /// 
    /// If the renderer doesn't support GL shaders, or if there is any problem when
    /// compiling the shader, then the node will draw pink. You should use
    /// `gsk_gl_shader_compile()` to ensure the `shader` will work for the renderer
    /// before using it.
    /// 
    /// If the shader requires textures (see `gsk_gl_shader_get_n_textures()`), then it is
    /// expected that you call `gtk_snapshot_gl_shader_pop_texture()` the number of times that are
    /// required. Each of these calls will generate a node that is added as a child to the gl shader
    /// node, which in turn will render these offscreen and pass as a texture to the shader.
    /// 
    /// Once all textures (if any) are pop:ed, you must call the regular `gtk_snapshot_pop()`.
    /// 
    /// If you want to use pre-existing textures as input to the shader rather than
    /// rendering new ones, use `gtk_snapshot_append_texture()` to push a texture node. These
    /// will be used directly rather than being re-rendered.
    /// 
    /// For details on how to write shaders, see `GskGLShader`.
    @inlinable func pushGl<BytesT: GLib.BytesProtocol>(shader: UnsafeMutablePointer<GskGLShader>!, bounds: UnsafePointer<graphene_rect_t>!, takeArgs: BytesT) {
        gtk_snapshot_push_gl_shader(snapshot_ptr, shader, bounds, takeArgs.bytes_ptr)
    
    }

    /// Modifies the opacity of an image.
    /// 
    /// The image is recorded until the next call to `gtk_snapshot_pop()`.
    @inlinable func push(opacity: CDouble) {
        gtk_snapshot_push_opacity(snapshot_ptr, opacity)
    
    }

    /// Creates a node that repeats the child node.
    /// 
    /// The child is recorded until the next call to `gtk_snapshot_pop()`.
    @inlinable func pushRepeat(bounds: UnsafePointer<graphene_rect_t>!, childBounds: UnsafePointer<graphene_rect_t>? = nil) {
        gtk_snapshot_push_repeat(snapshot_ptr, bounds, childBounds)
    
    }

    /// Clips an image to a rounded rectangle.
    /// 
    /// The image is recorded until the next call to `gtk_snapshot_pop()`.
    @inlinable func pushRoundedClip(bounds: UnsafePointer<GskRoundedRect>!) {
        gtk_snapshot_push_rounded_clip(snapshot_ptr, bounds)
    
    }

    /// Applies a shadow to an image.
    /// 
    /// The image is recorded until the next call to `gtk_snapshot_pop()`.
    @inlinable func push(shadow: UnsafePointer<GskShadow>!, nShadows: Int) {
        gtk_snapshot_push_shadow(snapshot_ptr, shadow, gsize(nShadows))
    
    }

    /// Creates a render node for the CSS background according to `context`,
    /// and appends it to the current node of `snapshot`, without changing
    /// the current node.
    @inlinable func renderBackground<StyleContextT: StyleContextProtocol>(context: StyleContextT, x: CDouble, y: CDouble, width: CDouble, height: CDouble) {
        gtk_snapshot_render_background(snapshot_ptr, context.style_context_ptr, x, y, width, height)
    
    }

    /// Creates a render node for the focus outline according to `context`,
    /// and appends it to the current node of `snapshot`, without changing
    /// the current node.
    @inlinable func renderFocus<StyleContextT: StyleContextProtocol>(context: StyleContextT, x: CDouble, y: CDouble, width: CDouble, height: CDouble) {
        gtk_snapshot_render_focus(snapshot_ptr, context.style_context_ptr, x, y, width, height)
    
    }

    /// Creates a render node for the CSS border according to `context`,
    /// and appends it to the current node of `snapshot`, without changing
    /// the current node.
    @inlinable func renderFrame<StyleContextT: StyleContextProtocol>(context: StyleContextT, x: CDouble, y: CDouble, width: CDouble, height: CDouble) {
        gtk_snapshot_render_frame(snapshot_ptr, context.style_context_ptr, x, y, width, height)
    
    }

    /// Draws a text caret using `snapshot` at the specified index of `layout`.
    @inlinable func renderInsertionCursor<LayoutT: Pango.LayoutProtocol, StyleContextT: StyleContextProtocol>(context: StyleContextT, x: CDouble, y: CDouble, layout: LayoutT, index: Int, direction: PangoDirection) {
        gtk_snapshot_render_insertion_cursor(snapshot_ptr, context.style_context_ptr, x, y, layout.layout_ptr, gint(index), direction)
    
    }

    /// Creates a render node for rendering `layout` according to the style
    /// information in `context`, and appends it to the current node of `snapshot`,
    /// without changing the current node.
    @inlinable func renderLayout<LayoutT: Pango.LayoutProtocol, StyleContextT: StyleContextProtocol>(context: StyleContextT, x: CDouble, y: CDouble, layout: LayoutT) {
        gtk_snapshot_render_layout(snapshot_ptr, context.style_context_ptr, x, y, layout.layout_ptr)
    
    }

    /// Restores `snapshot` to the state saved by a preceding call to
    /// `gtk_snapshot_save()` and removes that state from the stack of
    /// saved states.
    @inlinable func restore() {
        gtk_snapshot_restore(snapshot_ptr)
    
    }

    /// Rotates @`snapshot`'s coordinate system by `angle` degrees in 2D space -
    /// or in 3D speak, rotates around the z axis.
    @inlinable func rotate(angle: CFloat) {
        gtk_snapshot_rotate(snapshot_ptr, angle)
    
    }

    /// Rotates `snapshot`'s coordinate system by `angle` degrees around `axis`.
    /// 
    /// For a rotation in 2D space, use `gsk_transform_rotate()`.
    @inlinable func rotate3d(angle: CFloat, axis: UnsafePointer<graphene_vec3_t>!) {
        gtk_snapshot_rotate_3d(snapshot_ptr, angle, axis)
    
    }

    /// Makes a copy of the current state of `snapshot` and saves it
    /// on an internal stack of saved states for `snapshot`. When
    /// `gtk_snapshot_restore()` is called, `snapshot` will be restored to
    /// the saved state. Multiple calls to `gtk_snapshot_save()` and
    /// `gtk_snapshot_restore()` can be nested; each call to
    /// `gtk_snapshot_restore()` restores the state from the matching paired
    /// `gtk_snapshot_save()`.
    /// 
    /// It is necessary to clear all saved states with corresponding calls
    /// to `gtk_snapshot_restore()`.
    @inlinable func save() {
        gtk_snapshot_save(snapshot_ptr)
    
    }

    /// Scales `snapshot`'s coordinate system in 2-dimensional space by
    /// the given factors.
    /// 
    /// Use `gtk_snapshot_scale_3d()` to scale in all 3 dimensions.
    @inlinable func scale(factorX: CFloat, factorY: CFloat) {
        gtk_snapshot_scale(snapshot_ptr, factorX, factorY)
    
    }

    /// Scales `snapshot`'s coordinate system by the given factors.
    @inlinable func scale3d(factorX: CFloat, factorY: CFloat, factorZ: CFloat) {
        gtk_snapshot_scale_3d(snapshot_ptr, factorX, factorY, factorZ)
    
    }

    /// Returns the render node that was constructed
    /// by `snapshot`. After calling this function, it
    /// is no longer possible to add more nodes to
    /// `snapshot`. The only function that should be
    /// called after this is `g_object_unref()`.
    @inlinable func toNode() -> UnsafeMutablePointer<GskRenderNode>! {
        let rv = gtk_snapshot_to_node(snapshot_ptr)
        return rv
    }

    /// Returns a paintable encapsulating the render node
    /// that was constructed by `snapshot`. After calling
    /// this function, it is no longer possible to add more
    /// nodes to `snapshot`. The only function that should be
    /// called after this is `g_object_unref()`.
    @inlinable func toPaintable(size: UnsafePointer<graphene_size_t>? = nil) -> Gdk.PaintableRef! {
        let rv = Gdk.PaintableRef(gtk_snapshot_to_paintable(snapshot_ptr, size))
        return rv
    }

    /// Transforms `snapshot`'s coordinate system with the given `transform`.
    @inlinable func transform(transform: UnsafeMutablePointer<GskTransform>? = nil) {
        gtk_snapshot_transform(snapshot_ptr, transform)
    
    }

    /// Transforms `snapshot`'s coordinate system with the given `matrix`.
    @inlinable func transform(matrix: UnsafePointer<graphene_matrix_t>!) {
        gtk_snapshot_transform_matrix(snapshot_ptr, matrix)
    
    }

    /// Translates `snapshot`'s coordinate system by `point` in 2-dimensional space.
    @inlinable func translate(point: UnsafePointer<graphene_point_t>!) {
        gtk_snapshot_translate(snapshot_ptr, point)
    
    }

    /// Translates `snapshot`'s coordinate system by `point`.
    @inlinable func translate3d(point: UnsafePointer<graphene_point3d_t>!) {
        gtk_snapshot_translate_3d(snapshot_ptr, point)
    
    }


}



// MARK: - SortListModel Class

/// The `SortListModelProtocol` protocol exposes the methods and properties of an underlying `GtkSortListModel` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `SortListModel`.
/// Alternatively, use `SortListModelRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkSortListModel` is a list model that takes a list model and
/// sorts its elements according to a `GtkSorter`.
/// 
/// The model can be set up to do incremental sorting, so that
/// sorting long lists doesn't block the UI. See
/// `gtk_sort_list_model_set_incremental()` for details.
/// 
/// `GtkSortListModel` is a generic model and because of that it
/// cannot take advantage of any external knowledge when sorting.
/// If you run into performance issues with `GtkSortListModel`, it
/// is strongly recommended that you write your own sorting list
/// model.
public protocol SortListModelProtocol: GLibObject.ObjectProtocol, GIO.ListModelProtocol {
        /// Untyped pointer to the underlying `GtkSortListModel` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkSortListModel` instance.
    var sort_list_model_ptr: UnsafeMutablePointer<GtkSortListModel>! { get }

}

/// The `SortListModelRef` type acts as a lightweight Swift reference to an underlying `GtkSortListModel` instance.
/// It exposes methods that can operate on this data type through `SortListModelProtocol` conformance.
/// Use `SortListModelRef` only as an `unowned` reference to an existing `GtkSortListModel` instance.
///
/// `GtkSortListModel` is a list model that takes a list model and
/// sorts its elements according to a `GtkSorter`.
/// 
/// The model can be set up to do incremental sorting, so that
/// sorting long lists doesn't block the UI. See
/// `gtk_sort_list_model_set_incremental()` for details.
/// 
/// `GtkSortListModel` is a generic model and because of that it
/// cannot take advantage of any external knowledge when sorting.
/// If you run into performance issues with `GtkSortListModel`, it
/// is strongly recommended that you write your own sorting list
/// model.
public struct SortListModelRef: SortListModelProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkSortListModel` instance.
    /// For type-safe access, use the generated, typed pointer `sort_list_model_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension SortListModelRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkSortListModel>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkSortListModel>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkSortListModel>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkSortListModel>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `SortListModelProtocol`
    @inlinable init<T: SortListModelProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: SortListModelProtocol>(_ other: T) -> SortListModelRef { SortListModelRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SortListModelProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SortListModelProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SortListModelProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SortListModelProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SortListModelProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new sort list model that uses the `sorter` to sort `model`.
    @inlinable init<ListModelT: GIO.ListModelProtocol, SorterT: SorterProtocol>( model: ListModelT?, sorter: SorterT?) {
        let rv = gtk_sort_list_model_new(model?.list_model_ptr, sorter?.sorter_ptr)
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `SortListModel` type acts as a reference-counted owner of an underlying `GtkSortListModel` instance.
/// It provides the methods that can operate on this data type through `SortListModelProtocol` conformance.
/// Use `SortListModel` as a strong reference or owner of a `GtkSortListModel` instance.
///
/// `GtkSortListModel` is a list model that takes a list model and
/// sorts its elements according to a `GtkSorter`.
/// 
/// The model can be set up to do incremental sorting, so that
/// sorting long lists doesn't block the UI. See
/// `gtk_sort_list_model_set_incremental()` for details.
/// 
/// `GtkSortListModel` is a generic model and because of that it
/// cannot take advantage of any external knowledge when sorting.
/// If you run into performance issues with `GtkSortListModel`, it
/// is strongly recommended that you write your own sorting list
/// model.
open class SortListModel: GLibObject.Object, SortListModelProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SortListModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkSortListModel>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SortListModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkSortListModel>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SortListModel` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SortListModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SortListModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkSortListModel>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SortListModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkSortListModel>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkSortListModel`.
    /// i.e., ownership is transferred to the `SortListModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkSortListModel>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `SortListModelProtocol`
    /// Will retain `GtkSortListModel`.
    /// - Parameter other: an instance of a related type that implements `SortListModelProtocol`
    @inlinable public init<T: SortListModelProtocol>(sortListModel other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SortListModelProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SortListModelProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SortListModelProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SortListModelProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SortListModelProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SortListModelProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SortListModelProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SortListModelProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new sort list model that uses the `sorter` to sort `model`.
    @inlinable public init<ListModelT: GIO.ListModelProtocol, SorterT: SorterProtocol>( model: ListModelT?, sorter: SorterT?) {
        let rv = gtk_sort_list_model_new(model?.list_model_ptr, sorter?.sorter_ptr)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum SortListModelPropertyName: String, PropertyNameProtocol {
    /// If the model should sort items incrementally
    case incremental = "incremental"
    /// The model being sorted
    case model = "model"
    /// Estimate of unsorted items remaining
    case pending = "pending"
    /// The sorter for this model
    case sorter = "sorter"
}

public extension SortListModelProtocol {
    /// Bind a `SortListModelPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: SortListModelPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a SortListModel property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: SortListModelPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a SortListModel property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: SortListModelPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

// MARK: SortListModel has no signals// MARK: SortListModel Class: SortListModelProtocol extension (methods and fields)
public extension SortListModelProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkSortListModel` instance.
    @inlinable var sort_list_model_ptr: UnsafeMutablePointer<GtkSortListModel>! { return ptr?.assumingMemoryBound(to: GtkSortListModel.self) }

    /// Returns whether incremental sorting was enabled via
    /// `gtk_sort_list_model_set_incremental()`.
    @inlinable func getIncremental() -> Bool {
        let rv = ((gtk_sort_list_model_get_incremental(sort_list_model_ptr)) != 0)
        return rv
    }

    /// Gets the model currently sorted or `nil` if none.
    @inlinable func getModel() -> GIO.ListModelRef! {
        let rv = GIO.ListModelRef(gtk_sort_list_model_get_model(sort_list_model_ptr))
        return rv
    }

    /// Estimates progress of an ongoing sorting operation
    /// 
    /// The estimate is the number of items that would still need to be
    /// sorted to finish the sorting operation if this was a linear
    /// algorithm. So this number is not related to how many items are
    /// already correctly sorted.
    /// 
    /// If you want to estimate the progress, you can use code like this:
    /// (C Language Example):
    /// ```C
    ///   pending = gtk_sort_list_model_get_pending (self);
    ///   model = gtk_sort_list_model_get_model (self);
    ///   progress = 1.0 - pending / (double) MAX (1, g_list_model_get_n_items (model));
    /// ```
    /// 
    /// If no sort operation is ongoing - in particular when
    /// `GtkSortListModel:incremental` is `false` - this function returns 0.
    @inlinable func getPending() -> Int {
        let rv = Int(gtk_sort_list_model_get_pending(sort_list_model_ptr))
        return rv
    }

    /// Gets the sorter that is used to sort `self`.
    @inlinable func getSorter() -> SorterRef! {
        let rv = SorterRef(gconstpointer: gconstpointer(gtk_sort_list_model_get_sorter(sort_list_model_ptr)))
        return rv
    }

    /// Sets the sort model to do an incremental sort.
    /// 
    /// When incremental sorting is enabled, the sortlistmodel will not do
    /// a complete sort immediately, but will instead queue an idle handler that
    /// incrementally sorts the items towards their correct position. This of
    /// course means that items do not instantly appear in the right place. It
    /// also means that the total sorting time is a lot slower.
    /// 
    /// When your filter blocks the UI while sorting, you might consider
    /// turning this on. Depending on your model and sorters, this may become
    /// interesting around 10,000 to 100,000 items.
    /// 
    /// By default, incremental sorting is disabled.
    /// 
    /// See `gtk_sort_list_model_get_pending()` for progress information
    /// about an ongoing incremental sorting operation.
    @inlinable func set(incremental: Bool) {
        gtk_sort_list_model_set_incremental(sort_list_model_ptr, gboolean((incremental) ? 1 : 0))
    
    }

    /// Sets the model to be sorted. The `model`'s item type must conform to
    /// the item type of `self`.
    @inlinable func set(model: GIO.ListModelRef? = nil) {
        gtk_sort_list_model_set_model(sort_list_model_ptr, model?.list_model_ptr)
    
    }
    /// Sets the model to be sorted. The `model`'s item type must conform to
    /// the item type of `self`.
    @inlinable func set<ListModelT: GIO.ListModelProtocol>(model: ListModelT?) {
        gtk_sort_list_model_set_model(sort_list_model_ptr, model?.list_model_ptr)
    
    }

    /// Sets a new sorter on `self`.
    @inlinable func set(sorter: SorterRef? = nil) {
        gtk_sort_list_model_set_sorter(sort_list_model_ptr, sorter?.sorter_ptr)
    
    }
    /// Sets a new sorter on `self`.
    @inlinable func set<SorterT: SorterProtocol>(sorter: SorterT?) {
        gtk_sort_list_model_set_sorter(sort_list_model_ptr, sorter?.sorter_ptr)
    
    }
    /// If the model should sort items incrementally
    @inlinable var incremental: Bool {
        /// Returns whether incremental sorting was enabled via
        /// `gtk_sort_list_model_set_incremental()`.
        get {
            let rv = ((gtk_sort_list_model_get_incremental(sort_list_model_ptr)) != 0)
            return rv
        }
        /// Sets the sort model to do an incremental sort.
        /// 
        /// When incremental sorting is enabled, the sortlistmodel will not do
        /// a complete sort immediately, but will instead queue an idle handler that
        /// incrementally sorts the items towards their correct position. This of
        /// course means that items do not instantly appear in the right place. It
        /// also means that the total sorting time is a lot slower.
        /// 
        /// When your filter blocks the UI while sorting, you might consider
        /// turning this on. Depending on your model and sorters, this may become
        /// interesting around 10,000 to 100,000 items.
        /// 
        /// By default, incremental sorting is disabled.
        /// 
        /// See `gtk_sort_list_model_get_pending()` for progress information
        /// about an ongoing incremental sorting operation.
        nonmutating set {
            gtk_sort_list_model_set_incremental(sort_list_model_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// The model being sorted
    @inlinable var model: GIO.ListModelRef! {
        /// Gets the model currently sorted or `nil` if none.
        get {
            let rv = GIO.ListModelRef(gtk_sort_list_model_get_model(sort_list_model_ptr))
            return rv
        }
        /// Sets the model to be sorted. The `model`'s item type must conform to
        /// the item type of `self`.
        nonmutating set {
            gtk_sort_list_model_set_model(sort_list_model_ptr, UnsafeMutablePointer<GListModel>(newValue?.list_model_ptr))
        }
    }

    /// Estimate of unsorted items remaining
    @inlinable var pending: Int {
        /// Estimates progress of an ongoing sorting operation
        /// 
        /// The estimate is the number of items that would still need to be
        /// sorted to finish the sorting operation if this was a linear
        /// algorithm. So this number is not related to how many items are
        /// already correctly sorted.
        /// 
        /// If you want to estimate the progress, you can use code like this:
        /// (C Language Example):
        /// ```C
        ///   pending = gtk_sort_list_model_get_pending (self);
        ///   model = gtk_sort_list_model_get_model (self);
        ///   progress = 1.0 - pending / (double) MAX (1, g_list_model_get_n_items (model));
        /// ```
        /// 
        /// If no sort operation is ongoing - in particular when
        /// `GtkSortListModel:incremental` is `false` - this function returns 0.
        get {
            let rv = Int(gtk_sort_list_model_get_pending(sort_list_model_ptr))
            return rv
        }
    }

    /// The sorter for this model
    @inlinable var sorter: SorterRef! {
        /// Gets the sorter that is used to sort `self`.
        get {
            let rv = SorterRef(gconstpointer: gconstpointer(gtk_sort_list_model_get_sorter(sort_list_model_ptr)))
            return rv
        }
        /// Sets a new sorter on `self`.
        nonmutating set {
            gtk_sort_list_model_set_sorter(sort_list_model_ptr, UnsafeMutablePointer<GtkSorter>(newValue?.sorter_ptr))
        }
    }


}



// MARK: - Sorter Class

/// The `SorterProtocol` protocol exposes the methods and properties of an underlying `GtkSorter` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `Sorter`.
/// Alternatively, use `SorterRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkSorter` is the way to describe sorting criteria.
/// Its primary user is `GtkSortListModel`.
/// 
/// The model will use a sorter to determine the order in which its items should appear
/// by calling `gtk_sorter_compare()` for pairs of items.
/// 
/// Sorters may change their sorting behavior through their lifetime. In that case,
/// they will emit the `GtkSorter::changed` signal to notify that the sort order is
/// no longer valid and should be updated by calling `gtk_sorter_compare()` again.
/// 
/// GTK provides various pre-made sorter implementations for common sorting operations.
/// `GtkColumnView` has built-in support for sorting lists via the `GtkColumnViewColumn:sorter`
/// property, where the user can change the sorting by clicking on list headers.
/// 
/// Of course, in particular for large lists, it is also possible to subclass `GtkSorter`
/// and provide one's own sorter.
public protocol SorterProtocol: GLibObject.ObjectProtocol {
        /// Untyped pointer to the underlying `GtkSorter` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkSorter` instance.
    var sorter_ptr: UnsafeMutablePointer<GtkSorter>! { get }

}

/// The `SorterRef` type acts as a lightweight Swift reference to an underlying `GtkSorter` instance.
/// It exposes methods that can operate on this data type through `SorterProtocol` conformance.
/// Use `SorterRef` only as an `unowned` reference to an existing `GtkSorter` instance.
///
/// `GtkSorter` is the way to describe sorting criteria.
/// Its primary user is `GtkSortListModel`.
/// 
/// The model will use a sorter to determine the order in which its items should appear
/// by calling `gtk_sorter_compare()` for pairs of items.
/// 
/// Sorters may change their sorting behavior through their lifetime. In that case,
/// they will emit the `GtkSorter::changed` signal to notify that the sort order is
/// no longer valid and should be updated by calling `gtk_sorter_compare()` again.
/// 
/// GTK provides various pre-made sorter implementations for common sorting operations.
/// `GtkColumnView` has built-in support for sorting lists via the `GtkColumnViewColumn:sorter`
/// property, where the user can change the sorting by clicking on list headers.
/// 
/// Of course, in particular for large lists, it is also possible to subclass `GtkSorter`
/// and provide one's own sorter.
public struct SorterRef: SorterProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkSorter` instance.
    /// For type-safe access, use the generated, typed pointer `sorter_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension SorterRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkSorter>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkSorter>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkSorter>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkSorter>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `SorterProtocol`
    @inlinable init<T: SorterProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: SorterProtocol>(_ other: T) -> SorterRef { SorterRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SorterProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SorterProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SorterProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SorterProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SorterProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `Sorter` type acts as a reference-counted owner of an underlying `GtkSorter` instance.
/// It provides the methods that can operate on this data type through `SorterProtocol` conformance.
/// Use `Sorter` as a strong reference or owner of a `GtkSorter` instance.
///
/// `GtkSorter` is the way to describe sorting criteria.
/// Its primary user is `GtkSortListModel`.
/// 
/// The model will use a sorter to determine the order in which its items should appear
/// by calling `gtk_sorter_compare()` for pairs of items.
/// 
/// Sorters may change their sorting behavior through their lifetime. In that case,
/// they will emit the `GtkSorter::changed` signal to notify that the sort order is
/// no longer valid and should be updated by calling `gtk_sorter_compare()` again.
/// 
/// GTK provides various pre-made sorter implementations for common sorting operations.
/// `GtkColumnView` has built-in support for sorting lists via the `GtkColumnViewColumn:sorter`
/// property, where the user can change the sorting by clicking on list headers.
/// 
/// Of course, in particular for large lists, it is also possible to subclass `GtkSorter`
/// and provide one's own sorter.
open class Sorter: GLibObject.Object, SorterProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Sorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkSorter>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Sorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkSorter>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Sorter` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Sorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Sorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkSorter>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Sorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkSorter>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkSorter`.
    /// i.e., ownership is transferred to the `Sorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkSorter>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `SorterProtocol`
    /// Will retain `GtkSorter`.
    /// - Parameter other: an instance of a related type that implements `SorterProtocol`
    @inlinable public init<T: SorterProtocol>(sorter other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SorterProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SorterProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SorterProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SorterProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SorterProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SorterProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SorterProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SorterProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

// MARK: no Sorter properties

// MARK: Signals of Sorter
public extension SorterProtocol {
    /// This signal is emitted whenever the sorter changed. Users of the sorter
    /// should then update the sort order again via `gtk_sorter_compare()`.
    /// 
    /// `GtkSortListModel` handles this signal automatically.
    /// 
    /// Depending on the `change` parameter, it may be possible to update
    /// the sort order without a full resorting. Refer to the `GtkSorterChange`
    /// documentation for details.
    /// - Note: Representation of signal named `changed`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter change: how the sorter changed
    @discardableResult
    func onChanged(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SorterRef, _ change: SorterChange) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<SorterRef, SorterChange, Void>
        let cCallback: @convention(c) (gpointer, UInt32, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SorterRef(raw: unownedSelf), SorterChange(arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "changed", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    
}

// MARK: Sorter Class: SorterProtocol extension (methods and fields)
public extension SorterProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkSorter` instance.
    @inlinable var sorter_ptr: UnsafeMutablePointer<GtkSorter>! { return ptr?.assumingMemoryBound(to: GtkSorter.self) }

    /// Emits the `GtkSorter::changed` signal to notify all users of the sorter
    /// that it has changed. Users of the sorter should then update the sort
    /// order via `gtk_sorter_compare()`.
    /// 
    /// Depending on the `change` parameter, it may be possible to update
    /// the sort order without a full resorting. Refer to the `GtkSorterChange`
    /// documentation for details.
    /// 
    /// This function is intended for implementors of `GtkSorter` subclasses and
    /// should not be called from other functions.
    @inlinable func changed(change: GtkSorterChange) {
        gtk_sorter_changed(sorter_ptr, change)
    
    }

    /// Compares two given items according to the sort order implemented
    /// by the sorter.
    /// 
    /// Sorters implement a partial order:
    /// * It is reflexive, ie a = a
    /// * It is antisymmetric, ie if a < b and b < a, then a = b
    /// * It is transitive, ie given any 3 items with a ≤ b and b ≤ c,
    ///   then a ≤ c
    /// 
    /// The sorter  may signal it conforms to additional constraints
    /// via the return value of `gtk_sorter_get_order()`.
    @inlinable func compare<ObjectT: GLibObject.ObjectProtocol>(item1: ObjectT, item2: ObjectT) -> GtkOrdering {
        let rv = gtk_sorter_compare(sorter_ptr, item1.object_ptr, item2.object_ptr)
        return rv
    }

    /// Gets the order that `self` conforms to. See `GtkSorterOrder` for details
    /// of the possible return values.
    /// 
    /// This function is intended to allow optimizations.
    @inlinable func getOrder() -> GtkSorterOrder {
        let rv = gtk_sorter_get_order(sorter_ptr)
        return rv
    }
    /// Gets the order that `self` conforms to. See `GtkSorterOrder` for details
    /// of the possible return values.
    /// 
    /// This function is intended to allow optimizations.
    @inlinable var order: GtkSorterOrder {
        /// Gets the order that `self` conforms to. See `GtkSorterOrder` for details
        /// of the possible return values.
        /// 
        /// This function is intended to allow optimizations.
        get {
            let rv = gtk_sorter_get_order(sorter_ptr)
            return rv
        }
    }

    @inlinable var parentInstance: GObject {
        get {
            let rv = sorter_ptr.pointee.parent_instance
            return rv
        }
    }

}



// MARK: - SpinButton Class

/// The `SpinButtonProtocol` protocol exposes the methods and properties of an underlying `GtkSpinButton` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `SpinButton`.
/// Alternatively, use `SpinButtonRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A `GtkSpinButton` is an ideal way to allow the user to set the value of
/// some attribute. Rather than having to directly type a number into a
/// `GtkEntry`, GtkSpinButton allows the user to click on one of two arrows
/// to increment or decrement the displayed value. A value can still be
/// typed in, with the bonus that it can be checked to ensure it is in a
/// given range.
/// 
/// The main properties of a GtkSpinButton are through an adjustment.
/// See the `GtkAdjustment` section for more details about an adjustment's
/// properties.
/// 
/// Note that GtkSpinButton will by default make its entry large enough to
/// accommodate the lower and upper bounds of the adjustment. If this is
/// not desired, the automatic sizing can be turned off by explicitly
/// setting `GtkEditable::width`-chars to a value != -1.
/// 
/// ## Using a GtkSpinButton to get an integer
/// 
/// (C Language Example):
/// ```C
/// // Provides a function to retrieve an integer value from a GtkSpinButton
/// // and creates a spin button to model percentage values.
/// 
/// int
/// grab_int_value (GtkSpinButton *button,
///                 gpointer       user_data)
/// {
///   return gtk_spin_button_get_value_as_int (button);
/// }
/// 
/// void
/// create_integer_spin_button (void)
/// {
/// 
///   GtkWidget *window, *button;
///   GtkAdjustment *adjustment;
/// 
///   adjustment = gtk_adjustment_new (50.0, 0.0, 100.0, 1.0, 5.0, 0.0);
/// 
///   window = gtk_window_new ();
/// 
///   // creates the spinbutton, with no decimal places
///   button = gtk_spin_button_new (adjustment, 1.0, 0);
///   gtk_window_set_child (GTK_WINDOW (window), button);
/// 
///   gtk_widget_show (window);
/// }
/// ```
/// 
/// ## Using a GtkSpinButton to get a floating point value
/// 
/// (C Language Example):
/// ```C
/// // Provides a function to retrieve a floating point value from a
/// // GtkSpinButton, and creates a high precision spin button.
/// 
/// float
/// grab_float_value (GtkSpinButton *button,
///                   gpointer       user_data)
/// {
///   return gtk_spin_button_get_value (button);
/// }
/// 
/// void
/// create_floating_spin_button (void)
/// {
///   GtkWidget *window, *button;
///   GtkAdjustment *adjustment;
/// 
///   adjustment = gtk_adjustment_new (2.500, 0.0, 5.0, 0.001, 0.1, 0.0);
/// 
///   window = gtk_window_new ();
/// 
///   // creates the spinbutton, with three decimal places
///   button = gtk_spin_button_new (adjustment, 0.001, 3);
///   gtk_window_set_child (GTK_WINDOW (window), button);
/// 
///   gtk_widget_show (window);
/// }
/// ```
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// spinbutton.horizontal
/// ├── text
/// │    ├── undershoot.left
/// │    ╰── undershoot.right
/// ├── button.down
/// ╰── button.up
/// ```
/// 
/// (plain Language Example):
/// ```plain
/// spinbutton.vertical
/// ├── button.up
/// ├── text
/// │    ├── undershoot.left
/// │    ╰── undershoot.right
/// ╰── button.down
/// ```
/// 
/// GtkSpinButtons main CSS node has the name spinbutton. It creates subnodes
/// for the entry and the two buttons, with these names. The button nodes have
/// the style classes .up and .down. The GtkText subnodes (if present) are put
/// below the text node. The orientation of the spin button is reflected in
/// the .vertical or .horizontal style class on the main node.
/// 
/// # Accessiblity
/// 
/// GtkSpinButton uses the `GTK_ACCESSIBLE_ROLE_SPIN_BUTTON` role.
public protocol SpinButtonProtocol: WidgetProtocol, CellEditableProtocol, EditableProtocol, OrientableProtocol {
        /// Untyped pointer to the underlying `GtkSpinButton` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkSpinButton` instance.
    var spin_button_ptr: UnsafeMutablePointer<GtkSpinButton>! { get }

}

/// The `SpinButtonRef` type acts as a lightweight Swift reference to an underlying `GtkSpinButton` instance.
/// It exposes methods that can operate on this data type through `SpinButtonProtocol` conformance.
/// Use `SpinButtonRef` only as an `unowned` reference to an existing `GtkSpinButton` instance.
///
/// A `GtkSpinButton` is an ideal way to allow the user to set the value of
/// some attribute. Rather than having to directly type a number into a
/// `GtkEntry`, GtkSpinButton allows the user to click on one of two arrows
/// to increment or decrement the displayed value. A value can still be
/// typed in, with the bonus that it can be checked to ensure it is in a
/// given range.
/// 
/// The main properties of a GtkSpinButton are through an adjustment.
/// See the `GtkAdjustment` section for more details about an adjustment's
/// properties.
/// 
/// Note that GtkSpinButton will by default make its entry large enough to
/// accommodate the lower and upper bounds of the adjustment. If this is
/// not desired, the automatic sizing can be turned off by explicitly
/// setting `GtkEditable::width`-chars to a value != -1.
/// 
/// ## Using a GtkSpinButton to get an integer
/// 
/// (C Language Example):
/// ```C
/// // Provides a function to retrieve an integer value from a GtkSpinButton
/// // and creates a spin button to model percentage values.
/// 
/// int
/// grab_int_value (GtkSpinButton *button,
///                 gpointer       user_data)
/// {
///   return gtk_spin_button_get_value_as_int (button);
/// }
/// 
/// void
/// create_integer_spin_button (void)
/// {
/// 
///   GtkWidget *window, *button;
///   GtkAdjustment *adjustment;
/// 
///   adjustment = gtk_adjustment_new (50.0, 0.0, 100.0, 1.0, 5.0, 0.0);
/// 
///   window = gtk_window_new ();
/// 
///   // creates the spinbutton, with no decimal places
///   button = gtk_spin_button_new (adjustment, 1.0, 0);
///   gtk_window_set_child (GTK_WINDOW (window), button);
/// 
///   gtk_widget_show (window);
/// }
/// ```
/// 
/// ## Using a GtkSpinButton to get a floating point value
/// 
/// (C Language Example):
/// ```C
/// // Provides a function to retrieve a floating point value from a
/// // GtkSpinButton, and creates a high precision spin button.
/// 
/// float
/// grab_float_value (GtkSpinButton *button,
///                   gpointer       user_data)
/// {
///   return gtk_spin_button_get_value (button);
/// }
/// 
/// void
/// create_floating_spin_button (void)
/// {
///   GtkWidget *window, *button;
///   GtkAdjustment *adjustment;
/// 
///   adjustment = gtk_adjustment_new (2.500, 0.0, 5.0, 0.001, 0.1, 0.0);
/// 
///   window = gtk_window_new ();
/// 
///   // creates the spinbutton, with three decimal places
///   button = gtk_spin_button_new (adjustment, 0.001, 3);
///   gtk_window_set_child (GTK_WINDOW (window), button);
/// 
///   gtk_widget_show (window);
/// }
/// ```
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// spinbutton.horizontal
/// ├── text
/// │    ├── undershoot.left
/// │    ╰── undershoot.right
/// ├── button.down
/// ╰── button.up
/// ```
/// 
/// (plain Language Example):
/// ```plain
/// spinbutton.vertical
/// ├── button.up
/// ├── text
/// │    ├── undershoot.left
/// │    ╰── undershoot.right
/// ╰── button.down
/// ```
/// 
/// GtkSpinButtons main CSS node has the name spinbutton. It creates subnodes
/// for the entry and the two buttons, with these names. The button nodes have
/// the style classes .up and .down. The GtkText subnodes (if present) are put
/// below the text node. The orientation of the spin button is reflected in
/// the .vertical or .horizontal style class on the main node.
/// 
/// # Accessiblity
/// 
/// GtkSpinButton uses the `GTK_ACCESSIBLE_ROLE_SPIN_BUTTON` role.
public struct SpinButtonRef: SpinButtonProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkSpinButton` instance.
    /// For type-safe access, use the generated, typed pointer `spin_button_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension SpinButtonRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkSpinButton>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkSpinButton>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkSpinButton>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkSpinButton>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `SpinButtonProtocol`
    @inlinable init<T: SpinButtonProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: SpinButtonProtocol>(_ other: T) -> SpinButtonRef { SpinButtonRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinButtonProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinButtonProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinButtonProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinButtonProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinButtonProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkSpinButton`.
    @inlinable init<AdjustmentT: AdjustmentProtocol>( adjustment: AdjustmentT?, climbRate: CDouble, digits: Int) {
        let rv = gtk_spin_button_new(adjustment?.adjustment_ptr, climbRate, guint(digits))
        ptr = UnsafeMutableRawPointer(rv)
    }

    /// This is a convenience constructor that allows creation of a numeric
    /// `GtkSpinButton` without manually creating an adjustment. The value is
    /// initially set to the minimum value and a page increment of 10 * `step`
    /// is the default. The precision of the spin button is equivalent to the
    /// precision of `step`.
    /// 
    /// Note that the way in which the precision is derived works best if `step`
    /// is a power of ten. If the resulting precision is not suitable for your
    /// needs, use `gtk_spin_button_set_digits()` to correct it.
    @inlinable init(range min: CDouble, max: CDouble, step: CDouble) {
        let rv = gtk_spin_button_new_with_range(min, max, step)
        ptr = UnsafeMutableRawPointer(rv)
    }
    /// This is a convenience constructor that allows creation of a numeric
    /// `GtkSpinButton` without manually creating an adjustment. The value is
    /// initially set to the minimum value and a page increment of 10 * `step`
    /// is the default. The precision of the spin button is equivalent to the
    /// precision of `step`.
    /// 
    /// Note that the way in which the precision is derived works best if `step`
    /// is a power of ten. If the resulting precision is not suitable for your
    /// needs, use `gtk_spin_button_set_digits()` to correct it.
    @inlinable static func newWith(range min: CDouble, max: CDouble, step: CDouble) -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_spin_button_new_with_range(min, max, step))) else { return nil }
        return rv
    }
}

/// The `SpinButton` type acts as a reference-counted owner of an underlying `GtkSpinButton` instance.
/// It provides the methods that can operate on this data type through `SpinButtonProtocol` conformance.
/// Use `SpinButton` as a strong reference or owner of a `GtkSpinButton` instance.
///
/// A `GtkSpinButton` is an ideal way to allow the user to set the value of
/// some attribute. Rather than having to directly type a number into a
/// `GtkEntry`, GtkSpinButton allows the user to click on one of two arrows
/// to increment or decrement the displayed value. A value can still be
/// typed in, with the bonus that it can be checked to ensure it is in a
/// given range.
/// 
/// The main properties of a GtkSpinButton are through an adjustment.
/// See the `GtkAdjustment` section for more details about an adjustment's
/// properties.
/// 
/// Note that GtkSpinButton will by default make its entry large enough to
/// accommodate the lower and upper bounds of the adjustment. If this is
/// not desired, the automatic sizing can be turned off by explicitly
/// setting `GtkEditable::width`-chars to a value != -1.
/// 
/// ## Using a GtkSpinButton to get an integer
/// 
/// (C Language Example):
/// ```C
/// // Provides a function to retrieve an integer value from a GtkSpinButton
/// // and creates a spin button to model percentage values.
/// 
/// int
/// grab_int_value (GtkSpinButton *button,
///                 gpointer       user_data)
/// {
///   return gtk_spin_button_get_value_as_int (button);
/// }
/// 
/// void
/// create_integer_spin_button (void)
/// {
/// 
///   GtkWidget *window, *button;
///   GtkAdjustment *adjustment;
/// 
///   adjustment = gtk_adjustment_new (50.0, 0.0, 100.0, 1.0, 5.0, 0.0);
/// 
///   window = gtk_window_new ();
/// 
///   // creates the spinbutton, with no decimal places
///   button = gtk_spin_button_new (adjustment, 1.0, 0);
///   gtk_window_set_child (GTK_WINDOW (window), button);
/// 
///   gtk_widget_show (window);
/// }
/// ```
/// 
/// ## Using a GtkSpinButton to get a floating point value
/// 
/// (C Language Example):
/// ```C
/// // Provides a function to retrieve a floating point value from a
/// // GtkSpinButton, and creates a high precision spin button.
/// 
/// float
/// grab_float_value (GtkSpinButton *button,
///                   gpointer       user_data)
/// {
///   return gtk_spin_button_get_value (button);
/// }
/// 
/// void
/// create_floating_spin_button (void)
/// {
///   GtkWidget *window, *button;
///   GtkAdjustment *adjustment;
/// 
///   adjustment = gtk_adjustment_new (2.500, 0.0, 5.0, 0.001, 0.1, 0.0);
/// 
///   window = gtk_window_new ();
/// 
///   // creates the spinbutton, with three decimal places
///   button = gtk_spin_button_new (adjustment, 0.001, 3);
///   gtk_window_set_child (GTK_WINDOW (window), button);
/// 
///   gtk_widget_show (window);
/// }
/// ```
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// spinbutton.horizontal
/// ├── text
/// │    ├── undershoot.left
/// │    ╰── undershoot.right
/// ├── button.down
/// ╰── button.up
/// ```
/// 
/// (plain Language Example):
/// ```plain
/// spinbutton.vertical
/// ├── button.up
/// ├── text
/// │    ├── undershoot.left
/// │    ╰── undershoot.right
/// ╰── button.down
/// ```
/// 
/// GtkSpinButtons main CSS node has the name spinbutton. It creates subnodes
/// for the entry and the two buttons, with these names. The button nodes have
/// the style classes .up and .down. The GtkText subnodes (if present) are put
/// below the text node. The orientation of the spin button is reflected in
/// the .vertical or .horizontal style class on the main node.
/// 
/// # Accessiblity
/// 
/// GtkSpinButton uses the `GTK_ACCESSIBLE_ROLE_SPIN_BUTTON` role.
open class SpinButton: Widget, SpinButtonProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SpinButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkSpinButton>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SpinButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkSpinButton>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SpinButton` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SpinButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SpinButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkSpinButton>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SpinButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkSpinButton>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkSpinButton`.
    /// i.e., ownership is transferred to the `SpinButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkSpinButton>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `SpinButtonProtocol`
    /// Will retain `GtkSpinButton`.
    /// - Parameter other: an instance of a related type that implements `SpinButtonProtocol`
    @inlinable public init<T: SpinButtonProtocol>(spinButton other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinButtonProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinButtonProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinButtonProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinButtonProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinButtonProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinButtonProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinButtonProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinButtonProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkSpinButton`.
    @inlinable public init<AdjustmentT: AdjustmentProtocol>( adjustment: AdjustmentT?, climbRate: CDouble, digits: Int) {
        let rv = gtk_spin_button_new(adjustment?.adjustment_ptr, climbRate, guint(digits))
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// This is a convenience constructor that allows creation of a numeric
    /// `GtkSpinButton` without manually creating an adjustment. The value is
    /// initially set to the minimum value and a page increment of 10 * `step`
    /// is the default. The precision of the spin button is equivalent to the
    /// precision of `step`.
    /// 
    /// Note that the way in which the precision is derived works best if `step`
    /// is a power of ten. If the resulting precision is not suitable for your
    /// needs, use `gtk_spin_button_set_digits()` to correct it.
    @inlinable public init(range min: CDouble, max: CDouble, step: CDouble) {
        let rv = gtk_spin_button_new_with_range(min, max, step)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// This is a convenience constructor that allows creation of a numeric
    /// `GtkSpinButton` without manually creating an adjustment. The value is
    /// initially set to the minimum value and a page increment of 10 * `step`
    /// is the default. The precision of the spin button is equivalent to the
    /// precision of `step`.
    /// 
    /// Note that the way in which the precision is derived works best if `step`
    /// is a power of ten. If the resulting precision is not suitable for your
    /// needs, use `gtk_spin_button_set_digits()` to correct it.
    @inlinable public static func newWith(range min: CDouble, max: CDouble, step: CDouble) -> Widget! {
        guard let rv = Widget(gconstpointer: gconstpointer(gtk_spin_button_new_with_range(min, max, step))) else { return nil }
        if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
        return rv
    }

}

public enum SpinButtonPropertyName: String, PropertyNameProtocol {
    case adjustment = "adjustment"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    case canTarget = "can-target"
    case climbRate = "climb-rate"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`. See `gtk_widget_set_cursor()` for details.
    case cursor = "cursor"
    case digits = "digits"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case name = "name"
    case numeric = "numeric"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    case parent = "parent"
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget or `nil` if
    /// the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    case snapToTicks = "snap-to-ticks"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    case updatePolicy = "update-policy"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    case value = "value"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
    case wrap = "wrap"
}

public extension SpinButtonProtocol {
    /// Bind a `SpinButtonPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: SpinButtonPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a SpinButton property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: SpinButtonPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a SpinButton property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: SpinButtonPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

// MARK: Signals of SpinButton
public extension SpinButtonProtocol {
    /// The `input` signal can be used to influence the conversion of
    /// the users input into a double value. The signal handler is
    /// expected to use `gtk_editable_get_text()` to retrieve the text of
    /// the spinbutton and set `new_value` to the new value.
    /// 
    /// The default conversion uses `g_strtod()`.
    /// - Note: Representation of signal named `input`
    /// - Parameter flags: Flags
    /// - Parameter handler: `true` for a successful conversion, `false` if the input     was not handled, and `GTK_INPUT_ERROR` if the conversion failed.
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter newValue: return location for the new value
    /// - Warning: Wrapper of this signal could not be generated because it contains unimplemented features: { (1) argument with owner transfership is not allowed, (2)  argument out or inout direction is not allowed }
    /// - Note: Use this string for `signalConnectData` method
    static var onInput: String { "input" }
    /// The `change`-value signal is a [keybinding signal](#GtkSignalAction)
    /// which gets emitted when the user initiates a value change.
    /// 
    /// Applications should not connect to it, but may emit it with
    /// `g_signal_emit_by_name()` if they need to control the cursor
    /// programmatically.
    /// 
    /// The default bindings for this signal are Up/Down and PageUp and/PageDown.
    /// - Note: Representation of signal named `change-value`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter scroll: a `GtkScrollType` to specify the speed and amount of change
    @discardableResult
    func onChangeValue(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SpinButtonRef, _ scroll: ScrollType) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<SpinButtonRef, ScrollType, Void>
        let cCallback: @convention(c) (gpointer, UInt32, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SpinButtonRef(raw: unownedSelf), ScrollType(arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "change-value", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The `output` signal can be used to change to formatting
    /// of the value that is displayed in the spin buttons entry.
    /// (C Language Example):
    /// ```C
    /// // show leading zeros
    /// static gboolean
    /// on_output (GtkSpinButton *spin,
    ///            gpointer       data)
    /// {
    ///    GtkAdjustment *adjustment;
    ///    char *text;
    ///    int value;
    /// 
    ///    adjustment = gtk_spin_button_get_adjustment (spin);
    ///    value = (int)gtk_adjustment_get_value (adjustment);
    ///    text = g_strdup_printf ("%02d", value);
    ///    gtk_spin_button_set_text (spin, text):
    ///    g_free (text);
    /// 
    ///    return TRUE;
    /// }
    /// ```
    /// 
    /// - Note: Representation of signal named `output`
    /// - Parameter flags: Flags
    /// - Parameter handler: `true` if the value has been displayed
    /// - Parameter unownedSelf: Reference to instance of self
    @discardableResult
    func onOutput(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SpinButtonRef) -> Bool ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<SpinButtonRef, Bool>
        let cCallback: @convention(c) (gpointer, gpointer) -> gboolean = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call(SpinButtonRef(raw: unownedSelf))
            return gboolean((output) ? 1 : 0)
        }
        return signalConnectData(
            detailedSignal: "output", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The `value`-changed signal is emitted when the value represented by
    /// `spinbutton` changes. Also see the `GtkSpinButton::output` signal.
    /// - Note: Representation of signal named `value-changed`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    @discardableResult
    func onValueChanged(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SpinButtonRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<SpinButtonRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SpinButtonRef(raw: unownedSelf))
            return output
        }
        return signalConnectData(
            detailedSignal: "value-changed", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The `wrapped` signal is emitted right after the spinbutton wraps
    /// from its maximum to minimum value or vice-versa.
    /// - Note: Representation of signal named `wrapped`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    @discardableResult
    func onWrapped(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SpinButtonRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<SpinButtonRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SpinButtonRef(raw: unownedSelf))
            return output
        }
        return signalConnectData(
            detailedSignal: "wrapped", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::adjustment`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyAdjustment(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SpinButtonRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<SpinButtonRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SpinButtonRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::adjustment", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::climb-rate`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyClimbRate(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SpinButtonRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<SpinButtonRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SpinButtonRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::climb-rate", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::digits`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyDigits(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SpinButtonRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<SpinButtonRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SpinButtonRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::digits", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::numeric`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyNumeric(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SpinButtonRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<SpinButtonRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SpinButtonRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::numeric", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::snap-to-ticks`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifySnapToTicks(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SpinButtonRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<SpinButtonRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SpinButtonRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::snap-to-ticks", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::update-policy`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyUpdatePolicy(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SpinButtonRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<SpinButtonRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SpinButtonRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::update-policy", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::value`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyValue(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SpinButtonRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<SpinButtonRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SpinButtonRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::value", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::wrap`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyWrap(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SpinButtonRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<SpinButtonRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SpinButtonRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::wrap", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
}

// MARK: SpinButton Class: SpinButtonProtocol extension (methods and fields)
public extension SpinButtonProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkSpinButton` instance.
    @inlinable var spin_button_ptr: UnsafeMutablePointer<GtkSpinButton>! { return ptr?.assumingMemoryBound(to: GtkSpinButton.self) }

    /// Changes the properties of an existing spin button. The adjustment,
    /// climb rate, and number of decimal places are updated accordingly.
    @inlinable func configure(adjustment: AdjustmentRef? = nil, climbRate: CDouble, digits: Int) {
        gtk_spin_button_configure(spin_button_ptr, adjustment?.adjustment_ptr, climbRate, guint(digits))
    
    }
    /// Changes the properties of an existing spin button. The adjustment,
    /// climb rate, and number of decimal places are updated accordingly.
    @inlinable func configure<AdjustmentT: AdjustmentProtocol>(adjustment: AdjustmentT?, climbRate: CDouble, digits: Int) {
        gtk_spin_button_configure(spin_button_ptr, adjustment?.adjustment_ptr, climbRate, guint(digits))
    
    }

    /// Get the adjustment associated with a `GtkSpinButton`
    @inlinable func getAdjustment() -> AdjustmentRef! {
        let rv = AdjustmentRef(gconstpointer: gconstpointer(gtk_spin_button_get_adjustment(spin_button_ptr)))
        return rv
    }

    /// Returns the acceleration rate for repeated changes.
    @inlinable func getClimbRate() -> CDouble {
        let rv = gtk_spin_button_get_climb_rate(spin_button_ptr)
        return rv
    }

    /// Fetches the precision of `spin_button`. See `gtk_spin_button_set_digits()`.
    @inlinable func getDigits() -> Int {
        let rv = Int(gtk_spin_button_get_digits(spin_button_ptr))
        return rv
    }

    /// Gets the current step and page the increments used by `spin_button`. See
    /// `gtk_spin_button_set_increments()`.
    @inlinable func getIncrements(step: UnsafeMutablePointer<CDouble>! = nil, page: UnsafeMutablePointer<CDouble>! = nil) {
        gtk_spin_button_get_increments(spin_button_ptr, step, page)
    
    }

    /// Returns whether non-numeric text can be typed into the spin button.
    /// See `gtk_spin_button_set_numeric()`.
    @inlinable func getNumeric() -> Bool {
        let rv = ((gtk_spin_button_get_numeric(spin_button_ptr)) != 0)
        return rv
    }

    /// Gets the range allowed for `spin_button`.
    /// See `gtk_spin_button_set_range()`.
    @inlinable func getRange(min: UnsafeMutablePointer<CDouble>! = nil, max: UnsafeMutablePointer<CDouble>! = nil) {
        gtk_spin_button_get_range(spin_button_ptr, min, max)
    
    }

    /// Returns whether the values are corrected to the nearest step.
    /// See `gtk_spin_button_set_snap_to_ticks()`.
    @inlinable func getSnapToTicks() -> Bool {
        let rv = ((gtk_spin_button_get_snap_to_ticks(spin_button_ptr)) != 0)
        return rv
    }

    /// Gets the update behavior of a spin button.
    /// See `gtk_spin_button_set_update_policy()`.
    @inlinable func getUpdatePolicy() -> GtkSpinButtonUpdatePolicy {
        let rv = gtk_spin_button_get_update_policy(spin_button_ptr)
        return rv
    }

    /// Get the value in the `spin_button`.
    @inlinable func getValue() -> CDouble {
        let rv = gtk_spin_button_get_value(spin_button_ptr)
        return rv
    }

    /// Get the value `spin_button` represented as an integer.
    @inlinable func getValueAsInt() -> Int {
        let rv = Int(gtk_spin_button_get_value_as_int(spin_button_ptr))
        return rv
    }

    /// Returns whether the spin button’s value wraps around to the
    /// opposite limit when the upper or lower limit of the range is
    /// exceeded. See `gtk_spin_button_set_wrap()`.
    @inlinable func getWrap() -> Bool {
        let rv = ((gtk_spin_button_get_wrap(spin_button_ptr)) != 0)
        return rv
    }

    /// Replaces the `GtkAdjustment` associated with `spin_button`.
    @inlinable func set<AdjustmentT: AdjustmentProtocol>(adjustment: AdjustmentT) {
        gtk_spin_button_set_adjustment(spin_button_ptr, adjustment.adjustment_ptr)
    
    }

    /// Sets the acceleration rate for repeated changes when you
    /// hold down a button or key.
    @inlinable func set(climbRate: CDouble) {
        gtk_spin_button_set_climb_rate(spin_button_ptr, climbRate)
    
    }

    /// Set the precision to be displayed by `spin_button`. Up to 20 digit precision
    /// is allowed.
    @inlinable func set(digits: Int) {
        gtk_spin_button_set_digits(spin_button_ptr, guint(digits))
    
    }

    /// Sets the step and page increments for spin_button.  This affects how
    /// quickly the value changes when the spin button’s arrows are activated.
    @inlinable func setIncrements(step: CDouble, page: CDouble) {
        gtk_spin_button_set_increments(spin_button_ptr, step, page)
    
    }

    /// Sets the flag that determines if non-numeric text can be typed
    /// into the spin button.
    @inlinable func set(numeric: Bool) {
        gtk_spin_button_set_numeric(spin_button_ptr, gboolean((numeric) ? 1 : 0))
    
    }

    /// Sets the minimum and maximum allowable values for `spin_button`.
    /// 
    /// If the current value is outside this range, it will be adjusted
    /// to fit within the range, otherwise it will remain unchanged.
    @inlinable func setRange(min: CDouble, max: CDouble) {
        gtk_spin_button_set_range(spin_button_ptr, min, max)
    
    }

    /// Sets the policy as to whether values are corrected to the
    /// nearest step increment when a spin button is activated after
    /// providing an invalid value.
    @inlinable func set(snapToTicks: Bool) {
        gtk_spin_button_set_snap_to_ticks(spin_button_ptr, gboolean((snapToTicks) ? 1 : 0))
    
    }

    /// Sets the update behavior of a spin button.
    /// This determines whether the spin button is always updated
    /// or only when a valid value is set.
    @inlinable func setUpdate(policy: GtkSpinButtonUpdatePolicy) {
        gtk_spin_button_set_update_policy(spin_button_ptr, policy)
    
    }

    /// Sets the value of `spin_button`.
    @inlinable func set(value: CDouble) {
        gtk_spin_button_set_value(spin_button_ptr, value)
    
    }

    /// Sets the flag that determines if a spin button value wraps
    /// around to the opposite limit when the upper or lower limit
    /// of the range is exceeded.
    @inlinable func set(wrap: Bool) {
        gtk_spin_button_set_wrap(spin_button_ptr, gboolean((wrap) ? 1 : 0))
    
    }

    /// Increment or decrement a spin button’s value in a specified
    /// direction by a specified amount.
    @inlinable func spin(direction: GtkSpinType, increment: CDouble) {
        gtk_spin_button_spin(spin_button_ptr, direction, increment)
    
    }

    /// Manually force an update of the spin button.
    @inlinable func update() {
        gtk_spin_button_update(spin_button_ptr)
    
    }
    @inlinable var adjustment: AdjustmentRef! {
        /// Get the adjustment associated with a `GtkSpinButton`
        get {
            let rv = AdjustmentRef(gconstpointer: gconstpointer(gtk_spin_button_get_adjustment(spin_button_ptr)))
            return rv
        }
        /// Replaces the `GtkAdjustment` associated with `spin_button`.
        nonmutating set {
            gtk_spin_button_set_adjustment(spin_button_ptr, UnsafeMutablePointer<GtkAdjustment>(newValue?.adjustment_ptr))
        }
    }

    /// Returns the acceleration rate for repeated changes.
    @inlinable var climbRate: CDouble {
        /// Returns the acceleration rate for repeated changes.
        get {
            let rv = gtk_spin_button_get_climb_rate(spin_button_ptr)
            return rv
        }
        /// Sets the acceleration rate for repeated changes when you
        /// hold down a button or key.
        nonmutating set {
            gtk_spin_button_set_climb_rate(spin_button_ptr, newValue)
        }
    }

    @inlinable var digits: Int {
        /// Fetches the precision of `spin_button`. See `gtk_spin_button_set_digits()`.
        get {
            let rv = Int(gtk_spin_button_get_digits(spin_button_ptr))
            return rv
        }
        /// Set the precision to be displayed by `spin_button`. Up to 20 digit precision
        /// is allowed.
        nonmutating set {
            gtk_spin_button_set_digits(spin_button_ptr, guint(newValue))
        }
    }

    @inlinable var numeric: Bool {
        /// Returns whether non-numeric text can be typed into the spin button.
        /// See `gtk_spin_button_set_numeric()`.
        get {
            let rv = ((gtk_spin_button_get_numeric(spin_button_ptr)) != 0)
            return rv
        }
        /// Sets the flag that determines if non-numeric text can be typed
        /// into the spin button.
        nonmutating set {
            gtk_spin_button_set_numeric(spin_button_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns whether the values are corrected to the nearest step.
    /// See `gtk_spin_button_set_snap_to_ticks()`.
    @inlinable var snapToTicks: Bool {
        /// Returns whether the values are corrected to the nearest step.
        /// See `gtk_spin_button_set_snap_to_ticks()`.
        get {
            let rv = ((gtk_spin_button_get_snap_to_ticks(spin_button_ptr)) != 0)
            return rv
        }
        /// Sets the policy as to whether values are corrected to the
        /// nearest step increment when a spin button is activated after
        /// providing an invalid value.
        nonmutating set {
            gtk_spin_button_set_snap_to_ticks(spin_button_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Gets the update behavior of a spin button.
    /// See `gtk_spin_button_set_update_policy()`.
    @inlinable var updatePolicy: GtkSpinButtonUpdatePolicy {
        /// Gets the update behavior of a spin button.
        /// See `gtk_spin_button_set_update_policy()`.
        get {
            let rv = gtk_spin_button_get_update_policy(spin_button_ptr)
            return rv
        }
        /// Sets the update behavior of a spin button.
        /// This determines whether the spin button is always updated
        /// or only when a valid value is set.
        nonmutating set {
            gtk_spin_button_set_update_policy(spin_button_ptr, newValue)
        }
    }

    @inlinable var value: CDouble {
        /// Get the value in the `spin_button`.
        get {
            let rv = gtk_spin_button_get_value(spin_button_ptr)
            return rv
        }
        /// Sets the value of `spin_button`.
        nonmutating set {
            gtk_spin_button_set_value(spin_button_ptr, newValue)
        }
    }

    /// Get the value `spin_button` represented as an integer.
    @inlinable var valueAsInt: Int {
        /// Get the value `spin_button` represented as an integer.
        get {
            let rv = Int(gtk_spin_button_get_value_as_int(spin_button_ptr))
            return rv
        }
    }

    @inlinable var wrap: Bool {
        /// Returns whether the spin button’s value wraps around to the
        /// opposite limit when the upper or lower limit of the range is
        /// exceeded. See `gtk_spin_button_set_wrap()`.
        get {
            let rv = ((gtk_spin_button_get_wrap(spin_button_ptr)) != 0)
            return rv
        }
        /// Sets the flag that determines if a spin button value wraps
        /// around to the opposite limit when the upper or lower limit
        /// of the range is exceeded.
        nonmutating set {
            gtk_spin_button_set_wrap(spin_button_ptr, gboolean((newValue) ? 1 : 0))
        }
    }


}



// MARK: - Spinner Class

/// The `SpinnerProtocol` protocol exposes the methods and properties of an underlying `GtkSpinner` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `Spinner`.
/// Alternatively, use `SpinnerRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A GtkSpinner widget displays an icon-size spinning animation.
/// It is often used as an alternative to a `GtkProgressBar` for
/// displaying indefinite activity, instead of actual progress.
/// 
/// To start the animation, use `gtk_spinner_start()`, to stop it
/// use `gtk_spinner_stop()`.
/// 
/// # CSS nodes
/// 
/// GtkSpinner has a single CSS node with the name spinner.
/// When the animation is active, the :checked pseudoclass is
/// added to this node.
public protocol SpinnerProtocol: WidgetProtocol {
        /// Untyped pointer to the underlying `GtkSpinner` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkSpinner` instance.
    var spinner_ptr: UnsafeMutablePointer<GtkSpinner>! { get }

}

/// The `SpinnerRef` type acts as a lightweight Swift reference to an underlying `GtkSpinner` instance.
/// It exposes methods that can operate on this data type through `SpinnerProtocol` conformance.
/// Use `SpinnerRef` only as an `unowned` reference to an existing `GtkSpinner` instance.
///
/// A GtkSpinner widget displays an icon-size spinning animation.
/// It is often used as an alternative to a `GtkProgressBar` for
/// displaying indefinite activity, instead of actual progress.
/// 
/// To start the animation, use `gtk_spinner_start()`, to stop it
/// use `gtk_spinner_stop()`.
/// 
/// # CSS nodes
/// 
/// GtkSpinner has a single CSS node with the name spinner.
/// When the animation is active, the :checked pseudoclass is
/// added to this node.
public struct SpinnerRef: SpinnerProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkSpinner` instance.
    /// For type-safe access, use the generated, typed pointer `spinner_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension SpinnerRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkSpinner>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkSpinner>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkSpinner>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkSpinner>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `SpinnerProtocol`
    @inlinable init<T: SpinnerProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: SpinnerProtocol>(_ other: T) -> SpinnerRef { SpinnerRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinnerProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinnerProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinnerProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinnerProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinnerProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Returns a new spinner widget. Not yet started.
    @inlinable init() {
        let rv = gtk_spinner_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `Spinner` type acts as a reference-counted owner of an underlying `GtkSpinner` instance.
/// It provides the methods that can operate on this data type through `SpinnerProtocol` conformance.
/// Use `Spinner` as a strong reference or owner of a `GtkSpinner` instance.
///
/// A GtkSpinner widget displays an icon-size spinning animation.
/// It is often used as an alternative to a `GtkProgressBar` for
/// displaying indefinite activity, instead of actual progress.
/// 
/// To start the animation, use `gtk_spinner_start()`, to stop it
/// use `gtk_spinner_stop()`.
/// 
/// # CSS nodes
/// 
/// GtkSpinner has a single CSS node with the name spinner.
/// When the animation is active, the :checked pseudoclass is
/// added to this node.
open class Spinner: Widget, SpinnerProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Spinner` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkSpinner>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Spinner` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkSpinner>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Spinner` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Spinner` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Spinner` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkSpinner>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Spinner` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkSpinner>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkSpinner`.
    /// i.e., ownership is transferred to the `Spinner` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkSpinner>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `SpinnerProtocol`
    /// Will retain `GtkSpinner`.
    /// - Parameter other: an instance of a related type that implements `SpinnerProtocol`
    @inlinable public init<T: SpinnerProtocol>(spinner other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinnerProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinnerProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinnerProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinnerProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinnerProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinnerProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinnerProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinnerProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Returns a new spinner widget. Not yet started.
    @inlinable public init() {
        let rv = gtk_spinner_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum SpinnerPropertyName: String, PropertyNameProtocol {
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`. See `gtk_widget_set_cursor()` for details.
    case cursor = "cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case name = "name"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    case parent = "parent"
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget or `nil` if
    /// the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    case spinning = "spinning"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
}

public extension SpinnerProtocol {
    /// Bind a `SpinnerPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: SpinnerPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a Spinner property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: SpinnerPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a Spinner property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: SpinnerPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

// MARK: Spinner has no signals// MARK: Spinner Class: SpinnerProtocol extension (methods and fields)
public extension SpinnerProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkSpinner` instance.
    @inlinable var spinner_ptr: UnsafeMutablePointer<GtkSpinner>! { return ptr?.assumingMemoryBound(to: GtkSpinner.self) }

    /// Returns whether the spinner is spinning.
    @inlinable func getSpinning() -> Bool {
        let rv = ((gtk_spinner_get_spinning(spinner_ptr)) != 0)
        return rv
    }

    /// Sets the activity of the spinner.
    @inlinable func set(spinning: Bool) {
        gtk_spinner_set_spinning(spinner_ptr, gboolean((spinning) ? 1 : 0))
    
    }

    /// Starts the animation of the spinner.
    @inlinable func start() {
        gtk_spinner_start(spinner_ptr)
    
    }

    /// Stops the animation of the spinner.
    @inlinable func stop() {
        gtk_spinner_stop(spinner_ptr)
    
    }
    @inlinable var spinning: Bool {
        /// Returns whether the spinner is spinning.
        get {
            let rv = ((gtk_spinner_get_spinning(spinner_ptr)) != 0)
            return rv
        }
        /// Sets the activity of the spinner.
        nonmutating set {
            gtk_spinner_set_spinning(spinner_ptr, gboolean((newValue) ? 1 : 0))
        }
    }


}



// MARK: - Stack Class

/// The `StackProtocol` protocol exposes the methods and properties of an underlying `GtkStack` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `Stack`.
/// Alternatively, use `StackRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// The GtkStack widget is a container which only shows
/// one of its children at a time. In contrast to GtkNotebook,
/// GtkStack does not provide a means for users to change the
/// visible child. Instead, the `GtkStackSwitcher` widget can be
/// used with GtkStack to provide this functionality.
/// 
/// Transitions between pages can be animated as slides or
/// fades. This can be controlled with `gtk_stack_set_transition_type()`.
/// These animations respect the `GtkSettings:gtk`-enable-animations
/// setting.
/// 
/// GtkStack maintains a `GtkStackPage` object for each added
/// child, which holds additional per-child properties. You
/// obtain the `GtkStackPage` for a child with `gtk_stack_get_page()`.
/// 
/// # GtkStack as GtkBuildable
/// 
/// To set child-specific properties in a .ui file, create GtkStackPage
/// objects explicitly, and set the child widget as a property on it:
/// ```
///   <object class="GtkStack" id="stack">
///     <child>
///       <object class="GtkStackPage">
///         <property name="name">page1</property>
///         <property name="title">In the beginning…</property>
///         <property name="child">
///           <object class="GtkLabel">
///             <property name="label">It was dark</property>
///           </object>
///         </property>
///       </object>
///     </child>
/// ```
/// 
/// # CSS nodes
/// 
/// GtkStack has a single CSS node named stack.
/// 
/// # Accessibility
/// 
/// GtkStack uses the `GTK_ACCESSIBLE_ROLE_TAB_PANEL` for the stack
/// pages, which are the accessible parent objects of the child widgets.
public protocol StackProtocol: WidgetProtocol {
        /// Untyped pointer to the underlying `GtkStack` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkStack` instance.
    var stack_ptr: UnsafeMutablePointer<GtkStack>! { get }

}

/// The `StackRef` type acts as a lightweight Swift reference to an underlying `GtkStack` instance.
/// It exposes methods that can operate on this data type through `StackProtocol` conformance.
/// Use `StackRef` only as an `unowned` reference to an existing `GtkStack` instance.
///
/// The GtkStack widget is a container which only shows
/// one of its children at a time. In contrast to GtkNotebook,
/// GtkStack does not provide a means for users to change the
/// visible child. Instead, the `GtkStackSwitcher` widget can be
/// used with GtkStack to provide this functionality.
/// 
/// Transitions between pages can be animated as slides or
/// fades. This can be controlled with `gtk_stack_set_transition_type()`.
/// These animations respect the `GtkSettings:gtk`-enable-animations
/// setting.
/// 
/// GtkStack maintains a `GtkStackPage` object for each added
/// child, which holds additional per-child properties. You
/// obtain the `GtkStackPage` for a child with `gtk_stack_get_page()`.
/// 
/// # GtkStack as GtkBuildable
/// 
/// To set child-specific properties in a .ui file, create GtkStackPage
/// objects explicitly, and set the child widget as a property on it:
/// ```
///   <object class="GtkStack" id="stack">
///     <child>
///       <object class="GtkStackPage">
///         <property name="name">page1</property>
///         <property name="title">In the beginning…</property>
///         <property name="child">
///           <object class="GtkLabel">
///             <property name="label">It was dark</property>
///           </object>
///         </property>
///       </object>
///     </child>
/// ```
/// 
/// # CSS nodes
/// 
/// GtkStack has a single CSS node named stack.
/// 
/// # Accessibility
/// 
/// GtkStack uses the `GTK_ACCESSIBLE_ROLE_TAB_PANEL` for the stack
/// pages, which are the accessible parent objects of the child widgets.
public struct StackRef: StackProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkStack` instance.
    /// For type-safe access, use the generated, typed pointer `stack_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension StackRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkStack>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkStack>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkStack>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkStack>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `StackProtocol`
    @inlinable init<T: StackProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: StackProtocol>(_ other: T) -> StackRef { StackRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkStack` container.
    @inlinable init() {
        let rv = gtk_stack_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `Stack` type acts as a reference-counted owner of an underlying `GtkStack` instance.
/// It provides the methods that can operate on this data type through `StackProtocol` conformance.
/// Use `Stack` as a strong reference or owner of a `GtkStack` instance.
///
/// The GtkStack widget is a container which only shows
/// one of its children at a time. In contrast to GtkNotebook,
/// GtkStack does not provide a means for users to change the
/// visible child. Instead, the `GtkStackSwitcher` widget can be
/// used with GtkStack to provide this functionality.
/// 
/// Transitions between pages can be animated as slides or
/// fades. This can be controlled with `gtk_stack_set_transition_type()`.
/// These animations respect the `GtkSettings:gtk`-enable-animations
/// setting.
/// 
/// GtkStack maintains a `GtkStackPage` object for each added
/// child, which holds additional per-child properties. You
/// obtain the `GtkStackPage` for a child with `gtk_stack_get_page()`.
/// 
/// # GtkStack as GtkBuildable
/// 
/// To set child-specific properties in a .ui file, create GtkStackPage
/// objects explicitly, and set the child widget as a property on it:
/// ```
///   <object class="GtkStack" id="stack">
///     <child>
///       <object class="GtkStackPage">
///         <property name="name">page1</property>
///         <property name="title">In the beginning…</property>
///         <property name="child">
///           <object class="GtkLabel">
///             <property name="label">It was dark</property>
///           </object>
///         </property>
///       </object>
///     </child>
/// ```
/// 
/// # CSS nodes
/// 
/// GtkStack has a single CSS node named stack.
/// 
/// # Accessibility
/// 
/// GtkStack uses the `GTK_ACCESSIBLE_ROLE_TAB_PANEL` for the stack
/// pages, which are the accessible parent objects of the child widgets.
open class Stack: Widget, StackProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Stack` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkStack>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Stack` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkStack>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Stack` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Stack` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Stack` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkStack>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Stack` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkStack>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkStack`.
    /// i.e., ownership is transferred to the `Stack` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkStack>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `StackProtocol`
    /// Will retain `GtkStack`.
    /// - Parameter other: an instance of a related type that implements `StackProtocol`
    @inlinable public init<T: StackProtocol>(stack other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkStack` container.
    @inlinable public init() {
        let rv = gtk_stack_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum StackPropertyName: String, PropertyNameProtocol {
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`. See `gtk_widget_set_cursor()` for details.
    case cursor = "cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    /// `true` if the stack allocates the same width for all children.
    case hhomogeneous = "hhomogeneous"
    case interpolateSize = "interpolate-size"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case name = "name"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    case pages = "pages"
    case parent = "parent"
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget or `nil` if
    /// the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    case transitionDuration = "transition-duration"
    case transitionRunning = "transition-running"
    case transitionType = "transition-type"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    /// `true` if the stack allocates the same height for all children.
    case vhomogeneous = "vhomogeneous"
    case visible = "visible"
    case visibleChild = "visible-child"
    case visibleChildName = "visible-child-name"
    case widthRequest = "width-request"
}

public extension StackProtocol {
    /// Bind a `StackPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: StackPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a Stack property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: StackPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a Stack property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: StackPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

// MARK: Stack has no signals// MARK: Stack Class: StackProtocol extension (methods and fields)
public extension StackProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkStack` instance.
    @inlinable var stack_ptr: UnsafeMutablePointer<GtkStack>! { return ptr?.assumingMemoryBound(to: GtkStack.self) }

    /// Adds a child to `stack`.
    @inlinable func add<WidgetT: WidgetProtocol>(child: WidgetT) -> StackPageRef! {
        let rv = StackPageRef(gconstpointer: gconstpointer(gtk_stack_add_child(stack_ptr, child.widget_ptr)))
        return rv
    }

    /// Adds a child to `stack`.
    /// The child is identified by the `name`.
    @inlinable func addNamed<WidgetT: WidgetProtocol>(child: WidgetT, name: UnsafePointer<CChar>? = nil) -> StackPageRef! {
        let rv = StackPageRef(gconstpointer: gconstpointer(gtk_stack_add_named(stack_ptr, child.widget_ptr, name)))
        return rv
    }

    /// Adds a child to `stack`.
    /// The child is identified by the `name`. The `title`
    /// will be used by `GtkStackSwitcher` to represent
    /// `child` in a tab bar, so it should be short.
    @inlinable func addTitled<WidgetT: WidgetProtocol>(child: WidgetT, name: UnsafePointer<CChar>? = nil, title: UnsafePointer<CChar>!) -> StackPageRef! {
        let rv = StackPageRef(gconstpointer: gconstpointer(gtk_stack_add_titled(stack_ptr, child.widget_ptr, name, title)))
        return rv
    }

    /// Finds the child of the `GtkStack` with the name given as
    /// the argument. Returns `nil` if there is no child with this
    /// name.
    @inlinable func getChildBy(name: UnsafePointer<CChar>!) -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_stack_get_child_by_name(stack_ptr, name))) else { return nil }
        return rv
    }

    /// Gets whether `stack` is horizontally homogeneous.
    /// See `gtk_stack_set_hhomogeneous()`.
    @inlinable func getHhomogeneous() -> Bool {
        let rv = ((gtk_stack_get_hhomogeneous(stack_ptr)) != 0)
        return rv
    }

    /// Returns whether the `GtkStack` is set up to interpolate between
    /// the sizes of children on page switch.
    @inlinable func getInterpolateSize() -> Bool {
        let rv = ((gtk_stack_get_interpolate_size(stack_ptr)) != 0)
        return rv
    }

    /// Returns the `GtkStackPage` object for `child`.
    @inlinable func getPage<WidgetT: WidgetProtocol>(child: WidgetT) -> StackPageRef! {
        let rv = StackPageRef(gconstpointer: gconstpointer(gtk_stack_get_page(stack_ptr, child.widget_ptr)))
        return rv
    }

    /// Returns a `GListModel` that contains the pages of the stack,
    /// and can be used to keep an up-to-date view. The model also
    /// implements `GtkSelectionModel` and can be used to track and
    /// modify the visible page.
    @inlinable func getPages() -> SelectionModelRef! {
        let rv = SelectionModelRef(gconstpointer: gconstpointer(gtk_stack_get_pages(stack_ptr)))
        return rv
    }

    /// Returns the amount of time (in milliseconds) that
    /// transitions between pages in `stack` will take.
    @inlinable func getTransitionDuration() -> Int {
        let rv = Int(gtk_stack_get_transition_duration(stack_ptr))
        return rv
    }

    /// Returns whether the `stack` is currently in a transition from one page to
    /// another.
    @inlinable func getTransitionRunning() -> Bool {
        let rv = ((gtk_stack_get_transition_running(stack_ptr)) != 0)
        return rv
    }

    /// Gets the type of animation that will be used
    /// for transitions between pages in `stack`.
    @inlinable func getTransitionType() -> GtkStackTransitionType {
        let rv = gtk_stack_get_transition_type(stack_ptr)
        return rv
    }

    /// Gets whether `stack` is vertically homogeneous.
    /// See `gtk_stack_set_vhomogeneous()`.
    @inlinable func getVhomogeneous() -> Bool {
        let rv = ((gtk_stack_get_vhomogeneous(stack_ptr)) != 0)
        return rv
    }

    /// Gets the currently visible child of `stack`, or `nil` if
    /// there are no visible children.
    @inlinable func getVisibleChild() -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_stack_get_visible_child(stack_ptr))) else { return nil }
        return rv
    }

    /// Returns the name of the currently visible child of `stack`, or
    /// `nil` if there is no visible child.
    @inlinable func getVisibleChildName() -> String! {
        let rv = gtk_stack_get_visible_child_name(stack_ptr).map({ String(cString: $0) })
        return rv
    }

    /// Removes a child widget from `stack`.
    @inlinable func remove<WidgetT: WidgetProtocol>(child: WidgetT) {
        gtk_stack_remove(stack_ptr, child.widget_ptr)
    
    }

    /// Sets the `GtkStack` to be horizontally homogeneous or not.
    /// If it is homogeneous, the `GtkStack` will request the same
    /// width for all its children. If it isn't, the stack
    /// may change width when a different child becomes visible.
    @inlinable func set(hhomogeneous: Bool) {
        gtk_stack_set_hhomogeneous(stack_ptr, gboolean((hhomogeneous) ? 1 : 0))
    
    }

    /// Sets whether or not `stack` will interpolate its size when
    /// changing the visible child. If the `GtkStack:interpolate`-size
    /// property is set to `true`, `stack` will interpolate its size between
    /// the current one and the one it'll take after changing the
    /// visible child, according to the set transition duration.
    @inlinable func set(interpolateSize: Bool) {
        gtk_stack_set_interpolate_size(stack_ptr, gboolean((interpolateSize) ? 1 : 0))
    
    }

    /// Sets the duration that transitions between pages in `stack`
    /// will take.
    @inlinable func setTransition(duration: Int) {
        gtk_stack_set_transition_duration(stack_ptr, guint(duration))
    
    }

    /// Sets the type of animation that will be used for
    /// transitions between pages in `stack`. Available
    /// types include various kinds of fades and slides.
    /// 
    /// The transition type can be changed without problems
    /// at runtime, so it is possible to change the animation
    /// based on the page that is about to become current.
    @inlinable func setTransitionType(transition: GtkStackTransitionType) {
        gtk_stack_set_transition_type(stack_ptr, transition)
    
    }

    /// Sets the `GtkStack` to be vertically homogeneous or not.
    /// If it is homogeneous, the `GtkStack` will request the same
    /// height for all its children. If it isn't, the stack
    /// may change height when a different child becomes visible.
    @inlinable func set(vhomogeneous: Bool) {
        gtk_stack_set_vhomogeneous(stack_ptr, gboolean((vhomogeneous) ? 1 : 0))
    
    }

    /// Makes `child` the visible child of `stack`.
    /// 
    /// If `child` is different from the currently
    /// visible child, the transition between the
    /// two will be animated with the current
    /// transition type of `stack`.
    /// 
    /// Note that the `child` widget has to be visible itself
    /// (see `gtk_widget_show()`) in order to become the visible
    /// child of `stack`.
    @inlinable func setVisible<WidgetT: WidgetProtocol>(child: WidgetT) {
        gtk_stack_set_visible_child(stack_ptr, child.widget_ptr)
    
    }

    /// Makes the child with the given name visible.
    /// 
    /// Note that the child widget has to be visible itself
    /// (see `gtk_widget_show()`) in order to become the visible
    /// child of `stack`.
    @inlinable func setVisibleChildFull(name: UnsafePointer<CChar>!, transition: GtkStackTransitionType) {
        gtk_stack_set_visible_child_full(stack_ptr, name, transition)
    
    }

    /// Makes the child with the given name visible.
    /// 
    /// If `child` is different from the currently
    /// visible child, the transition between the
    /// two will be animated with the current
    /// transition type of `stack`.
    /// 
    /// Note that the child widget has to be visible itself
    /// (see `gtk_widget_show()`) in order to become the visible
    /// child of `stack`.
    @inlinable func setVisibleChild(name: UnsafePointer<CChar>!) {
        gtk_stack_set_visible_child_name(stack_ptr, name)
    
    }
    /// `true` if the stack allocates the same width for all children.
    @inlinable var hhomogeneous: Bool {
        /// Gets whether `stack` is horizontally homogeneous.
        /// See `gtk_stack_set_hhomogeneous()`.
        get {
            let rv = ((gtk_stack_get_hhomogeneous(stack_ptr)) != 0)
            return rv
        }
        /// Sets the `GtkStack` to be horizontally homogeneous or not.
        /// If it is homogeneous, the `GtkStack` will request the same
        /// width for all its children. If it isn't, the stack
        /// may change width when a different child becomes visible.
        nonmutating set {
            gtk_stack_set_hhomogeneous(stack_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns whether the `GtkStack` is set up to interpolate between
    /// the sizes of children on page switch.
    @inlinable var interpolateSize: Bool {
        /// Returns whether the `GtkStack` is set up to interpolate between
        /// the sizes of children on page switch.
        get {
            let rv = ((gtk_stack_get_interpolate_size(stack_ptr)) != 0)
            return rv
        }
        /// Sets whether or not `stack` will interpolate its size when
        /// changing the visible child. If the `GtkStack:interpolate`-size
        /// property is set to `true`, `stack` will interpolate its size between
        /// the current one and the one it'll take after changing the
        /// visible child, according to the set transition duration.
        nonmutating set {
            gtk_stack_set_interpolate_size(stack_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    @inlinable var pages: SelectionModelRef! {
        /// Returns a `GListModel` that contains the pages of the stack,
        /// and can be used to keep an up-to-date view. The model also
        /// implements `GtkSelectionModel` and can be used to track and
        /// modify the visible page.
        get {
            let rv = SelectionModelRef(gconstpointer: gconstpointer(gtk_stack_get_pages(stack_ptr)))
            return rv
        }
    }

    /// Returns the amount of time (in milliseconds) that
    /// transitions between pages in `stack` will take.
    @inlinable var transitionDuration: Int {
        /// Returns the amount of time (in milliseconds) that
        /// transitions between pages in `stack` will take.
        get {
            let rv = Int(gtk_stack_get_transition_duration(stack_ptr))
            return rv
        }
        /// Sets the duration that transitions between pages in `stack`
        /// will take.
        nonmutating set {
            gtk_stack_set_transition_duration(stack_ptr, guint(newValue))
        }
    }

    /// Returns whether the `stack` is currently in a transition from one page to
    /// another.
    @inlinable var transitionRunning: Bool {
        /// Returns whether the `stack` is currently in a transition from one page to
        /// another.
        get {
            let rv = ((gtk_stack_get_transition_running(stack_ptr)) != 0)
            return rv
        }
    }

    /// Gets the type of animation that will be used
    /// for transitions between pages in `stack`.
    @inlinable var transitionType: GtkStackTransitionType {
        /// Gets the type of animation that will be used
        /// for transitions between pages in `stack`.
        get {
            let rv = gtk_stack_get_transition_type(stack_ptr)
            return rv
        }
        /// Sets the type of animation that will be used for
        /// transitions between pages in `stack`. Available
        /// types include various kinds of fades and slides.
        /// 
        /// The transition type can be changed without problems
        /// at runtime, so it is possible to change the animation
        /// based on the page that is about to become current.
        nonmutating set {
            gtk_stack_set_transition_type(stack_ptr, newValue)
        }
    }

    /// `true` if the stack allocates the same height for all children.
    @inlinable var vhomogeneous: Bool {
        /// Gets whether `stack` is vertically homogeneous.
        /// See `gtk_stack_set_vhomogeneous()`.
        get {
            let rv = ((gtk_stack_get_vhomogeneous(stack_ptr)) != 0)
            return rv
        }
        /// Sets the `GtkStack` to be vertically homogeneous or not.
        /// If it is homogeneous, the `GtkStack` will request the same
        /// height for all its children. If it isn't, the stack
        /// may change height when a different child becomes visible.
        nonmutating set {
            gtk_stack_set_vhomogeneous(stack_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Gets the currently visible child of `stack`, or `nil` if
    /// there are no visible children.
    @inlinable var visibleChild: WidgetRef! {
        /// Gets the currently visible child of `stack`, or `nil` if
        /// there are no visible children.
        get {
            guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_stack_get_visible_child(stack_ptr))) else { return nil }
            return rv
        }
        /// Makes `child` the visible child of `stack`.
        /// 
        /// If `child` is different from the currently
        /// visible child, the transition between the
        /// two will be animated with the current
        /// transition type of `stack`.
        /// 
        /// Note that the `child` widget has to be visible itself
        /// (see `gtk_widget_show()`) in order to become the visible
        /// child of `stack`.
        nonmutating set {
            gtk_stack_set_visible_child(stack_ptr, UnsafeMutablePointer<GtkWidget>(newValue?.widget_ptr))
        }
    }

    /// Returns the name of the currently visible child of `stack`, or
    /// `nil` if there is no visible child.
    @inlinable var visibleChildName: String! {
        /// Returns the name of the currently visible child of `stack`, or
        /// `nil` if there is no visible child.
        get {
            let rv = gtk_stack_get_visible_child_name(stack_ptr).map({ String(cString: $0) })
            return rv
        }
        /// Makes the child with the given name visible.
        /// 
        /// If `child` is different from the currently
        /// visible child, the transition between the
        /// two will be animated with the current
        /// transition type of `stack`.
        /// 
        /// Note that the child widget has to be visible itself
        /// (see `gtk_widget_show()`) in order to become the visible
        /// child of `stack`.
        nonmutating set {
            gtk_stack_set_visible_child_name(stack_ptr, newValue)
        }
    }


}



// MARK: - StackPage Class

/// The `StackPageProtocol` protocol exposes the methods and properties of an underlying `GtkStackPage` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `StackPage`.
/// Alternatively, use `StackPageRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///

public protocol StackPageProtocol: GLibObject.ObjectProtocol, AccessibleProtocol {
        /// Untyped pointer to the underlying `GtkStackPage` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkStackPage` instance.
    var stack_page_ptr: UnsafeMutablePointer<GtkStackPage>! { get }

}

/// The `StackPageRef` type acts as a lightweight Swift reference to an underlying `GtkStackPage` instance.
/// It exposes methods that can operate on this data type through `StackPageProtocol` conformance.
/// Use `StackPageRef` only as an `unowned` reference to an existing `GtkStackPage` instance.
///

public struct StackPageRef: StackPageProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkStackPage` instance.
    /// For type-safe access, use the generated, typed pointer `stack_page_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension StackPageRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkStackPage>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkStackPage>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkStackPage>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkStackPage>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `StackPageProtocol`
    @inlinable init<T: StackPageProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: StackPageProtocol>(_ other: T) -> StackPageRef { StackPageRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackPageProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackPageProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackPageProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackPageProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackPageProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `StackPage` type acts as a reference-counted owner of an underlying `GtkStackPage` instance.
/// It provides the methods that can operate on this data type through `StackPageProtocol` conformance.
/// Use `StackPage` as a strong reference or owner of a `GtkStackPage` instance.
///

open class StackPage: GLibObject.Object, StackPageProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StackPage` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkStackPage>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StackPage` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkStackPage>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StackPage` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StackPage` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StackPage` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkStackPage>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StackPage` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkStackPage>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkStackPage`.
    /// i.e., ownership is transferred to the `StackPage` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkStackPage>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `StackPageProtocol`
    /// Will retain `GtkStackPage`.
    /// - Parameter other: an instance of a related type that implements `StackPageProtocol`
    @inlinable public init<T: StackPageProtocol>(stackPage other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackPageProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackPageProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackPageProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackPageProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackPageProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackPageProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackPageProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackPageProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum StackPagePropertyName: String, PropertyNameProtocol {
    case child = "child"
    case iconName = "icon-name"
    case name = "name"
    /// Sets a flag specifying whether the page requires the user attention.
    /// This is used by the `GtkStackSwitcher` to change the appearance of the
    /// corresponding button when a page needs attention and it is not the
    /// current one.
    case needsAttention = "needs-attention"
    case title = "title"
    case useUnderline = "use-underline"
    case visible = "visible"
}

public extension StackPageProtocol {
    /// Bind a `StackPagePropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: StackPagePropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a StackPage property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: StackPagePropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a StackPage property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: StackPagePropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

// MARK: StackPage has no signals// MARK: StackPage Class: StackPageProtocol extension (methods and fields)
public extension StackPageProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkStackPage` instance.
    @inlinable var stack_page_ptr: UnsafeMutablePointer<GtkStackPage>! { return ptr?.assumingMemoryBound(to: GtkStackPage.self) }

    /// Returns the stack child to which `self` belongs.
    @inlinable func getChild() -> WidgetRef! {
        let rv = WidgetRef(gconstpointer: gconstpointer(gtk_stack_page_get_child(stack_page_ptr)))
        return rv
    }

    /// Returns the current value of the `GtkStackPage:icon`-name property.
    @inlinable func getIconName() -> String! {
        let rv = gtk_stack_page_get_icon_name(stack_page_ptr).map({ String(cString: $0) })
        return rv
    }

    /// Returns the current value of the `GtkStackPage:name` property.
    @inlinable func getName() -> String! {
        let rv = gtk_stack_page_get_name(stack_page_ptr).map({ String(cString: $0) })
        return rv
    }

    /// Returns the current value of the `GtkStackPage:needs`-attention property.
    @inlinable func getNeedsAttention() -> Bool {
        let rv = ((gtk_stack_page_get_needs_attention(stack_page_ptr)) != 0)
        return rv
    }

    /// Returns the current value of the `GtkStackPage:title` property.
    @inlinable func getTitle() -> String! {
        let rv = gtk_stack_page_get_title(stack_page_ptr).map({ String(cString: $0) })
        return rv
    }

    /// Returns the current value of the `GtkStackPage:use`-underline property.
    @inlinable func getUseUnderline() -> Bool {
        let rv = ((gtk_stack_page_get_use_underline(stack_page_ptr)) != 0)
        return rv
    }

    /// Returns whether `page` is visible in its `GtkStack`.
    /// This is independent from the `GtkWidget:visible` value of its
    /// `GtkWidget`.
    @inlinable func getVisible() -> Bool {
        let rv = ((gtk_stack_page_get_visible(stack_page_ptr)) != 0)
        return rv
    }

    /// Sets the new value of the `GtkStackPage:icon`-name property.
    /// See also `gtk_stack_page_get_icon_name()`
    @inlinable func setIconName(setting: UnsafePointer<CChar>!) {
        gtk_stack_page_set_icon_name(stack_page_ptr, setting)
    
    }

    /// Sets the new value of the `GtkStackPage:name` property.
    /// See also `gtk_stack_page_get_name()`
    @inlinable func setName(setting: UnsafePointer<CChar>!) {
        gtk_stack_page_set_name(stack_page_ptr, setting)
    
    }

    /// Sets the new value of the `GtkStackPage:needs`-attention property.
    /// See also `gtk_stack_page_get_needs_attention()`
    @inlinable func setNeedsAttention(setting: Bool) {
        gtk_stack_page_set_needs_attention(stack_page_ptr, gboolean((setting) ? 1 : 0))
    
    }

    /// Sets the new value of the `GtkStackPage:title` property.
    /// See also `gtk_stack_page_get_title()`
    @inlinable func setTitle(setting: UnsafePointer<CChar>!) {
        gtk_stack_page_set_title(stack_page_ptr, setting)
    
    }

    /// Sets the new value of the `GtkStackPage:use`-underline property.
    /// See also `gtk_stack_page_get_use_underline()`
    @inlinable func setUseUnderline(setting: Bool) {
        gtk_stack_page_set_use_underline(stack_page_ptr, gboolean((setting) ? 1 : 0))
    
    }

    /// Sets the new value of the `GtkStackPage:visible` property
    /// to `visible`.
    @inlinable func set(visible: Bool) {
        gtk_stack_page_set_visible(stack_page_ptr, gboolean((visible) ? 1 : 0))
    
    }
    @inlinable var child: WidgetRef! {
        /// Returns the stack child to which `self` belongs.
        get {
            let rv = WidgetRef(gconstpointer: gconstpointer(gtk_stack_page_get_child(stack_page_ptr)))
            return rv
        }
    }

    /// Returns the current value of the `GtkStackPage:icon`-name property.
    @inlinable var iconName: String! {
        /// Returns the current value of the `GtkStackPage:icon`-name property.
        get {
            let rv = gtk_stack_page_get_icon_name(stack_page_ptr).map({ String(cString: $0) })
            return rv
        }
        /// Sets the new value of the `GtkStackPage:icon`-name property.
        /// See also `gtk_stack_page_get_icon_name()`
        nonmutating set {
            gtk_stack_page_set_icon_name(stack_page_ptr, newValue)
        }
    }

    @inlinable var name: String! {
        /// Returns the current value of the `GtkStackPage:name` property.
        get {
            let rv = gtk_stack_page_get_name(stack_page_ptr).map({ String(cString: $0) })
            return rv
        }
        /// Sets the new value of the `GtkStackPage:name` property.
        /// See also `gtk_stack_page_get_name()`
        nonmutating set {
            gtk_stack_page_set_name(stack_page_ptr, newValue)
        }
    }

    /// Returns the current value of the `GtkStackPage:needs`-attention property.
    @inlinable var needsAttention: Bool {
        /// Returns the current value of the `GtkStackPage:needs`-attention property.
        get {
            let rv = ((gtk_stack_page_get_needs_attention(stack_page_ptr)) != 0)
            return rv
        }
        /// Sets the new value of the `GtkStackPage:needs`-attention property.
        /// See also `gtk_stack_page_get_needs_attention()`
        nonmutating set {
            gtk_stack_page_set_needs_attention(stack_page_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    @inlinable var title: String! {
        /// Returns the current value of the `GtkStackPage:title` property.
        get {
            let rv = gtk_stack_page_get_title(stack_page_ptr).map({ String(cString: $0) })
            return rv
        }
        /// Sets the new value of the `GtkStackPage:title` property.
        /// See also `gtk_stack_page_get_title()`
        nonmutating set {
            gtk_stack_page_set_title(stack_page_ptr, newValue)
        }
    }

    /// Returns the current value of the `GtkStackPage:use`-underline property.
    @inlinable var useUnderline: Bool {
        /// Returns the current value of the `GtkStackPage:use`-underline property.
        get {
            let rv = ((gtk_stack_page_get_use_underline(stack_page_ptr)) != 0)
            return rv
        }
        /// Sets the new value of the `GtkStackPage:use`-underline property.
        /// See also `gtk_stack_page_get_use_underline()`
        nonmutating set {
            gtk_stack_page_set_use_underline(stack_page_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    @inlinable var visible: Bool {
        /// Returns whether `page` is visible in its `GtkStack`.
        /// This is independent from the `GtkWidget:visible` value of its
        /// `GtkWidget`.
        get {
            let rv = ((gtk_stack_page_get_visible(stack_page_ptr)) != 0)
            return rv
        }
        /// Sets the new value of the `GtkStackPage:visible` property
        /// to `visible`.
        nonmutating set {
            gtk_stack_page_set_visible(stack_page_ptr, gboolean((newValue) ? 1 : 0))
        }
    }


}



// MARK: - StackSidebar Class

/// The `StackSidebarProtocol` protocol exposes the methods and properties of an underlying `GtkStackSidebar` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `StackSidebar`.
/// Alternatively, use `StackSidebarRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A GtkStackSidebar enables you to quickly and easily provide a
/// consistent "sidebar" object for your user interface.
/// 
/// In order to use a GtkStackSidebar, you simply use a GtkStack to
/// organize your UI flow, and add the sidebar to your sidebar area. You
/// can use `gtk_stack_sidebar_set_stack()` to connect the `GtkStackSidebar`
/// to the `GtkStack`.
/// 
/// # CSS nodes
/// 
/// GtkStackSidebar has a single CSS node with name stacksidebar and
/// style class .sidebar.
/// 
/// When circumstances require it, GtkStackSidebar adds the
/// .needs-attention style class to the widgets representing the stack
/// pages.
public protocol StackSidebarProtocol: WidgetProtocol {
        /// Untyped pointer to the underlying `GtkStackSidebar` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkStackSidebar` instance.
    var stack_sidebar_ptr: UnsafeMutablePointer<GtkStackSidebar>! { get }

}

/// The `StackSidebarRef` type acts as a lightweight Swift reference to an underlying `GtkStackSidebar` instance.
/// It exposes methods that can operate on this data type through `StackSidebarProtocol` conformance.
/// Use `StackSidebarRef` only as an `unowned` reference to an existing `GtkStackSidebar` instance.
///
/// A GtkStackSidebar enables you to quickly and easily provide a
/// consistent "sidebar" object for your user interface.
/// 
/// In order to use a GtkStackSidebar, you simply use a GtkStack to
/// organize your UI flow, and add the sidebar to your sidebar area. You
/// can use `gtk_stack_sidebar_set_stack()` to connect the `GtkStackSidebar`
/// to the `GtkStack`.
/// 
/// # CSS nodes
/// 
/// GtkStackSidebar has a single CSS node with name stacksidebar and
/// style class .sidebar.
/// 
/// When circumstances require it, GtkStackSidebar adds the
/// .needs-attention style class to the widgets representing the stack
/// pages.
public struct StackSidebarRef: StackSidebarProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkStackSidebar` instance.
    /// For type-safe access, use the generated, typed pointer `stack_sidebar_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension StackSidebarRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkStackSidebar>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkStackSidebar>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkStackSidebar>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkStackSidebar>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `StackSidebarProtocol`
    @inlinable init<T: StackSidebarProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: StackSidebarProtocol>(_ other: T) -> StackSidebarRef { StackSidebarRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSidebarProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSidebarProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSidebarProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSidebarProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSidebarProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new sidebar.
    @inlinable init() {
        let rv = gtk_stack_sidebar_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `StackSidebar` type acts as a reference-counted owner of an underlying `GtkStackSidebar` instance.
/// It provides the methods that can operate on this data type through `StackSidebarProtocol` conformance.
/// Use `StackSidebar` as a strong reference or owner of a `GtkStackSidebar` instance.
///
/// A GtkStackSidebar enables you to quickly and easily provide a
/// consistent "sidebar" object for your user interface.
/// 
/// In order to use a GtkStackSidebar, you simply use a GtkStack to
/// organize your UI flow, and add the sidebar to your sidebar area. You
/// can use `gtk_stack_sidebar_set_stack()` to connect the `GtkStackSidebar`
/// to the `GtkStack`.
/// 
/// # CSS nodes
/// 
/// GtkStackSidebar has a single CSS node with name stacksidebar and
/// style class .sidebar.
/// 
/// When circumstances require it, GtkStackSidebar adds the
/// .needs-attention style class to the widgets representing the stack
/// pages.
open class StackSidebar: Widget, StackSidebarProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StackSidebar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkStackSidebar>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StackSidebar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkStackSidebar>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StackSidebar` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StackSidebar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StackSidebar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkStackSidebar>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StackSidebar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkStackSidebar>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkStackSidebar`.
    /// i.e., ownership is transferred to the `StackSidebar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkStackSidebar>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `StackSidebarProtocol`
    /// Will retain `GtkStackSidebar`.
    /// - Parameter other: an instance of a related type that implements `StackSidebarProtocol`
    @inlinable public init<T: StackSidebarProtocol>(stackSidebar other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSidebarProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSidebarProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSidebarProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSidebarProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSidebarProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSidebarProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSidebarProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSidebarProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new sidebar.
    @inlinable public init() {
        let rv = gtk_stack_sidebar_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum StackSidebarPropertyName: String, PropertyNameProtocol {
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`. See `gtk_widget_set_cursor()` for details.
    case cursor = "cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case name = "name"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    case parent = "parent"
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget or `nil` if
    /// the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    case stack = "stack"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
}

public extension StackSidebarProtocol {
    /// Bind a `StackSidebarPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: StackSidebarPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a StackSidebar property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: StackSidebarPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a StackSidebar property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: StackSidebarPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

// MARK: StackSidebar has no signals// MARK: StackSidebar Class: StackSidebarProtocol extension (methods and fields)
public extension StackSidebarProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkStackSidebar` instance.
    @inlinable var stack_sidebar_ptr: UnsafeMutablePointer<GtkStackSidebar>! { return ptr?.assumingMemoryBound(to: GtkStackSidebar.self) }

    /// Retrieves the stack.
    /// See `gtk_stack_sidebar_set_stack()`.
    @inlinable func getStack() -> StackRef! {
        let rv = StackRef(gconstpointer: gconstpointer(gtk_stack_sidebar_get_stack(stack_sidebar_ptr)))
        return rv
    }

    /// Set the `GtkStack` associated with this `GtkStackSidebar`.
    /// 
    /// The sidebar widget will automatically update according to the order
    /// (packing) and items within the given `GtkStack`.
    @inlinable func set<StackT: StackProtocol>(stack: StackT) {
        gtk_stack_sidebar_set_stack(stack_sidebar_ptr, stack.stack_ptr)
    
    }
    @inlinable var stack: StackRef! {
        /// Retrieves the stack.
        /// See `gtk_stack_sidebar_set_stack()`.
        get {
            let rv = StackRef(gconstpointer: gconstpointer(gtk_stack_sidebar_get_stack(stack_sidebar_ptr)))
            return rv
        }
        /// Set the `GtkStack` associated with this `GtkStackSidebar`.
        /// 
        /// The sidebar widget will automatically update according to the order
        /// (packing) and items within the given `GtkStack`.
        nonmutating set {
            gtk_stack_sidebar_set_stack(stack_sidebar_ptr, UnsafeMutablePointer<GtkStack>(newValue?.stack_ptr))
        }
    }


}



// MARK: - StackSwitcher Class

/// The `StackSwitcherProtocol` protocol exposes the methods and properties of an underlying `GtkStackSwitcher` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `StackSwitcher`.
/// Alternatively, use `StackSwitcherRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// The GtkStackSwitcher widget acts as a controller for a
/// `GtkStack`; it shows a row of buttons to switch between
/// the various pages of the associated stack widget.
/// 
/// All the content for the buttons comes from the child properties
/// of the `GtkStack`; the button visibility in a `GtkStackSwitcher`
/// widget is controlled by the visibility of the child in the
/// `GtkStack`.
/// 
/// It is possible to associate multiple `GtkStackSwitcher` widgets
/// with the same `GtkStack` widget.
/// 
/// # CSS nodes
/// 
/// GtkStackSwitcher has a single CSS node named stackswitcher and
/// style class .stack-switcher.
/// 
/// When circumstances require it, GtkStackSwitcher adds the
/// .needs-attention style class to the widgets representing the
/// stack pages.
/// 
/// # Accessibility
/// 
/// GtkStackSwitcher uses the `GTK_ACCESSIBLE_ROLE_TAB_LIST` role
/// and uses the `GTK_ACCESSIBLE_ROLE_TAB` for its buttons.
public protocol StackSwitcherProtocol: WidgetProtocol {
        /// Untyped pointer to the underlying `GtkStackSwitcher` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkStackSwitcher` instance.
    var stack_switcher_ptr: UnsafeMutablePointer<GtkStackSwitcher>! { get }

}

/// The `StackSwitcherRef` type acts as a lightweight Swift reference to an underlying `GtkStackSwitcher` instance.
/// It exposes methods that can operate on this data type through `StackSwitcherProtocol` conformance.
/// Use `StackSwitcherRef` only as an `unowned` reference to an existing `GtkStackSwitcher` instance.
///
/// The GtkStackSwitcher widget acts as a controller for a
/// `GtkStack`; it shows a row of buttons to switch between
/// the various pages of the associated stack widget.
/// 
/// All the content for the buttons comes from the child properties
/// of the `GtkStack`; the button visibility in a `GtkStackSwitcher`
/// widget is controlled by the visibility of the child in the
/// `GtkStack`.
/// 
/// It is possible to associate multiple `GtkStackSwitcher` widgets
/// with the same `GtkStack` widget.
/// 
/// # CSS nodes
/// 
/// GtkStackSwitcher has a single CSS node named stackswitcher and
/// style class .stack-switcher.
/// 
/// When circumstances require it, GtkStackSwitcher adds the
/// .needs-attention style class to the widgets representing the
/// stack pages.
/// 
/// # Accessibility
/// 
/// GtkStackSwitcher uses the `GTK_ACCESSIBLE_ROLE_TAB_LIST` role
/// and uses the `GTK_ACCESSIBLE_ROLE_TAB` for its buttons.
public struct StackSwitcherRef: StackSwitcherProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkStackSwitcher` instance.
    /// For type-safe access, use the generated, typed pointer `stack_switcher_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension StackSwitcherRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkStackSwitcher>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkStackSwitcher>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkStackSwitcher>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkStackSwitcher>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `StackSwitcherProtocol`
    @inlinable init<T: StackSwitcherProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: StackSwitcherProtocol>(_ other: T) -> StackSwitcherRef { StackSwitcherRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSwitcherProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSwitcherProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSwitcherProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSwitcherProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSwitcherProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Create a new `GtkStackSwitcher`.
    @inlinable init() {
        let rv = gtk_stack_switcher_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `StackSwitcher` type acts as a reference-counted owner of an underlying `GtkStackSwitcher` instance.
/// It provides the methods that can operate on this data type through `StackSwitcherProtocol` conformance.
/// Use `StackSwitcher` as a strong reference or owner of a `GtkStackSwitcher` instance.
///
/// The GtkStackSwitcher widget acts as a controller for a
/// `GtkStack`; it shows a row of buttons to switch between
/// the various pages of the associated stack widget.
/// 
/// All the content for the buttons comes from the child properties
/// of the `GtkStack`; the button visibility in a `GtkStackSwitcher`
/// widget is controlled by the visibility of the child in the
/// `GtkStack`.
/// 
/// It is possible to associate multiple `GtkStackSwitcher` widgets
/// with the same `GtkStack` widget.
/// 
/// # CSS nodes
/// 
/// GtkStackSwitcher has a single CSS node named stackswitcher and
/// style class .stack-switcher.
/// 
/// When circumstances require it, GtkStackSwitcher adds the
/// .needs-attention style class to the widgets representing the
/// stack pages.
/// 
/// # Accessibility
/// 
/// GtkStackSwitcher uses the `GTK_ACCESSIBLE_ROLE_TAB_LIST` role
/// and uses the `GTK_ACCESSIBLE_ROLE_TAB` for its buttons.
open class StackSwitcher: Widget, StackSwitcherProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StackSwitcher` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkStackSwitcher>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StackSwitcher` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkStackSwitcher>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StackSwitcher` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StackSwitcher` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StackSwitcher` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkStackSwitcher>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StackSwitcher` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkStackSwitcher>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkStackSwitcher`.
    /// i.e., ownership is transferred to the `StackSwitcher` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkStackSwitcher>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `StackSwitcherProtocol`
    /// Will retain `GtkStackSwitcher`.
    /// - Parameter other: an instance of a related type that implements `StackSwitcherProtocol`
    @inlinable public init<T: StackSwitcherProtocol>(stackSwitcher other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSwitcherProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSwitcherProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSwitcherProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSwitcherProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSwitcherProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSwitcherProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSwitcherProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSwitcherProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Create a new `GtkStackSwitcher`.
    @inlinable public init() {
        let rv = gtk_stack_switcher_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum StackSwitcherPropertyName: String, PropertyNameProtocol {
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`. See `gtk_widget_set_cursor()` for details.
    case cursor = "cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case name = "name"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    case parent = "parent"
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget or `nil` if
    /// the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    case stack = "stack"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
}

public extension StackSwitcherProtocol {
    /// Bind a `StackSwitcherPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: StackSwitcherPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a StackSwitcher property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: StackSwitcherPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a StackSwitcher property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: StackSwitcherPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

// MARK: StackSwitcher has no signals// MARK: StackSwitcher Class: StackSwitcherProtocol extension (methods and fields)
public extension StackSwitcherProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkStackSwitcher` instance.
    @inlinable var stack_switcher_ptr: UnsafeMutablePointer<GtkStackSwitcher>! { return ptr?.assumingMemoryBound(to: GtkStackSwitcher.self) }

    /// Retrieves the stack.
    /// See `gtk_stack_switcher_set_stack()`.
    @inlinable func getStack() -> StackRef! {
        let rv = StackRef(gconstpointer: gconstpointer(gtk_stack_switcher_get_stack(stack_switcher_ptr)))
        return rv
    }

    /// Sets the stack to control.
    @inlinable func set(stack: StackRef? = nil) {
        gtk_stack_switcher_set_stack(stack_switcher_ptr, stack?.stack_ptr)
    
    }
    /// Sets the stack to control.
    @inlinable func set<StackT: StackProtocol>(stack: StackT?) {
        gtk_stack_switcher_set_stack(stack_switcher_ptr, stack?.stack_ptr)
    
    }
    @inlinable var stack: StackRef! {
        /// Retrieves the stack.
        /// See `gtk_stack_switcher_set_stack()`.
        get {
            let rv = StackRef(gconstpointer: gconstpointer(gtk_stack_switcher_get_stack(stack_switcher_ptr)))
            return rv
        }
        /// Sets the stack to control.
        nonmutating set {
            gtk_stack_switcher_set_stack(stack_switcher_ptr, UnsafeMutablePointer<GtkStack>(newValue?.stack_ptr))
        }
    }


}



// MARK: - Statusbar Class

/// The `StatusbarProtocol` protocol exposes the methods and properties of an underlying `GtkStatusbar` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `Statusbar`.
/// Alternatively, use `StatusbarRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A `GtkStatusbar` is usually placed along the bottom of an application's
/// main `GtkWindow`. It may provide a regular commentary of the application's
/// status (as is usually the case in a web browser, for example), or may be
/// used to simply output a message when the status changes, (when an upload
/// is complete in an FTP client, for example).
/// 
/// Status bars in GTK+ maintain a stack of messages. The message at
/// the top of the each bar’s stack is the one that will currently be displayed.
/// 
/// Any messages added to a statusbar’s stack must specify a
/// context id that is used to uniquely identify
/// the source of a message. This context id can be generated by
/// `gtk_statusbar_get_context_id()`, given a message and the statusbar that
/// it will be added to. Note that messages are stored in a stack, and when
/// choosing which message to display, the stack structure is adhered to,
/// regardless of the context identifier of a message.
/// 
/// One could say that a statusbar maintains one stack of messages for
/// display purposes, but allows multiple message producers to maintain
/// sub-stacks of the messages they produced (via context ids).
/// 
/// Status bars are created using `gtk_statusbar_new()`.
/// 
/// Messages are added to the bar’s stack with `gtk_statusbar_push()`.
/// 
/// The message at the top of the stack can be removed using
/// `gtk_statusbar_pop()`. A message can be removed from anywhere in the
/// stack if its message id was recorded at the time it was added. This
/// is done using `gtk_statusbar_remove()`.
/// 
/// # CSS node
/// 
/// GtkStatusbar has a single CSS node with name statusbar.
public protocol StatusbarProtocol: WidgetProtocol {
        /// Untyped pointer to the underlying `GtkStatusbar` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkStatusbar` instance.
    var statusbar_ptr: UnsafeMutablePointer<GtkStatusbar>! { get }

}

/// The `StatusbarRef` type acts as a lightweight Swift reference to an underlying `GtkStatusbar` instance.
/// It exposes methods that can operate on this data type through `StatusbarProtocol` conformance.
/// Use `StatusbarRef` only as an `unowned` reference to an existing `GtkStatusbar` instance.
///
/// A `GtkStatusbar` is usually placed along the bottom of an application's
/// main `GtkWindow`. It may provide a regular commentary of the application's
/// status (as is usually the case in a web browser, for example), or may be
/// used to simply output a message when the status changes, (when an upload
/// is complete in an FTP client, for example).
/// 
/// Status bars in GTK+ maintain a stack of messages. The message at
/// the top of the each bar’s stack is the one that will currently be displayed.
/// 
/// Any messages added to a statusbar’s stack must specify a
/// context id that is used to uniquely identify
/// the source of a message. This context id can be generated by
/// `gtk_statusbar_get_context_id()`, given a message and the statusbar that
/// it will be added to. Note that messages are stored in a stack, and when
/// choosing which message to display, the stack structure is adhered to,
/// regardless of the context identifier of a message.
/// 
/// One could say that a statusbar maintains one stack of messages for
/// display purposes, but allows multiple message producers to maintain
/// sub-stacks of the messages they produced (via context ids).
/// 
/// Status bars are created using `gtk_statusbar_new()`.
/// 
/// Messages are added to the bar’s stack with `gtk_statusbar_push()`.
/// 
/// The message at the top of the stack can be removed using
/// `gtk_statusbar_pop()`. A message can be removed from anywhere in the
/// stack if its message id was recorded at the time it was added. This
/// is done using `gtk_statusbar_remove()`.
/// 
/// # CSS node
/// 
/// GtkStatusbar has a single CSS node with name statusbar.
public struct StatusbarRef: StatusbarProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkStatusbar` instance.
    /// For type-safe access, use the generated, typed pointer `statusbar_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension StatusbarRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkStatusbar>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkStatusbar>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkStatusbar>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkStatusbar>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `StatusbarProtocol`
    @inlinable init<T: StatusbarProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: StatusbarProtocol>(_ other: T) -> StatusbarRef { StatusbarRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StatusbarProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StatusbarProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StatusbarProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StatusbarProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StatusbarProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkStatusbar` ready for messages.
    @inlinable init() {
        let rv = gtk_statusbar_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `Statusbar` type acts as a reference-counted owner of an underlying `GtkStatusbar` instance.
/// It provides the methods that can operate on this data type through `StatusbarProtocol` conformance.
/// Use `Statusbar` as a strong reference or owner of a `GtkStatusbar` instance.
///
/// A `GtkStatusbar` is usually placed along the bottom of an application's
/// main `GtkWindow`. It may provide a regular commentary of the application's
/// status (as is usually the case in a web browser, for example), or may be
/// used to simply output a message when the status changes, (when an upload
/// is complete in an FTP client, for example).
/// 
/// Status bars in GTK+ maintain a stack of messages. The message at
/// the top of the each bar’s stack is the one that will currently be displayed.
/// 
/// Any messages added to a statusbar’s stack must specify a
/// context id that is used to uniquely identify
/// the source of a message. This context id can be generated by
/// `gtk_statusbar_get_context_id()`, given a message and the statusbar that
/// it will be added to. Note that messages are stored in a stack, and when
/// choosing which message to display, the stack structure is adhered to,
/// regardless of the context identifier of a message.
/// 
/// One could say that a statusbar maintains one stack of messages for
/// display purposes, but allows multiple message producers to maintain
/// sub-stacks of the messages they produced (via context ids).
/// 
/// Status bars are created using `gtk_statusbar_new()`.
/// 
/// Messages are added to the bar’s stack with `gtk_statusbar_push()`.
/// 
/// The message at the top of the stack can be removed using
/// `gtk_statusbar_pop()`. A message can be removed from anywhere in the
/// stack if its message id was recorded at the time it was added. This
/// is done using `gtk_statusbar_remove()`.
/// 
/// # CSS node
/// 
/// GtkStatusbar has a single CSS node with name statusbar.
open class Statusbar: Widget, StatusbarProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Statusbar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkStatusbar>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Statusbar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkStatusbar>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Statusbar` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Statusbar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Statusbar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkStatusbar>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Statusbar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkStatusbar>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkStatusbar`.
    /// i.e., ownership is transferred to the `Statusbar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkStatusbar>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `StatusbarProtocol`
    /// Will retain `GtkStatusbar`.
    /// - Parameter other: an instance of a related type that implements `StatusbarProtocol`
    @inlinable public init<T: StatusbarProtocol>(statusbar other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StatusbarProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StatusbarProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StatusbarProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StatusbarProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StatusbarProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StatusbarProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StatusbarProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StatusbarProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkStatusbar` ready for messages.
    @inlinable public init() {
        let rv = gtk_statusbar_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum StatusbarPropertyName: String, PropertyNameProtocol {
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`. See `gtk_widget_set_cursor()` for details.
    case cursor = "cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case name = "name"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    case parent = "parent"
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget or `nil` if
    /// the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
}

public extension StatusbarProtocol {
    /// Bind a `StatusbarPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: StatusbarPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a Statusbar property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: StatusbarPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a Statusbar property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: StatusbarPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

// MARK: Signals of Statusbar
public extension StatusbarProtocol {
    /// Is emitted whenever a new message is popped off a statusbar's stack.
    /// - Note: Representation of signal named `text-popped`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter contextId: the context id of the relevant message/statusbar
    /// - Parameter text: the message that was just popped
    @discardableResult
    func onTextPopped(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: StatusbarRef, _ contextId: UInt, _ text: String) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder3<StatusbarRef, UInt, String, Void>
        let cCallback: @convention(c) (gpointer, guint, UnsafeMutablePointer<gchar>?, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(StatusbarRef(raw: unownedSelf), UInt(arg1), arg2.map({ String(cString: $0) })!)
            return output
        }
        return signalConnectData(
            detailedSignal: "text-popped", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// Is emitted whenever a new message gets pushed onto a statusbar's stack.
    /// - Note: Representation of signal named `text-pushed`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter contextId: the context id of the relevant message/statusbar
    /// - Parameter text: the message that was pushed
    @discardableResult
    func onTextPushed(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: StatusbarRef, _ contextId: UInt, _ text: String) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder3<StatusbarRef, UInt, String, Void>
        let cCallback: @convention(c) (gpointer, guint, UnsafeMutablePointer<gchar>?, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(StatusbarRef(raw: unownedSelf), UInt(arg1), arg2.map({ String(cString: $0) })!)
            return output
        }
        return signalConnectData(
            detailedSignal: "text-pushed", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    
}

// MARK: Statusbar Class: StatusbarProtocol extension (methods and fields)
public extension StatusbarProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkStatusbar` instance.
    @inlinable var statusbar_ptr: UnsafeMutablePointer<GtkStatusbar>! { return ptr?.assumingMemoryBound(to: GtkStatusbar.self) }

    /// Returns a new context identifier, given a description
    /// of the actual context. Note that the description is
    /// not shown in the UI.
    @inlinable func getContextId(contextDescription: UnsafePointer<CChar>!) -> Int {
        let rv = Int(gtk_statusbar_get_context_id(statusbar_ptr, contextDescription))
        return rv
    }

    /// Removes the first message in the `GtkStatusbar`’s stack
    /// with the given context id.
    /// 
    /// Note that this may not change the displayed message, if
    /// the message at the top of the stack has a different
    /// context id.
    @inlinable func pop(contextId: Int) {
        gtk_statusbar_pop(statusbar_ptr, guint(contextId))
    
    }

    /// Pushes a new message onto a statusbar’s stack.
    @inlinable func push(contextId: Int, text: UnsafePointer<CChar>!) -> Int {
        let rv = Int(gtk_statusbar_push(statusbar_ptr, guint(contextId), text))
        return rv
    }

    /// Forces the removal of a message from a statusbar’s stack.
    /// The exact `context_id` and `message_id` must be specified.
    @inlinable func remove(contextId: Int, messageId: Int) {
        gtk_statusbar_remove(statusbar_ptr, guint(contextId), guint(messageId))
    
    }

    /// Forces the removal of all messages from a statusbar's
    /// stack with the exact `context_id`.
    @inlinable func removeAll(contextId: Int) {
        gtk_statusbar_remove_all(statusbar_ptr, guint(contextId))
    
    }


}



// MARK: - StringFilter Class

/// The `StringFilterProtocol` protocol exposes the methods and properties of an underlying `GtkStringFilter` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `StringFilter`.
/// Alternatively, use `StringFilterRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// GtkStringFilter determines whether to include items by looking
/// at strings and comparing them to a fixed search term. The strings
/// are obtained from the items by evaluating a `GtkExpression`.
/// 
/// GtkStringFilter has several different modes of comparison - it
/// can match the whole string, just a prefix, or any substring.
public protocol StringFilterProtocol: FilterProtocol {
        /// Untyped pointer to the underlying `GtkStringFilter` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkStringFilter` instance.
    var string_filter_ptr: UnsafeMutablePointer<GtkStringFilter>! { get }

}

/// The `StringFilterRef` type acts as a lightweight Swift reference to an underlying `GtkStringFilter` instance.
/// It exposes methods that can operate on this data type through `StringFilterProtocol` conformance.
/// Use `StringFilterRef` only as an `unowned` reference to an existing `GtkStringFilter` instance.
///
/// GtkStringFilter determines whether to include items by looking
/// at strings and comparing them to a fixed search term. The strings
/// are obtained from the items by evaluating a `GtkExpression`.
/// 
/// GtkStringFilter has several different modes of comparison - it
/// can match the whole string, just a prefix, or any substring.
public struct StringFilterRef: StringFilterProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkStringFilter` instance.
    /// For type-safe access, use the generated, typed pointer `string_filter_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension StringFilterRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkStringFilter>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkStringFilter>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkStringFilter>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkStringFilter>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `StringFilterProtocol`
    @inlinable init<T: StringFilterProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: StringFilterProtocol>(_ other: T) -> StringFilterRef { StringFilterRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringFilterProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringFilterProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringFilterProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringFilterProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringFilterProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new string filter.
    /// 
    /// You will want to set up the filter by providing a string to search for
    /// and by providing a property to look up on the item.
    @inlinable init<ExpressionT: ExpressionProtocol>( expression: ExpressionT?) {
        let rv = gtk_string_filter_new(expression?.expression_ptr)
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `StringFilter` type acts as a reference-counted owner of an underlying `GtkStringFilter` instance.
/// It provides the methods that can operate on this data type through `StringFilterProtocol` conformance.
/// Use `StringFilter` as a strong reference or owner of a `GtkStringFilter` instance.
///
/// GtkStringFilter determines whether to include items by looking
/// at strings and comparing them to a fixed search term. The strings
/// are obtained from the items by evaluating a `GtkExpression`.
/// 
/// GtkStringFilter has several different modes of comparison - it
/// can match the whole string, just a prefix, or any substring.
open class StringFilter: Filter, StringFilterProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringFilter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkStringFilter>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringFilter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkStringFilter>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringFilter` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringFilter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringFilter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkStringFilter>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringFilter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkStringFilter>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkStringFilter`.
    /// i.e., ownership is transferred to the `StringFilter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkStringFilter>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `StringFilterProtocol`
    /// Will retain `GtkStringFilter`.
    /// - Parameter other: an instance of a related type that implements `StringFilterProtocol`
    @inlinable public init<T: StringFilterProtocol>(stringFilter other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringFilterProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringFilterProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringFilterProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringFilterProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringFilterProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringFilterProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringFilterProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringFilterProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new string filter.
    /// 
    /// You will want to set up the filter by providing a string to search for
    /// and by providing a property to look up on the item.
    @inlinable public init<ExpressionT: ExpressionProtocol>( expression: ExpressionT?) {
        let rv = gtk_string_filter_new(expression?.expression_ptr)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum StringFilterPropertyName: String, PropertyNameProtocol {
    /// The expression to evaluate on item to get a string to compare with
    case expression = "expression"
    /// If matching is case sensitive
    case ignoreCase = "ignore-case"
    /// If exact matches are necessary or if substrings are allowed
    case matchMode = "match-mode"
    /// The search term
    case search = "search"
}

public extension StringFilterProtocol {
    /// Bind a `StringFilterPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: StringFilterPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a StringFilter property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: StringFilterPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a StringFilter property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: StringFilterPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

// MARK: StringFilter has no signals// MARK: StringFilter Class: StringFilterProtocol extension (methods and fields)
public extension StringFilterProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkStringFilter` instance.
    @inlinable var string_filter_ptr: UnsafeMutablePointer<GtkStringFilter>! { return ptr?.assumingMemoryBound(to: GtkStringFilter.self) }

    /// Gets the expression that the string filter uses to
    /// obtain strings from items.
    @inlinable func getExpression() -> ExpressionRef! {
        let rv = ExpressionRef(gconstpointer: gconstpointer(gtk_string_filter_get_expression(string_filter_ptr)))
        return rv
    }

    /// Returns whether the filter ignores case differences.
    @inlinable func getIgnoreCase() -> Bool {
        let rv = ((gtk_string_filter_get_ignore_case(string_filter_ptr)) != 0)
        return rv
    }

    /// Returns the match mode that the filter is using.
    @inlinable func getMatchMode() -> GtkStringFilterMatchMode {
        let rv = gtk_string_filter_get_match_mode(string_filter_ptr)
        return rv
    }

    /// Gets the search string set via `gtk_string_filter_set_search()`.
    @inlinable func getSearch() -> String! {
        let rv = gtk_string_filter_get_search(string_filter_ptr).map({ String(cString: $0) })
        return rv
    }

    /// Sets the expression that the string filter uses to
    /// obtain strings from items. The expression must have
    /// a value type of `G_TYPE_STRING`.
    @inlinable func set<ExpressionT: ExpressionProtocol>(expression: ExpressionT) {
        gtk_string_filter_set_expression(string_filter_ptr, expression.expression_ptr)
    
    }

    /// Sets whether the filter ignores case differences.
    @inlinable func set(ignoreCase: Bool) {
        gtk_string_filter_set_ignore_case(string_filter_ptr, gboolean((ignoreCase) ? 1 : 0))
    
    }

    /// Sets the match mode for the filter.
    @inlinable func setMatch(mode: GtkStringFilterMatchMode) {
        gtk_string_filter_set_match_mode(string_filter_ptr, mode)
    
    }

    /// Sets the string to search for.
    @inlinable func set(search: UnsafePointer<CChar>? = nil) {
        gtk_string_filter_set_search(string_filter_ptr, search)
    
    }
    /// The expression to evaluate on item to get a string to compare with
    @inlinable var expression: ExpressionRef! {
        /// Gets the expression that the string filter uses to
        /// obtain strings from items.
        get {
            let rv = ExpressionRef(gconstpointer: gconstpointer(gtk_string_filter_get_expression(string_filter_ptr)))
            return rv
        }
        /// Sets the expression that the string filter uses to
        /// obtain strings from items. The expression must have
        /// a value type of `G_TYPE_STRING`.
        nonmutating set {
            gtk_string_filter_set_expression(string_filter_ptr, UnsafeMutablePointer<GtkExpression>(newValue?.expression_ptr))
        }
    }

    /// Returns whether the filter ignores case differences.
    @inlinable var ignoreCase: Bool {
        /// Returns whether the filter ignores case differences.
        get {
            let rv = ((gtk_string_filter_get_ignore_case(string_filter_ptr)) != 0)
            return rv
        }
        /// Sets whether the filter ignores case differences.
        nonmutating set {
            gtk_string_filter_set_ignore_case(string_filter_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns the match mode that the filter is using.
    @inlinable var matchMode: GtkStringFilterMatchMode {
        /// Returns the match mode that the filter is using.
        get {
            let rv = gtk_string_filter_get_match_mode(string_filter_ptr)
            return rv
        }
        /// Sets the match mode for the filter.
        nonmutating set {
            gtk_string_filter_set_match_mode(string_filter_ptr, newValue)
        }
    }

    /// The search term
    @inlinable var search: String! {
        /// Gets the search string set via `gtk_string_filter_set_search()`.
        get {
            let rv = gtk_string_filter_get_search(string_filter_ptr).map({ String(cString: $0) })
            return rv
        }
        /// Sets the string to search for.
        nonmutating set {
            gtk_string_filter_set_search(string_filter_ptr, newValue)
        }
    }


}



// MARK: - StringList Class

/// The `StringListProtocol` protocol exposes the methods and properties of an underlying `GtkStringList` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `StringList`.
/// Alternatively, use `StringListRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkStringList` is a list model that wraps an array of strings.
/// 
/// The objects in the model have a "string" property.
/// 
/// GtkStringList is well-suited for any place where you would
/// typically use a `char*[]`, but need a list model.
/// 
/// # GtkStringList as GtkBuildable
/// 
/// The GtkStringList implementation of the GtkBuildable interface
/// supports adding items directly using the <items> element and
/// specifying <item> elements for each item. Each <item> element
/// supports the regular translation attributes “translatable”,
/// “context” and “comments”.
/// 
/// Here is a UI definition fragment specifying a GtkStringList
/// ```
/// <object class="GtkStringList">
///   <items>
///     <item translatable="yes">Factory</item>
///     <item translatable="yes">Home</item>
///     <item translatable="yes">Subway</item>
///   </items>
/// </object>
/// ```
/// 
public protocol StringListProtocol: GLibObject.ObjectProtocol, GIO.ListModelProtocol, BuildableProtocol {
        /// Untyped pointer to the underlying `GtkStringList` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkStringList` instance.
    var string_list_ptr: UnsafeMutablePointer<GtkStringList>! { get }

}

/// The `StringListRef` type acts as a lightweight Swift reference to an underlying `GtkStringList` instance.
/// It exposes methods that can operate on this data type through `StringListProtocol` conformance.
/// Use `StringListRef` only as an `unowned` reference to an existing `GtkStringList` instance.
///
/// `GtkStringList` is a list model that wraps an array of strings.
/// 
/// The objects in the model have a "string" property.
/// 
/// GtkStringList is well-suited for any place where you would
/// typically use a `char*[]`, but need a list model.
/// 
/// # GtkStringList as GtkBuildable
/// 
/// The GtkStringList implementation of the GtkBuildable interface
/// supports adding items directly using the <items> element and
/// specifying <item> elements for each item. Each <item> element
/// supports the regular translation attributes “translatable”,
/// “context” and “comments”.
/// 
/// Here is a UI definition fragment specifying a GtkStringList
/// ```
/// <object class="GtkStringList">
///   <items>
///     <item translatable="yes">Factory</item>
///     <item translatable="yes">Home</item>
///     <item translatable="yes">Subway</item>
///   </items>
/// </object>
/// ```
/// 
public struct StringListRef: StringListProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkStringList` instance.
    /// For type-safe access, use the generated, typed pointer `string_list_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension StringListRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkStringList>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkStringList>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkStringList>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkStringList>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `StringListProtocol`
    @inlinable init<T: StringListProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: StringListProtocol>(_ other: T) -> StringListRef { StringListRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringListProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringListProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringListProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringListProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringListProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkStringList` with the given `strings`.
    @inlinable init( strings: UnsafePointer<UnsafePointer<CChar>?>! = nil) {
        let rv = gtk_string_list_new(strings)
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `StringList` type acts as a reference-counted owner of an underlying `GtkStringList` instance.
/// It provides the methods that can operate on this data type through `StringListProtocol` conformance.
/// Use `StringList` as a strong reference or owner of a `GtkStringList` instance.
///
/// `GtkStringList` is a list model that wraps an array of strings.
/// 
/// The objects in the model have a "string" property.
/// 
/// GtkStringList is well-suited for any place where you would
/// typically use a `char*[]`, but need a list model.
/// 
/// # GtkStringList as GtkBuildable
/// 
/// The GtkStringList implementation of the GtkBuildable interface
/// supports adding items directly using the <items> element and
/// specifying <item> elements for each item. Each <item> element
/// supports the regular translation attributes “translatable”,
/// “context” and “comments”.
/// 
/// Here is a UI definition fragment specifying a GtkStringList
/// ```
/// <object class="GtkStringList">
///   <items>
///     <item translatable="yes">Factory</item>
///     <item translatable="yes">Home</item>
///     <item translatable="yes">Subway</item>
///   </items>
/// </object>
/// ```
/// 
open class StringList: GLibObject.Object, StringListProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringList` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkStringList>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringList` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkStringList>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringList` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringList` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringList` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkStringList>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringList` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkStringList>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkStringList`.
    /// i.e., ownership is transferred to the `StringList` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkStringList>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `StringListProtocol`
    /// Will retain `GtkStringList`.
    /// - Parameter other: an instance of a related type that implements `StringListProtocol`
    @inlinable public init<T: StringListProtocol>(stringList other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringListProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringListProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringListProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringListProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringListProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringListProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringListProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringListProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkStringList` with the given `strings`.
    @inlinable public init( strings: UnsafePointer<UnsafePointer<CChar>?>! = nil) {
        let rv = gtk_string_list_new(strings)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

// MARK: no StringList properties

// MARK: StringList has no signals// MARK: StringList Class: StringListProtocol extension (methods and fields)
public extension StringListProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkStringList` instance.
    @inlinable var string_list_ptr: UnsafeMutablePointer<GtkStringList>! { return ptr?.assumingMemoryBound(to: GtkStringList.self) }

    /// Appends `string` to `self`.
    /// 
    /// The `string` will be copied. See `gtk_string_list_take()`
    /// for a way to avoid that.
    @inlinable func append(string: UnsafePointer<CChar>!) {
        gtk_string_list_append(string_list_ptr, string)
    
    }

    /// Gets the string that is at `position` in `self`. If `self`
    /// does not contain `position` items, `nil` is returned.
    /// 
    /// This function returns the const char *. To get the
    /// object wrapping it, use `g_list_model_get_item()`.
    @inlinable func getString(position: Int) -> String! {
        let rv = gtk_string_list_get_string(string_list_ptr, guint(position)).map({ String(cString: $0) })
        return rv
    }

    /// Removes the string at `position` from `self`. `position` must
    /// be smaller than the current length of the list.
    @inlinable func remove(position: Int) {
        gtk_string_list_remove(string_list_ptr, guint(position))
    
    }

    /// Changes `self` by removing `n_removals` strings and adding `additions`
    /// to it.
    /// 
    /// This function is more efficient than `gtk_string_list_append()` and
    /// `gtk_string_list_remove()`, because it only emits
    /// `GListModel::items`-changed once for the change.
    /// 
    /// This function copies the strings in `additions`.
    /// 
    /// The parameters `position` and `n_removals` must be correct (ie:
    /// `position` + `n_removals` must be less than or equal to the length
    /// of the list at the time this function is called).
    @inlinable func splice(position: Int, nRemovals: Int, additions: UnsafePointer<UnsafePointer<CChar>?>! = nil) {
        gtk_string_list_splice(string_list_ptr, guint(position), guint(nRemovals), additions)
    
    }

    /// Adds `string` to self at the end, and takes
    /// ownership of it.
    /// 
    /// This variant of `gtk_string_list_append()` is
    /// convenient for formatting strings:
    /// 
    /// ```
    /// gtk_string_list_take (self, g_strdup_print ("%d dollars", lots));
    /// ```
    /// 
    @inlinable func take(string: UnsafeMutablePointer<CChar>!) {
        gtk_string_list_take(string_list_ptr, string)
    
    }


}



// MARK: - StringObject Class

/// The `StringObjectProtocol` protocol exposes the methods and properties of an underlying `GtkStringObject` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `StringObject`.
/// Alternatively, use `StringObjectRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///

public protocol StringObjectProtocol: GLibObject.ObjectProtocol {
        /// Untyped pointer to the underlying `GtkStringObject` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkStringObject` instance.
    var string_object_ptr: UnsafeMutablePointer<GtkStringObject>! { get }

}

/// The `StringObjectRef` type acts as a lightweight Swift reference to an underlying `GtkStringObject` instance.
/// It exposes methods that can operate on this data type through `StringObjectProtocol` conformance.
/// Use `StringObjectRef` only as an `unowned` reference to an existing `GtkStringObject` instance.
///

public struct StringObjectRef: StringObjectProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkStringObject` instance.
    /// For type-safe access, use the generated, typed pointer `string_object_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension StringObjectRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkStringObject>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkStringObject>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkStringObject>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkStringObject>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `StringObjectProtocol`
    @inlinable init<T: StringObjectProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: StringObjectProtocol>(_ other: T) -> StringObjectRef { StringObjectRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringObjectProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringObjectProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringObjectProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringObjectProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringObjectProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Wraps a string in an object for use with `GListModel`
    @inlinable init( string: UnsafePointer<CChar>!) {
        let rv = gtk_string_object_new(string)
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `StringObject` type acts as a reference-counted owner of an underlying `GtkStringObject` instance.
/// It provides the methods that can operate on this data type through `StringObjectProtocol` conformance.
/// Use `StringObject` as a strong reference or owner of a `GtkStringObject` instance.
///

open class StringObject: GLibObject.Object, StringObjectProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringObject` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkStringObject>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringObject` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkStringObject>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringObject` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringObject` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringObject` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkStringObject>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringObject` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkStringObject>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkStringObject`.
    /// i.e., ownership is transferred to the `StringObject` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkStringObject>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `StringObjectProtocol`
    /// Will retain `GtkStringObject`.
    /// - Parameter other: an instance of a related type that implements `StringObjectProtocol`
    @inlinable public init<T: StringObjectProtocol>(stringObject other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringObjectProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringObjectProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringObjectProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringObjectProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringObjectProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringObjectProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringObjectProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringObjectProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Wraps a string in an object for use with `GListModel`
    @inlinable public init( string: UnsafePointer<CChar>!) {
        let rv = gtk_string_object_new(string)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum StringObjectPropertyName: String, PropertyNameProtocol {
    case string = "string"
}

public extension StringObjectProtocol {
    /// Bind a `StringObjectPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: StringObjectPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a StringObject property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: StringObjectPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a StringObject property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: StringObjectPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

// MARK: StringObject has no signals// MARK: StringObject Class: StringObjectProtocol extension (methods and fields)
public extension StringObjectProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkStringObject` instance.
    @inlinable var string_object_ptr: UnsafeMutablePointer<GtkStringObject>! { return ptr?.assumingMemoryBound(to: GtkStringObject.self) }

    /// Returns the string contained in a `GtkStringObject`.
    @inlinable func getString() -> String! {
        let rv = gtk_string_object_get_string(string_object_ptr).map({ String(cString: $0) })
        return rv
    }
    @inlinable var string: String! {
        /// Returns the string contained in a `GtkStringObject`.
        get {
            let rv = gtk_string_object_get_string(string_object_ptr).map({ String(cString: $0) })
            return rv
        }
    }


}



// MARK: - StringSorter Class

/// The `StringSorterProtocol` protocol exposes the methods and properties of an underlying `GtkStringSorter` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `StringSorter`.
/// Alternatively, use `StringSorterRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// GtkStringSorter is a `GtkSorter` that compares strings. It does the
/// comparison in a linguistically correct way using the current locale by
/// normalizing Unicode strings and possibly case-folding them before
/// performing the comparison.
/// 
/// To obtain the strings to compare, this sorter evaluates a `GtkExpression`.
public protocol StringSorterProtocol: SorterProtocol {
        /// Untyped pointer to the underlying `GtkStringSorter` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkStringSorter` instance.
    var string_sorter_ptr: UnsafeMutablePointer<GtkStringSorter>! { get }

}

/// The `StringSorterRef` type acts as a lightweight Swift reference to an underlying `GtkStringSorter` instance.
/// It exposes methods that can operate on this data type through `StringSorterProtocol` conformance.
/// Use `StringSorterRef` only as an `unowned` reference to an existing `GtkStringSorter` instance.
///
/// GtkStringSorter is a `GtkSorter` that compares strings. It does the
/// comparison in a linguistically correct way using the current locale by
/// normalizing Unicode strings and possibly case-folding them before
/// performing the comparison.
/// 
/// To obtain the strings to compare, this sorter evaluates a `GtkExpression`.
public struct StringSorterRef: StringSorterProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkStringSorter` instance.
    /// For type-safe access, use the generated, typed pointer `string_sorter_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension StringSorterRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkStringSorter>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkStringSorter>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkStringSorter>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkStringSorter>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `StringSorterProtocol`
    @inlinable init<T: StringSorterProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: StringSorterProtocol>(_ other: T) -> StringSorterRef { StringSorterRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringSorterProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringSorterProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringSorterProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringSorterProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringSorterProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new string sorter that compares items using the given
    /// `expression`.
    /// 
    /// Unless an expression is set on it, this sorter will always
    /// compare items as invalid.
    @inlinable init<ExpressionT: ExpressionProtocol>( expression: ExpressionT?) {
        let rv = gtk_string_sorter_new(expression?.expression_ptr)
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `StringSorter` type acts as a reference-counted owner of an underlying `GtkStringSorter` instance.
/// It provides the methods that can operate on this data type through `StringSorterProtocol` conformance.
/// Use `StringSorter` as a strong reference or owner of a `GtkStringSorter` instance.
///
/// GtkStringSorter is a `GtkSorter` that compares strings. It does the
/// comparison in a linguistically correct way using the current locale by
/// normalizing Unicode strings and possibly case-folding them before
/// performing the comparison.
/// 
/// To obtain the strings to compare, this sorter evaluates a `GtkExpression`.
open class StringSorter: Sorter, StringSorterProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringSorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkStringSorter>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringSorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkStringSorter>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringSorter` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringSorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringSorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkStringSorter>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringSorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkStringSorter>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkStringSorter`.
    /// i.e., ownership is transferred to the `StringSorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkStringSorter>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `StringSorterProtocol`
    /// Will retain `GtkStringSorter`.
    /// - Parameter other: an instance of a related type that implements `StringSorterProtocol`
    @inlinable public init<T: StringSorterProtocol>(stringSorter other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringSorterProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringSorterProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringSorterProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringSorterProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringSorterProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringSorterProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringSorterProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringSorterProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new string sorter that compares items using the given
    /// `expression`.
    /// 
    /// Unless an expression is set on it, this sorter will always
    /// compare items as invalid.
    @inlinable public init<ExpressionT: ExpressionProtocol>( expression: ExpressionT?) {
        let rv = gtk_string_sorter_new(expression?.expression_ptr)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum StringSorterPropertyName: String, PropertyNameProtocol {
    /// The expression to evaluate on item to get a string to compare with
    case expression = "expression"
    /// If matching is case sensitive
    case ignoreCase = "ignore-case"
}

public extension StringSorterProtocol {
    /// Bind a `StringSorterPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: StringSorterPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a StringSorter property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: StringSorterPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a StringSorter property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: StringSorterPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

// MARK: StringSorter has no signals// MARK: StringSorter Class: StringSorterProtocol extension (methods and fields)
public extension StringSorterProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkStringSorter` instance.
    @inlinable var string_sorter_ptr: UnsafeMutablePointer<GtkStringSorter>! { return ptr?.assumingMemoryBound(to: GtkStringSorter.self) }

    /// Gets the expression that is evaluated to obtain strings from items.
    @inlinable func getExpression() -> ExpressionRef! {
        let rv = ExpressionRef(gconstpointer: gconstpointer(gtk_string_sorter_get_expression(string_sorter_ptr)))
        return rv
    }

    /// Gets whether the sorter ignores case differences.
    @inlinable func getIgnoreCase() -> Bool {
        let rv = ((gtk_string_sorter_get_ignore_case(string_sorter_ptr)) != 0)
        return rv
    }

    /// Sets the expression that is evaluated to obtain strings from items.
    /// 
    /// The expression must have the type G_TYPE_STRING.
    @inlinable func set(expression: ExpressionRef? = nil) {
        gtk_string_sorter_set_expression(string_sorter_ptr, expression?.expression_ptr)
    
    }
    /// Sets the expression that is evaluated to obtain strings from items.
    /// 
    /// The expression must have the type G_TYPE_STRING.
    @inlinable func set<ExpressionT: ExpressionProtocol>(expression: ExpressionT?) {
        gtk_string_sorter_set_expression(string_sorter_ptr, expression?.expression_ptr)
    
    }

    /// Sets whether the sorter will ignore case differences.
    @inlinable func set(ignoreCase: Bool) {
        gtk_string_sorter_set_ignore_case(string_sorter_ptr, gboolean((ignoreCase) ? 1 : 0))
    
    }
    /// The expression to evaluate on item to get a string to compare with
    @inlinable var expression: ExpressionRef! {
        /// Gets the expression that is evaluated to obtain strings from items.
        get {
            let rv = ExpressionRef(gconstpointer: gconstpointer(gtk_string_sorter_get_expression(string_sorter_ptr)))
            return rv
        }
        /// Sets the expression that is evaluated to obtain strings from items.
        /// 
        /// The expression must have the type G_TYPE_STRING.
        nonmutating set {
            gtk_string_sorter_set_expression(string_sorter_ptr, UnsafeMutablePointer<GtkExpression>(newValue?.expression_ptr))
        }
    }

    /// Gets whether the sorter ignores case differences.
    @inlinable var ignoreCase: Bool {
        /// Gets whether the sorter ignores case differences.
        get {
            let rv = ((gtk_string_sorter_get_ignore_case(string_sorter_ptr)) != 0)
            return rv
        }
        /// Sets whether the sorter will ignore case differences.
        nonmutating set {
            gtk_string_sorter_set_ignore_case(string_sorter_ptr, gboolean((newValue) ? 1 : 0))
        }
    }


}



// MARK: - StyleContext Class

/// The `StyleContextProtocol` protocol exposes the methods and properties of an underlying `GtkStyleContext` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `StyleContext`.
/// Alternatively, use `StyleContextRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkStyleContext` is an object that stores styling information affecting
/// a widget.
/// 
/// In order to construct the final style information, `GtkStyleContext`
/// queries information from all attached `GtkStyleProviders`. Style providers
/// can be either attached explicitly to the context through
/// `gtk_style_context_add_provider()`, or to the display through
/// `gtk_style_context_add_provider_for_display()`. The resulting style is a
/// combination of all providers’ information in priority order.
/// 
/// For GTK widgets, any `GtkStyleContext` returned by
/// `gtk_widget_get_style_context()` will already have a `GdkDisplay` and
/// RTL/LTR information set. The style context will also be updated
/// automatically if any of these settings change on the widget.
/// 
/// # Style Classes # <a name="gtkstylecontext-classes"></a>
/// 
/// Widgets can add style classes to their context, which can be used to associate
/// different styles by class. The documentation for individual widgets lists
/// which style classes it uses itself, and which style classes may be added by
/// applications to affect their appearance.
/// 
/// GTK defines macros for a number of style classes.
/// 
/// # Custom styling in UI libraries and applications
/// 
/// If you are developing a library with custom `GtkWidgets` that
/// render differently than standard components, you may need to add a
/// `GtkStyleProvider` yourself with the `GTK_STYLE_PROVIDER_PRIORITY_FALLBACK`
/// priority, either a `GtkCssProvider` or a custom object implementing the
/// `GtkStyleProvider` interface. This way themes may still attempt
/// to style your UI elements in a different way if needed so.
/// 
/// If you are using custom styling on an applications, you probably want then
/// to make your style information prevail to the theme’s, so you must use
/// a `GtkStyleProvider` with the `GTK_STYLE_PROVIDER_PRIORITY_APPLICATION`
/// priority, keep in mind that the user settings in
/// `XDG_CONFIG_HOME/gtk-4.0/gtk.css` will
/// still take precedence over your changes, as it uses the
/// `GTK_STYLE_PROVIDER_PRIORITY_USER` priority.
public protocol StyleContextProtocol: GLibObject.ObjectProtocol {
        /// Untyped pointer to the underlying `GtkStyleContext` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkStyleContext` instance.
    var style_context_ptr: UnsafeMutablePointer<GtkStyleContext>! { get }

}

/// The `StyleContextRef` type acts as a lightweight Swift reference to an underlying `GtkStyleContext` instance.
/// It exposes methods that can operate on this data type through `StyleContextProtocol` conformance.
/// Use `StyleContextRef` only as an `unowned` reference to an existing `GtkStyleContext` instance.
///
/// `GtkStyleContext` is an object that stores styling information affecting
/// a widget.
/// 
/// In order to construct the final style information, `GtkStyleContext`
/// queries information from all attached `GtkStyleProviders`. Style providers
/// can be either attached explicitly to the context through
/// `gtk_style_context_add_provider()`, or to the display through
/// `gtk_style_context_add_provider_for_display()`. The resulting style is a
/// combination of all providers’ information in priority order.
/// 
/// For GTK widgets, any `GtkStyleContext` returned by
/// `gtk_widget_get_style_context()` will already have a `GdkDisplay` and
/// RTL/LTR information set. The style context will also be updated
/// automatically if any of these settings change on the widget.
/// 
/// # Style Classes # <a name="gtkstylecontext-classes"></a>
/// 
/// Widgets can add style classes to their context, which can be used to associate
/// different styles by class. The documentation for individual widgets lists
/// which style classes it uses itself, and which style classes may be added by
/// applications to affect their appearance.
/// 
/// GTK defines macros for a number of style classes.
/// 
/// # Custom styling in UI libraries and applications
/// 
/// If you are developing a library with custom `GtkWidgets` that
/// render differently than standard components, you may need to add a
/// `GtkStyleProvider` yourself with the `GTK_STYLE_PROVIDER_PRIORITY_FALLBACK`
/// priority, either a `GtkCssProvider` or a custom object implementing the
/// `GtkStyleProvider` interface. This way themes may still attempt
/// to style your UI elements in a different way if needed so.
/// 
/// If you are using custom styling on an applications, you probably want then
/// to make your style information prevail to the theme’s, so you must use
/// a `GtkStyleProvider` with the `GTK_STYLE_PROVIDER_PRIORITY_APPLICATION`
/// priority, keep in mind that the user settings in
/// `XDG_CONFIG_HOME/gtk-4.0/gtk.css` will
/// still take precedence over your changes, as it uses the
/// `GTK_STYLE_PROVIDER_PRIORITY_USER` priority.
public struct StyleContextRef: StyleContextProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkStyleContext` instance.
    /// For type-safe access, use the generated, typed pointer `style_context_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension StyleContextRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkStyleContext>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkStyleContext>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkStyleContext>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkStyleContext>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `StyleContextProtocol`
    @inlinable init<T: StyleContextProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: StyleContextProtocol>(_ other: T) -> StyleContextRef { StyleContextRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StyleContextProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StyleContextProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StyleContextProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StyleContextProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StyleContextProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `StyleContext` type acts as a reference-counted owner of an underlying `GtkStyleContext` instance.
/// It provides the methods that can operate on this data type through `StyleContextProtocol` conformance.
/// Use `StyleContext` as a strong reference or owner of a `GtkStyleContext` instance.
///
/// `GtkStyleContext` is an object that stores styling information affecting
/// a widget.
/// 
/// In order to construct the final style information, `GtkStyleContext`
/// queries information from all attached `GtkStyleProviders`. Style providers
/// can be either attached explicitly to the context through
/// `gtk_style_context_add_provider()`, or to the display through
/// `gtk_style_context_add_provider_for_display()`. The resulting style is a
/// combination of all providers’ information in priority order.
/// 
/// For GTK widgets, any `GtkStyleContext` returned by
/// `gtk_widget_get_style_context()` will already have a `GdkDisplay` and
/// RTL/LTR information set. The style context will also be updated
/// automatically if any of these settings change on the widget.
/// 
/// # Style Classes # <a name="gtkstylecontext-classes"></a>
/// 
/// Widgets can add style classes to their context, which can be used to associate
/// different styles by class. The documentation for individual widgets lists
/// which style classes it uses itself, and which style classes may be added by
/// applications to affect their appearance.
/// 
/// GTK defines macros for a number of style classes.
/// 
/// # Custom styling in UI libraries and applications
/// 
/// If you are developing a library with custom `GtkWidgets` that
/// render differently than standard components, you may need to add a
/// `GtkStyleProvider` yourself with the `GTK_STYLE_PROVIDER_PRIORITY_FALLBACK`
/// priority, either a `GtkCssProvider` or a custom object implementing the
/// `GtkStyleProvider` interface. This way themes may still attempt
/// to style your UI elements in a different way if needed so.
/// 
/// If you are using custom styling on an applications, you probably want then
/// to make your style information prevail to the theme’s, so you must use
/// a `GtkStyleProvider` with the `GTK_STYLE_PROVIDER_PRIORITY_APPLICATION`
/// priority, keep in mind that the user settings in
/// `XDG_CONFIG_HOME/gtk-4.0/gtk.css` will
/// still take precedence over your changes, as it uses the
/// `GTK_STYLE_PROVIDER_PRIORITY_USER` priority.
open class StyleContext: GLibObject.Object, StyleContextProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StyleContext` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkStyleContext>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StyleContext` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkStyleContext>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StyleContext` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StyleContext` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StyleContext` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkStyleContext>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StyleContext` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkStyleContext>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkStyleContext`.
    /// i.e., ownership is transferred to the `StyleContext` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkStyleContext>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `StyleContextProtocol`
    /// Will retain `GtkStyleContext`.
    /// - Parameter other: an instance of a related type that implements `StyleContextProtocol`
    @inlinable public init<T: StyleContextProtocol>(styleContext other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StyleContextProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StyleContextProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StyleContextProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StyleContextProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StyleContextProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StyleContextProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StyleContextProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StyleContextProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum StyleContextPropertyName: String, PropertyNameProtocol {
    case display = "display"
}

public extension StyleContextProtocol {
    /// Bind a `StyleContextPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: StyleContextPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a StyleContext property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: StyleContextPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a StyleContext property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: StyleContextPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

// MARK: StyleContext has no signals// MARK: StyleContext Class: StyleContextProtocol extension (methods and fields)
public extension StyleContextProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkStyleContext` instance.
    @inlinable var style_context_ptr: UnsafeMutablePointer<GtkStyleContext>! { return ptr?.assumingMemoryBound(to: GtkStyleContext.self) }

    /// Adds a style class to `context`, so later uses of the
    /// style context will make use of this new class for styling.
    /// 
    /// In the CSS file format, a `GtkEntry` defining a “search”
    /// class, would be matched by:
    /// 
    /// (CSS Language Example):
    /// ```CSS
    /// entry.search { ... }
    /// ```
    /// 
    /// While any widget defining a “search” class would be
    /// matched by:
    /// (CSS Language Example):
    /// ```CSS
    /// .search { ... }
    /// ```
    /// 
    @inlinable func addClass(className: UnsafePointer<CChar>!) {
        gtk_style_context_add_class(style_context_ptr, className)
    
    }

    /// Adds a style provider to `context`, to be used in style construction.
    /// Note that a style provider added by this function only affects
    /// the style of the widget to which `context` belongs. If you want
    /// to affect the style of all widgets, use
    /// `gtk_style_context_add_provider_for_display()`.
    /// 
    /// Note: If both priorities are the same, a `GtkStyleProvider`
    /// added through this function takes precedence over another added
    /// through `gtk_style_context_add_provider_for_display()`.
    @inlinable func add<StyleProviderT: StyleProviderProtocol>(provider: StyleProviderT, priority: Int) {
        gtk_style_context_add_provider(style_context_ptr, provider.style_provider_ptr, guint(priority))
    
    }

    /// Gets the border for a given state as a `GtkBorder`.
    @inlinable func get<BorderT: BorderProtocol>(border: BorderT) {
        gtk_style_context_get_border(style_context_ptr, border.border_ptr)
    
    }

    /// Gets the foreground color for a given state.
    @inlinable func get<RGBAT: Gdk.RGBAProtocol>(color: RGBAT) {
        gtk_style_context_get_color(style_context_ptr, color.rgba_ptr)
    
    }

    /// Returns the `GdkDisplay` to which `context` is attached.
    @inlinable func getDisplay() -> Gdk.DisplayRef! {
        let rv = Gdk.DisplayRef(gtk_style_context_get_display(style_context_ptr))
        return rv
    }

    /// Gets the margin for a given state as a `GtkBorder`.
    @inlinable func get<BorderT: BorderProtocol>(margin: BorderT) {
        gtk_style_context_get_margin(style_context_ptr, margin.border_ptr)
    
    }

    /// Gets the padding for a given state as a `GtkBorder`.
    @inlinable func get<BorderT: BorderProtocol>(padding: BorderT) {
        gtk_style_context_get_padding(style_context_ptr, padding.border_ptr)
    
    }

    /// Returns the scale used for assets.
    @inlinable func getScale() -> Int {
        let rv = Int(gtk_style_context_get_scale(style_context_ptr))
        return rv
    }

    /// Returns the state used for style matching.
    /// 
    /// This method should only be used to retrieve the `GtkStateFlags`
    /// to pass to `GtkStyleContext` methods, like `gtk_style_context_get_padding()`.
    /// If you need to retrieve the current state of a `GtkWidget`, use
    /// `gtk_widget_get_state_flags()`.
    @inlinable func getState() -> StateFlags {
        let rv = StateFlags(gtk_style_context_get_state(style_context_ptr))
        return rv
    }

    /// Returns `true` if `context` currently has defined the
    /// given class name.
    @inlinable func hasClass(className: UnsafePointer<CChar>!) -> Bool {
        let rv = ((gtk_style_context_has_class(style_context_ptr, className)) != 0)
        return rv
    }

    /// Looks up and resolves a color name in the `context` color map.
    @inlinable func lookupColor<RGBAT: Gdk.RGBAProtocol>(colorName: UnsafePointer<CChar>!, color: RGBAT) -> Bool {
        let rv = ((gtk_style_context_lookup_color(style_context_ptr, colorName, color.rgba_ptr)) != 0)
        return rv
    }

    /// Removes `class_name` from `context`.
    @inlinable func removeClass(className: UnsafePointer<CChar>!) {
        gtk_style_context_remove_class(style_context_ptr, className)
    
    }

    /// Removes `provider` from the style providers list in `context`.
    @inlinable func remove<StyleProviderT: StyleProviderProtocol>(provider: StyleProviderT) {
        gtk_style_context_remove_provider(style_context_ptr, provider.style_provider_ptr)
    
    }

    /// Restores `context` state to a previous stage.
    /// See `gtk_style_context_save()`.
    @inlinable func restore() {
        gtk_style_context_restore(style_context_ptr)
    
    }

    /// Saves the `context` state, so temporary modifications done through
    /// `gtk_style_context_add_class()`, `gtk_style_context_remove_class()`,
    /// `gtk_style_context_set_state()`, etc. can quickly be reverted
    /// in one go through `gtk_style_context_restore()`.
    /// 
    /// The matching call to `gtk_style_context_restore()` must be done
    /// before GTK returns to the main loop.
    @inlinable func save() {
        gtk_style_context_save(style_context_ptr)
    
    }

    /// Attaches `context` to the given display.
    /// 
    /// The display is used to add style information from “global” style
    /// providers, such as the display's `GtkSettings` instance.
    /// 
    /// If you are using a `GtkStyleContext` returned from
    /// `gtk_widget_get_style_context()`, you do not need to
    /// call this yourself.
    @inlinable func set<DisplayT: Gdk.DisplayProtocol>(display: DisplayT) {
        gtk_style_context_set_display(style_context_ptr, display.display_ptr)
    
    }

    /// Sets the scale to use when getting image assets for the style.
    @inlinable func set(scale: Int) {
        gtk_style_context_set_scale(style_context_ptr, gint(scale))
    
    }

    /// Sets the state to be used for style matching.
    @inlinable func setState(flags: StateFlags) {
        gtk_style_context_set_state(style_context_ptr, flags.value)
    
    }

    /// Converts the style context into a string representation.
    /// 
    /// The string representation always includes information about
    /// the name, state, id, visibility and style classes of the CSS
    /// node that is backing `context`. Depending on the flags, more
    /// information may be included.
    /// 
    /// This function is intended for testing and debugging of the
    /// CSS implementation in GTK. There are no guarantees about
    /// the format of the returned string, it may change.
    @inlinable func toString(flags: StyleContextPrintFlags) -> String! {
        let rv = gtk_style_context_to_string(style_context_ptr, flags.value).map({ String(cString: $0) })
        return rv
    }

    /// Renders an activity indicator (such as in `GtkSpinner`).
    /// The state `GTK_STATE_FLAG_CHECKED` determines whether there is
    /// activity going on.
    @inlinable func renderActivity<ContextT: Cairo.ContextProtocol>(cr: ContextT, x: CDouble, y: CDouble, width: CDouble, height: CDouble) {
        gtk_render_activity(style_context_ptr, cr._ptr, x, y, width, height)
    
    }

    /// Renders an arrow pointing to `angle`.
    /// 
    /// Typical arrow rendering at 0, 1⁄2 π;, π; and 3⁄2 π:
    /// 
    /// ![](arrows.png)
    @inlinable func renderArrow<ContextT: Cairo.ContextProtocol>(cr: ContextT, angle: CDouble, x: CDouble, y: CDouble, size: CDouble) {
        gtk_render_arrow(style_context_ptr, cr._ptr, angle, x, y, size)
    
    }

    /// Renders the background of an element.
    /// 
    /// Typical background rendering, showing the effect of
    /// `background-image`, `border-width` and `border-radius`:
    /// 
    /// ![](background.png)
    @inlinable func renderBackground<ContextT: Cairo.ContextProtocol>(cr: ContextT, x: CDouble, y: CDouble, width: CDouble, height: CDouble) {
        gtk_render_background(style_context_ptr, cr._ptr, x, y, width, height)
    
    }

    /// Renders a checkmark (as in a `GtkCheckButton`).
    /// 
    /// The `GTK_STATE_FLAG_CHECKED` state determines whether the check is
    /// on or off, and `GTK_STATE_FLAG_INCONSISTENT` determines whether it
    /// should be marked as undefined.
    /// 
    /// Typical checkmark rendering:
    /// 
    /// ![](checks.png)
    @inlinable func renderCheck<ContextT: Cairo.ContextProtocol>(cr: ContextT, x: CDouble, y: CDouble, width: CDouble, height: CDouble) {
        gtk_render_check(style_context_ptr, cr._ptr, x, y, width, height)
    
    }

    /// Renders an expander (as used in `GtkTreeView` and `GtkExpander`) in the area
    /// defined by `x`, `y`, `width`, `height`. The state `GTK_STATE_FLAG_CHECKED`
    /// determines whether the expander is collapsed or expanded.
    /// 
    /// Typical expander rendering:
    /// 
    /// ![](expanders.png)
    @inlinable func renderExpander<ContextT: Cairo.ContextProtocol>(cr: ContextT, x: CDouble, y: CDouble, width: CDouble, height: CDouble) {
        gtk_render_expander(style_context_ptr, cr._ptr, x, y, width, height)
    
    }

    /// Renders a focus indicator on the rectangle determined by `x`, `y`, `width`, `height`.
    /// 
    /// Typical focus rendering:
    /// 
    /// ![](focus.png)
    @inlinable func renderFocus<ContextT: Cairo.ContextProtocol>(cr: ContextT, x: CDouble, y: CDouble, width: CDouble, height: CDouble) {
        gtk_render_focus(style_context_ptr, cr._ptr, x, y, width, height)
    
    }

    /// Renders a frame around the rectangle defined by `x`, `y`, `width`, `height`.
    /// 
    /// Examples of frame rendering, showing the effect of `border-image`,
    /// `border-color`, `border-width`, `border-radius` and junctions:
    /// 
    /// ![](frames.png)
    @inlinable func renderFrame<ContextT: Cairo.ContextProtocol>(cr: ContextT, x: CDouble, y: CDouble, width: CDouble, height: CDouble) {
        gtk_render_frame(style_context_ptr, cr._ptr, x, y, width, height)
    
    }

    /// Renders a handle (as in `GtkPaned` and
    /// `GtkWindow`’s resize grip), in the rectangle
    /// determined by `x`, `y`, `width`, `height`.
    /// 
    /// Handles rendered for the paned and grip classes:
    /// 
    /// ![](handles.png)
    @inlinable func renderHandle<ContextT: Cairo.ContextProtocol>(cr: ContextT, x: CDouble, y: CDouble, width: CDouble, height: CDouble) {
        gtk_render_handle(style_context_ptr, cr._ptr, x, y, width, height)
    
    }

    /// Renders the icon in `texture` at the specified `x` and `y` coordinates.
    /// 
    /// This function will render the icon in `texture` at exactly its size,
    /// regardless of scaling factors, which may not be appropriate when
    /// drawing on displays with high pixel densities.
    @inlinable func renderIcon<ContextT: Cairo.ContextProtocol, TextureT: Gdk.TextureProtocol>(cr: ContextT, texture: TextureT, x: CDouble, y: CDouble) {
        gtk_render_icon(style_context_ptr, cr._ptr, texture.texture_ptr, x, y)
    
    }

    /// Renders `layout` on the coordinates `x`, `y`
    @inlinable func renderLayout<ContextT: Cairo.ContextProtocol, LayoutT: Pango.LayoutProtocol>(cr: ContextT, x: CDouble, y: CDouble, layout: LayoutT) {
        gtk_render_layout(style_context_ptr, cr._ptr, x, y, layout.layout_ptr)
    
    }

    /// Renders a line from (x0, y0) to (x1, y1).
    @inlinable func renderLine<ContextT: Cairo.ContextProtocol>(cr: ContextT, x0: CDouble, y0: CDouble, x1: CDouble, y1: CDouble) {
        gtk_render_line(style_context_ptr, cr._ptr, x0, y0, x1, y1)
    
    }

    /// Renders an option mark (as in a radio button), the `GTK_STATE_FLAG_CHECKED`
    /// state will determine whether the option is on or off, and
    /// `GTK_STATE_FLAG_INCONSISTENT` whether it should be marked as undefined.
    /// 
    /// Typical option mark rendering:
    /// 
    /// ![](options.png)
    @inlinable func renderOption<ContextT: Cairo.ContextProtocol>(cr: ContextT, x: CDouble, y: CDouble, width: CDouble, height: CDouble) {
        gtk_render_option(style_context_ptr, cr._ptr, x, y, width, height)
    
    }
    @inlinable var display: Gdk.DisplayRef! {
        /// Returns the `GdkDisplay` to which `context` is attached.
        get {
            let rv = Gdk.DisplayRef(gtk_style_context_get_display(style_context_ptr))
            return rv
        }
        /// Attaches `context` to the given display.
        /// 
        /// The display is used to add style information from “global” style
        /// providers, such as the display's `GtkSettings` instance.
        /// 
        /// If you are using a `GtkStyleContext` returned from
        /// `gtk_widget_get_style_context()`, you do not need to
        /// call this yourself.
        nonmutating set {
            gtk_style_context_set_display(style_context_ptr, UnsafeMutablePointer<GdkDisplay>(newValue?.display_ptr))
        }
    }

    /// Returns the scale used for assets.
    @inlinable var scale: Int {
        /// Returns the scale used for assets.
        get {
            let rv = Int(gtk_style_context_get_scale(style_context_ptr))
            return rv
        }
        /// Sets the scale to use when getting image assets for the style.
        nonmutating set {
            gtk_style_context_set_scale(style_context_ptr, gint(newValue))
        }
    }

    /// Returns the state used for style matching.
    /// 
    /// This method should only be used to retrieve the `GtkStateFlags`
    /// to pass to `GtkStyleContext` methods, like `gtk_style_context_get_padding()`.
    /// If you need to retrieve the current state of a `GtkWidget`, use
    /// `gtk_widget_get_state_flags()`.
    @inlinable var state: StateFlags {
        /// Returns the state used for style matching.
        /// 
        /// This method should only be used to retrieve the `GtkStateFlags`
        /// to pass to `GtkStyleContext` methods, like `gtk_style_context_get_padding()`.
        /// If you need to retrieve the current state of a `GtkWidget`, use
        /// `gtk_widget_get_state_flags()`.
        get {
            let rv = StateFlags(gtk_style_context_get_state(style_context_ptr))
            return rv
        }
        /// Sets the state to be used for style matching.
        nonmutating set {
            gtk_style_context_set_state(style_context_ptr, newValue.value)
        }
    }

    @inlinable var parentObject: GObject {
        get {
            let rv = style_context_ptr.pointee.parent_object
            return rv
        }
    }

}



// MARK: - Switch Class

/// The `SwitchProtocol` protocol exposes the methods and properties of an underlying `GtkSwitch` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `Switch`.
/// Alternatively, use `SwitchRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkSwitch` is a widget that has two states: on or off. The user can control
/// which state should be active by clicking the empty area, or by dragging the
/// handle.
/// 
/// GtkSwitch can also handle situations where the underlying state changes with
/// a delay. See `GtkSwitch::state`-set for details.
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// switch
/// ├── label
/// ├── label
/// ╰── slider
/// ```
/// 
/// GtkSwitch has four css nodes, the main node with the name switch and subnodes
/// for the slider and the on and off labels. Neither of them is using any style classes.
/// 
/// # Accessibility
/// 
/// GtkSwitch uses the `GTK_ACCESSIBLE_ROLE_SWITCH` role.
public protocol SwitchProtocol: WidgetProtocol, ActionableProtocol {
        /// Untyped pointer to the underlying `GtkSwitch` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkSwitch` instance.
    var switch_ptr: UnsafeMutablePointer<GtkSwitch>! { get }

}

/// The `SwitchRef` type acts as a lightweight Swift reference to an underlying `GtkSwitch` instance.
/// It exposes methods that can operate on this data type through `SwitchProtocol` conformance.
/// Use `SwitchRef` only as an `unowned` reference to an existing `GtkSwitch` instance.
///
/// `GtkSwitch` is a widget that has two states: on or off. The user can control
/// which state should be active by clicking the empty area, or by dragging the
/// handle.
/// 
/// GtkSwitch can also handle situations where the underlying state changes with
/// a delay. See `GtkSwitch::state`-set for details.
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// switch
/// ├── label
/// ├── label
/// ╰── slider
/// ```
/// 
/// GtkSwitch has four css nodes, the main node with the name switch and subnodes
/// for the slider and the on and off labels. Neither of them is using any style classes.
/// 
/// # Accessibility
/// 
/// GtkSwitch uses the `GTK_ACCESSIBLE_ROLE_SWITCH` role.
public struct SwitchRef: SwitchProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkSwitch` instance.
    /// For type-safe access, use the generated, typed pointer `switch_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension SwitchRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkSwitch>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkSwitch>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkSwitch>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkSwitch>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `SwitchProtocol`
    @inlinable init<T: SwitchProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: SwitchProtocol>(_ other: T) -> SwitchRef { SwitchRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SwitchProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SwitchProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SwitchProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SwitchProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SwitchProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkSwitch` widget.
    @inlinable init() {
        let rv = gtk_switch_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `Switch` type acts as a reference-counted owner of an underlying `GtkSwitch` instance.
/// It provides the methods that can operate on this data type through `SwitchProtocol` conformance.
/// Use `Switch` as a strong reference or owner of a `GtkSwitch` instance.
///
/// `GtkSwitch` is a widget that has two states: on or off. The user can control
/// which state should be active by clicking the empty area, or by dragging the
/// handle.
/// 
/// GtkSwitch can also handle situations where the underlying state changes with
/// a delay. See `GtkSwitch::state`-set for details.
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// switch
/// ├── label
/// ├── label
/// ╰── slider
/// ```
/// 
/// GtkSwitch has four css nodes, the main node with the name switch and subnodes
/// for the slider and the on and off labels. Neither of them is using any style classes.
/// 
/// # Accessibility
/// 
/// GtkSwitch uses the `GTK_ACCESSIBLE_ROLE_SWITCH` role.
open class Switch: Widget, SwitchProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Switch` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkSwitch>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Switch` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkSwitch>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Switch` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Switch` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Switch` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkSwitch>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Switch` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkSwitch>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkSwitch`.
    /// i.e., ownership is transferred to the `Switch` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkSwitch>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `SwitchProtocol`
    /// Will retain `GtkSwitch`.
    /// - Parameter other: an instance of a related type that implements `SwitchProtocol`
    @inlinable public init<T: SwitchProtocol>(switch other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SwitchProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SwitchProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SwitchProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SwitchProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SwitchProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SwitchProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SwitchProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SwitchProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkSwitch` widget.
    @inlinable public init() {
        let rv = gtk_switch_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum SwitchPropertyName: String, PropertyNameProtocol {
    /// Whether the `GtkSwitch` widget is in its on or off state.
    case active = "active"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`. See `gtk_widget_set_cursor()` for details.
    case cursor = "cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case name = "name"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    case parent = "parent"
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget or `nil` if
    /// the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    /// The backend state that is controlled by the switch.
    /// See `GtkSwitch::state`-set for details.
    case state = "state"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
}

public extension SwitchProtocol {
    /// Bind a `SwitchPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: SwitchPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a Switch property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: SwitchPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a Switch property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: SwitchPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

// MARK: Signals of Switch
public extension SwitchProtocol {
    /// The `activate` signal on GtkSwitch is an action signal and
    /// emitting it causes the switch to animate.
    /// Applications should never connect to this signal, but use the
    /// notify`active` signal.
    /// - Note: Representation of signal named `activate`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    @discardableResult
    func onActivate(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SwitchRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<SwitchRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SwitchRef(raw: unownedSelf))
            return output
        }
        return signalConnectData(
            detailedSignal: "activate", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The `state`-set signal on GtkSwitch is emitted to change the underlying
    /// state. It is emitted when the user changes the switch position. The
    /// default handler keeps the state in sync with the `GtkSwitch:active`
    /// property.
    /// 
    /// To implement delayed state change, applications can connect to this signal,
    /// initiate the change of the underlying state, and call `gtk_switch_set_state()`
    /// when the underlying state change is complete. The signal handler should
    /// return `true` to prevent the default handler from running.
    /// 
    /// Visually, the underlying state is represented by the trough color of
    /// the switch, while the `GtkSwitch:active` property is represented by the
    /// position of the switch.
    /// - Note: Representation of signal named `state-set`
    /// - Parameter flags: Flags
    /// - Parameter handler: `true` to stop the signal emission
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter state: the new state of the switch
    @discardableResult
    func onStateSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SwitchRef, _ state: Bool) -> Bool ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<SwitchRef, Bool, Bool>
        let cCallback: @convention(c) (gpointer, gboolean, gpointer) -> gboolean = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call(SwitchRef(raw: unownedSelf), ((arg1) != 0))
            return gboolean((output) ? 1 : 0)
        }
        return signalConnectData(
            detailedSignal: "state-set", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::active`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyActive(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SwitchRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<SwitchRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SwitchRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::active", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::state`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyState(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SwitchRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<SwitchRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SwitchRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::state", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
}

// MARK: Switch Class: SwitchProtocol extension (methods and fields)
public extension SwitchProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkSwitch` instance.
    @inlinable var switch_ptr: UnsafeMutablePointer<GtkSwitch>! { return ptr?.assumingMemoryBound(to: GtkSwitch.self) }

    /// Gets whether the `GtkSwitch` is in its “on” or “off” state.
    @inlinable func getActive() -> Bool {
        let rv = ((gtk_switch_get_active(switch_ptr)) != 0)
        return rv
    }

    /// Gets the underlying state of the `GtkSwitch`.
    @inlinable func getState() -> Bool {
        let rv = ((gtk_switch_get_state(switch_ptr)) != 0)
        return rv
    }

    /// Changes the state of `self` to the desired one.
    @inlinable func setActive(isActive: Bool) {
        gtk_switch_set_active(switch_ptr, gboolean((isActive) ? 1 : 0))
    
    }

    /// Sets the underlying state of the `GtkSwitch`.
    /// 
    /// Normally, this is the same as `GtkSwitch:active`, unless the switch
    /// is set up for delayed state changes. This function is typically
    /// called from a `GtkSwitch::state`-set signal handler.
    /// 
    /// See `GtkSwitch::state`-set for details.
    @inlinable func set(state: Bool) {
        gtk_switch_set_state(switch_ptr, gboolean((state) ? 1 : 0))
    
    }
    /// Whether the `GtkSwitch` widget is in its on or off state.
    @inlinable var active: Bool {
        /// Gets whether the `GtkSwitch` is in its “on” or “off” state.
        get {
            let rv = ((gtk_switch_get_active(switch_ptr)) != 0)
            return rv
        }
        /// Changes the state of `self` to the desired one.
        nonmutating set {
            gtk_switch_set_active(switch_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// The backend state that is controlled by the switch.
    /// See `GtkSwitch::state`-set for details.
    @inlinable var state: Bool {
        /// Gets the underlying state of the `GtkSwitch`.
        get {
            let rv = ((gtk_switch_get_state(switch_ptr)) != 0)
            return rv
        }
        /// Sets the underlying state of the `GtkSwitch`.
        /// 
        /// Normally, this is the same as `GtkSwitch:active`, unless the switch
        /// is set up for delayed state changes. This function is typically
        /// called from a `GtkSwitch::state`-set signal handler.
        /// 
        /// See `GtkSwitch::state`-set for details.
        nonmutating set {
            gtk_switch_set_state(switch_ptr, gboolean((newValue) ? 1 : 0))
        }
    }


}



// MARK: - Text Class

/// The `TextProtocol` protocol exposes the methods and properties of an underlying `GtkText` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `Text`.
/// Alternatively, use `TextRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// The `GtkText` widget is a single line text entry widget.
/// 
/// A fairly large set of key bindings are supported by default. If the
/// entered text is longer than the allocation of the widget, the widget
/// will scroll so that the cursor position is visible.
/// 
/// When using an entry for passwords and other sensitive information,
/// it can be put into “password mode” using `gtk_text_set_visibility()`.
/// In this mode, entered text is displayed using a “invisible” character.
/// By default, GTK picks the best invisible character that is available
/// in the current font, but it can be changed with `gtk_text_set_invisible_char()`.
/// 
/// If you are looking to add icons or progress display in an entry, look
/// at `GtkEntry`. There other alternatives for more specialized use cases,
/// such as `GtkSearchEntry`.
/// 
/// If you need multi-line editable text, look at `GtkTextView`.
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// text[.read-only]
/// ├── placeholder
/// ├── undershoot.left
/// ├── undershoot.right
/// ├── [selection]
/// ├── [block-cursor]
/// ╰── [window.popup]
/// ```
/// 
/// GtkText has a main node with the name text. Depending on the properties
/// of the widget, the .read-only style class may appear.
/// 
/// When the entry has a selection, it adds a subnode with the name selection.
/// 
/// When the entry is in overwrite mode, it adds a subnode with the name block-cursor
/// that determines how the block cursor is drawn.
/// 
/// The CSS node for a context menu is added as a subnode below text as well.
/// 
/// The undershoot nodes are used to draw the underflow indication when content
/// is scrolled out of view. These nodes get the .left and .right style classes
/// added depending on where the indication is drawn.
/// 
/// When touch is used and touch selection handles are shown, they are using
/// CSS nodes with name cursor-handle. They get the .top or .bottom style class
/// depending on where they are shown in relation to the selection. If there is
/// just a single handle for the text cursor, it gets the style class .insertion-cursor.
/// 
/// # Accessibility
/// 
/// GtkText uses the `GTK_ACCESSIBLE_ROLE_NONE` role, which causes it to be skipped
/// for accessibility. This is because GtkText is expected to be used as a delegate
/// for a `GtkEditable` implementation that will be represented to accessibility.
public protocol TextProtocol: WidgetProtocol, EditableProtocol {
        /// Untyped pointer to the underlying `GtkText` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkText` instance.
    var text_ptr: UnsafeMutablePointer<GtkText>! { get }

}

/// The `TextRef` type acts as a lightweight Swift reference to an underlying `GtkText` instance.
/// It exposes methods that can operate on this data type through `TextProtocol` conformance.
/// Use `TextRef` only as an `unowned` reference to an existing `GtkText` instance.
///
/// The `GtkText` widget is a single line text entry widget.
/// 
/// A fairly large set of key bindings are supported by default. If the
/// entered text is longer than the allocation of the widget, the widget
/// will scroll so that the cursor position is visible.
/// 
/// When using an entry for passwords and other sensitive information,
/// it can be put into “password mode” using `gtk_text_set_visibility()`.
/// In this mode, entered text is displayed using a “invisible” character.
/// By default, GTK picks the best invisible character that is available
/// in the current font, but it can be changed with `gtk_text_set_invisible_char()`.
/// 
/// If you are looking to add icons or progress display in an entry, look
/// at `GtkEntry`. There other alternatives for more specialized use cases,
/// such as `GtkSearchEntry`.
/// 
/// If you need multi-line editable text, look at `GtkTextView`.
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// text[.read-only]
/// ├── placeholder
/// ├── undershoot.left
/// ├── undershoot.right
/// ├── [selection]
/// ├── [block-cursor]
/// ╰── [window.popup]
/// ```
/// 
/// GtkText has a main node with the name text. Depending on the properties
/// of the widget, the .read-only style class may appear.
/// 
/// When the entry has a selection, it adds a subnode with the name selection.
/// 
/// When the entry is in overwrite mode, it adds a subnode with the name block-cursor
/// that determines how the block cursor is drawn.
/// 
/// The CSS node for a context menu is added as a subnode below text as well.
/// 
/// The undershoot nodes are used to draw the underflow indication when content
/// is scrolled out of view. These nodes get the .left and .right style classes
/// added depending on where the indication is drawn.
/// 
/// When touch is used and touch selection handles are shown, they are using
/// CSS nodes with name cursor-handle. They get the .top or .bottom style class
/// depending on where they are shown in relation to the selection. If there is
/// just a single handle for the text cursor, it gets the style class .insertion-cursor.
/// 
/// # Accessibility
/// 
/// GtkText uses the `GTK_ACCESSIBLE_ROLE_NONE` role, which causes it to be skipped
/// for accessibility. This is because GtkText is expected to be used as a delegate
/// for a `GtkEditable` implementation that will be represented to accessibility.
public struct TextRef: TextProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkText` instance.
    /// For type-safe access, use the generated, typed pointer `text_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TextRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkText>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkText>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkText>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkText>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TextProtocol`
    @inlinable init<T: TextProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: TextProtocol>(_ other: T) -> TextRef { TextRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new self.
    @inlinable init() {
        let rv = gtk_text_new()
        ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new self with the specified text buffer.
    @inlinable init<EntryBufferT: EntryBufferProtocol>(buffer: EntryBufferT) {
        let rv = gtk_text_new_with_buffer(buffer.entry_buffer_ptr)
        ptr = UnsafeMutableRawPointer(rv)
    }
    /// Creates a new self with the specified text buffer.
    @inlinable static func newWith<EntryBufferT: EntryBufferProtocol>(buffer: EntryBufferT) -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_text_new_with_buffer(buffer.entry_buffer_ptr))) else { return nil }
        return rv
    }
}

/// The `Text` type acts as a reference-counted owner of an underlying `GtkText` instance.
/// It provides the methods that can operate on this data type through `TextProtocol` conformance.
/// Use `Text` as a strong reference or owner of a `GtkText` instance.
///
/// The `GtkText` widget is a single line text entry widget.
/// 
/// A fairly large set of key bindings are supported by default. If the
/// entered text is longer than the allocation of the widget, the widget
/// will scroll so that the cursor position is visible.
/// 
/// When using an entry for passwords and other sensitive information,
/// it can be put into “password mode” using `gtk_text_set_visibility()`.
/// In this mode, entered text is displayed using a “invisible” character.
/// By default, GTK picks the best invisible character that is available
/// in the current font, but it can be changed with `gtk_text_set_invisible_char()`.
/// 
/// If you are looking to add icons or progress display in an entry, look
/// at `GtkEntry`. There other alternatives for more specialized use cases,
/// such as `GtkSearchEntry`.
/// 
/// If you need multi-line editable text, look at `GtkTextView`.
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// text[.read-only]
/// ├── placeholder
/// ├── undershoot.left
/// ├── undershoot.right
/// ├── [selection]
/// ├── [block-cursor]
/// ╰── [window.popup]
/// ```
/// 
/// GtkText has a main node with the name text. Depending on the properties
/// of the widget, the .read-only style class may appear.
/// 
/// When the entry has a selection, it adds a subnode with the name selection.
/// 
/// When the entry is in overwrite mode, it adds a subnode with the name block-cursor
/// that determines how the block cursor is drawn.
/// 
/// The CSS node for a context menu is added as a subnode below text as well.
/// 
/// The undershoot nodes are used to draw the underflow indication when content
/// is scrolled out of view. These nodes get the .left and .right style classes
/// added depending on where the indication is drawn.
/// 
/// When touch is used and touch selection handles are shown, they are using
/// CSS nodes with name cursor-handle. They get the .top or .bottom style class
/// depending on where they are shown in relation to the selection. If there is
/// just a single handle for the text cursor, it gets the style class .insertion-cursor.
/// 
/// # Accessibility
/// 
/// GtkText uses the `GTK_ACCESSIBLE_ROLE_NONE` role, which causes it to be skipped
/// for accessibility. This is because GtkText is expected to be used as a delegate
/// for a `GtkEditable` implementation that will be represented to accessibility.
open class Text: Widget, TextProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Text` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkText>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Text` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkText>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Text` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Text` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Text` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkText>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Text` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkText>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkText`.
    /// i.e., ownership is transferred to the `Text` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkText>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `TextProtocol`
    /// Will retain `GtkText`.
    /// - Parameter other: an instance of a related type that implements `TextProtocol`
    @inlinable public init<T: TextProtocol>(text other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new self.
    @inlinable public init() {
        let rv = gtk_text_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new self with the specified text buffer.
    @inlinable public init<EntryBufferT: EntryBufferProtocol>(buffer: EntryBufferT) {
        let rv = gtk_text_new_with_buffer(buffer.entry_buffer_ptr)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new self with the specified text buffer.
    @inlinable public static func newWith<EntryBufferT: EntryBufferProtocol>(buffer: EntryBufferT) -> Widget! {
        guard let rv = Widget(gconstpointer: gconstpointer(gtk_text_new_with_buffer(buffer.entry_buffer_ptr))) else { return nil }
        if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
        return rv
    }

}

public enum TextPropertyName: String, PropertyNameProtocol {
    case activatesDefault = "activates-default"
    /// A list of Pango attributes to apply to the text of the self.
    /// 
    /// This is mainly useful to change the size or weight of the text.
    /// 
    /// The `PangoAttribute`'s `start_index` and `end_index` must refer to the
    /// `GtkEntryBuffer` text, i.e. without the preedit string.
    case attributes = "attributes"
    case buffer = "buffer"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`. See `gtk_widget_set_cursor()` for details.
    case cursor = "cursor"
    case enableEmojiCompletion = "enable-emoji-completion"
    /// A menu model whose contents will be appended to
    /// the context menu.
    case extraMenu = "extra-menu"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    /// Which IM (input method) module should be used for this self.
    /// See `GtkIMContext`.
    /// 
    /// Setting this to a non-`nil` value overrides the
    /// system-wide IM module setting. See the GtkSettings
    /// `GtkSettings:gtk`-im-module property.
    case imModule = "im-module"
    /// Additional hints (beyond `GtkText:input`-purpose) that
    /// allow input methods to fine-tune their behaviour.
    case inputHints = "input-hints"
    /// The purpose of this text field.
    /// 
    /// This property can be used by on-screen keyboards and other input
    /// methods to adjust their behaviour.
    /// 
    /// Note that setting the purpose to `GTK_INPUT_PURPOSE_PASSWORD` or
    /// `GTK_INPUT_PURPOSE_PIN` is independent from setting
    /// `GtkText:visibility`.
    case inputPurpose = "input-purpose"
    case invisibleChar = "invisible-char"
    /// Whether the invisible char has been set for the `GtkText`.
    case invisibleCharSet = "invisible-char-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case maxLength = "max-length"
    case name = "name"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// If text is overwritten when typing in the `GtkText`.
    case overwriteMode = "overwrite-mode"
    case parent = "parent"
    /// The text that will be displayed in the `GtkText` when it is empty
    /// and unfocused.
    case placeholderText = "placeholder-text"
    case propagateTextWidth = "propagate-text-width"
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget or `nil` if
    /// the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case scrollOffset = "scroll-offset"
    case sensitive = "sensitive"
    /// A list of tabstops to apply to the text of the self.
    case tabs = "tabs"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// When `true`, pasted multi-line text is truncated to the first line.
    case truncateMultiline = "truncate-multiline"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visibility = "visibility"
    case visible = "visible"
    case widthRequest = "width-request"
}

public extension TextProtocol {
    /// Bind a `TextPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: TextPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a Text property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: TextPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a Text property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: TextPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

// MARK: Signals of Text
public extension TextProtocol {
    /// The `activate` signal is emitted when the user hits
    /// the Enter key.
    /// 
    /// The default bindings for this signal are all forms of the Enter key.
    /// - Note: Representation of signal named `activate`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    @discardableResult
    func onActivate(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<TextRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf))
            return output
        }
        return signalConnectData(
            detailedSignal: "activate", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The `backspace` signal is a
    /// [keybinding signal](#GtkSignalAction)
    /// which gets emitted when the user asks for it.
    /// 
    /// The default bindings for this signal are
    /// Backspace and Shift-Backspace.
    /// - Note: Representation of signal named `backspace`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    @discardableResult
    func onBackspace(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<TextRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf))
            return output
        }
        return signalConnectData(
            detailedSignal: "backspace", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The `copy`-clipboard signal is a
    /// [keybinding signal](#GtkSignalAction)
    /// which gets emitted to copy the selection to the clipboard.
    /// 
    /// The default bindings for this signal are
    /// Ctrl-c and Ctrl-Insert.
    /// - Note: Representation of signal named `copy-clipboard`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    @discardableResult
    func onCopyClipboard(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<TextRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf))
            return output
        }
        return signalConnectData(
            detailedSignal: "copy-clipboard", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The `cut`-clipboard signal is a
    /// [keybinding signal](#GtkSignalAction)
    /// which gets emitted to cut the selection to the clipboard.
    /// 
    /// The default bindings for this signal are
    /// Ctrl-x and Shift-Delete.
    /// - Note: Representation of signal named `cut-clipboard`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    @discardableResult
    func onCutClipboard(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<TextRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf))
            return output
        }
        return signalConnectData(
            detailedSignal: "cut-clipboard", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The `delete`-from-cursor signal is a
    /// [keybinding signal](#GtkSignalAction)
    /// which gets emitted when the user initiates a text deletion.
    /// 
    /// If the `type` is `GTK_DELETE_CHARS`, GTK deletes the selection
    /// if there is one, otherwise it deletes the requested number
    /// of characters.
    /// 
    /// The default bindings for this signal are
    /// Delete for deleting a character and Ctrl-Delete for
    /// deleting a word.
    /// - Note: Representation of signal named `delete-from-cursor`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter type: the granularity of the deletion, as a `GtkDeleteType`
    /// - Parameter count: the number of `type` units to delete
    @discardableResult
    func onDeleteFromCursor(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ type: DeleteType, _ count: Int) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder3<TextRef, DeleteType, Int, Void>
        let cCallback: @convention(c) (gpointer, UInt32, gint, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), DeleteType(arg1), Int(arg2))
            return output
        }
        return signalConnectData(
            detailedSignal: "delete-from-cursor", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The `insert`-at-cursor signal is a
    /// [keybinding signal](#GtkSignalAction)
    /// which gets emitted when the user initiates the insertion of a
    /// fixed string at the cursor.
    /// 
    /// This signal has no default bindings.
    /// - Note: Representation of signal named `insert-at-cursor`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter string: the string to insert
    @discardableResult
    func onInsertAtCursor(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ string: String) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextRef, String, Void>
        let cCallback: @convention(c) (gpointer, UnsafeMutablePointer<gchar>?, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), arg1.map({ String(cString: $0) })!)
            return output
        }
        return signalConnectData(
            detailedSignal: "insert-at-cursor", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The `insert`-emoji signal is a
    /// [keybinding signal](#GtkSignalAction)
    /// which gets emitted to present the Emoji chooser for the `self`.
    /// 
    /// The default bindings for this signal are Ctrl-. and Ctrl-;
    /// - Note: Representation of signal named `insert-emoji`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    @discardableResult
    func onInsertEmoji(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<TextRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf))
            return output
        }
        return signalConnectData(
            detailedSignal: "insert-emoji", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The `move`-cursor signal is a
    /// [keybinding signal](#GtkSignalAction)
    /// which gets emitted when the user initiates a cursor movement.
    /// If the cursor is not visible in `self`, this signal causes
    /// the viewport to be moved instead.
    /// 
    /// Applications should not connect to it, but may emit it with
    /// `g_signal_emit_by_name()` if they need to control the cursor
    /// programmatically.
    /// 
    /// The default bindings for this signal come in two variants,
    /// the variant with the Shift modifier extends the selection,
    /// the variant without the Shift modifier does not.
    /// There are too many key combinations to list them all here.
    /// - Arrow keys move by individual characters/lines
    /// - Ctrl-arrow key combinations move by words/paragraphs
    /// - Home/End keys move to the ends of the buffer
    /// - Note: Representation of signal named `move-cursor`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter step: the granularity of the move, as a `GtkMovementStep`
    /// - Parameter count: the number of `step` units to move
    /// - Parameter extend: `true` if the move should extend the selection
    @discardableResult
    func onMoveCursor(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ step: MovementStep, _ count: Int, _ extend: Bool) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder4<TextRef, MovementStep, Int, Bool, Void>
        let cCallback: @convention(c) (gpointer, UInt32, gint, gboolean, gpointer) -> Void = { unownedSelf, arg1, arg2, arg3, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), MovementStep(arg1), Int(arg2), ((arg3) != 0))
            return output
        }
        return signalConnectData(
            detailedSignal: "move-cursor", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The `paste`-clipboard signal is a
    /// [keybinding signal](#GtkSignalAction)
    /// which gets emitted to paste the contents of the clipboard
    /// into the text view.
    /// 
    /// The default bindings for this signal are
    /// Ctrl-v and Shift-Insert.
    /// - Note: Representation of signal named `paste-clipboard`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    @discardableResult
    func onPasteClipboard(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<TextRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf))
            return output
        }
        return signalConnectData(
            detailedSignal: "paste-clipboard", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// If an input method is used, the typed text will not immediately
    /// be committed to the buffer. So if you are interested in the text,
    /// connect to this signal.
    /// - Note: Representation of signal named `preedit-changed`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter preedit: the current preedit string
    @discardableResult
    func onPreeditChanged(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ preedit: String) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextRef, String, Void>
        let cCallback: @convention(c) (gpointer, UnsafeMutablePointer<gchar>?, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), arg1.map({ String(cString: $0) })!)
            return output
        }
        return signalConnectData(
            detailedSignal: "preedit-changed", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The `toggle`-overwrite signal is a
    /// [keybinding signal](#GtkSignalAction)
    /// which gets emitted to toggle the overwrite mode of the self.
    /// 
    /// The default bindings for this signal is Insert.
    /// - Note: Representation of signal named `toggle-overwrite`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    @discardableResult
    func onToggleOverwrite(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<TextRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf))
            return output
        }
        return signalConnectData(
            detailedSignal: "toggle-overwrite", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::activates-default`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyActivatesDefault(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::activates-default", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::attributes`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyAttributes(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::attributes", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::buffer`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyBuffer(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::buffer", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::enable-emoji-completion`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyEnableEmojiCompletion(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::enable-emoji-completion", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::extra-menu`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyExtraMenu(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::extra-menu", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::im-module`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyImModule(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::im-module", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::input-hints`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyInputHints(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::input-hints", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::input-purpose`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyInputPurpose(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::input-purpose", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::invisible-char`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyInvisibleChar(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::invisible-char", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::invisible-char-set`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyInvisibleCharSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::invisible-char-set", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::max-length`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyMaxLength(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::max-length", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::overwrite-mode`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyOverwriteMode(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::overwrite-mode", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::placeholder-text`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyPlaceholderText(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::placeholder-text", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::propagate-text-width`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyPropagateTextWidth(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::propagate-text-width", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::scroll-offset`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyScrollOffset(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::scroll-offset", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::tabs`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyTabs(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::tabs", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::truncate-multiline`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyTruncateMultiline(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::truncate-multiline", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: Representation of signal named `notify::visibility`
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    @discardableResult
    func onNotifyVisibility(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return signalConnectData(
            detailedSignal: "notify::visibility", 
            cHandler: unsafeBitCast(cCallback, to: GCallback.self), 
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(), 
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            connectFlags: flags
        )
    }
    
}

// MARK: Text Class: TextProtocol extension (methods and fields)
public extension TextProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkText` instance.
    @inlinable var text_ptr: UnsafeMutablePointer<GtkText>! { return ptr?.assumingMemoryBound(to: GtkText.self) }

    /// Retrieves the value set by `gtk_text_set_activates_default()`.
    @inlinable func getActivatesDefault() -> Bool {
        let rv = ((gtk_text_get_activates_default(text_ptr)) != 0)
        return rv
    }

    /// Gets the attribute list that was set on the self using
    /// `gtk_text_set_attributes()`, if any.
    @inlinable func getAttributes() -> Pango.AttrListRef! {
        let rv = Pango.AttrListRef(gtk_text_get_attributes(text_ptr))
        return rv
    }

    /// Get the `GtkEntryBuffer` object which holds the text for
    /// this self.
    @inlinable func getBuffer() -> EntryBufferRef! {
        let rv = EntryBufferRef(gconstpointer: gconstpointer(gtk_text_get_buffer(text_ptr)))
        return rv
    }

    /// Returns whether Emoji completion is enabled for this
    /// GtkText widget.
    @inlinable func getEnableEmojiCompletion() -> Bool {
        let rv = ((gtk_text_get_enable_emoji_completion(text_ptr)) != 0)
        return rv
    }

    /// Gets the menu model set with `gtk_text_set_extra_menu()`.
    @inlinable func getExtraMenu() -> GIO.MenuModelRef! {
        let rv = GIO.MenuModelRef(gtk_text_get_extra_menu(text_ptr))
        return rv
    }

    /// Gets the value of the `GtkText:input`-hints property.
    @inlinable func getInputHints() -> InputHints {
        let rv = InputHints(gtk_text_get_input_hints(text_ptr))
        return rv
    }

    /// Gets the value of the `GtkText:input`-purpose property.
    @inlinable func getInputPurpose() -> GtkInputPurpose {
        let rv = gtk_text_get_input_purpose(text_ptr)
        return rv
    }

    /// Retrieves the character displayed in place of the real characters
    /// for entries with visibility set to false. Note that GTK does not
    /// compute this value unless it needs it, so the value returned by
    /// this function is not very useful unless it has been explicitly
    /// set with `gtk_text_set_invisible_char()`
    @inlinable func getInvisibleChar() -> gunichar {
        let rv = gtk_text_get_invisible_char(text_ptr)
        return rv
    }

    /// Retrieves the maximum allowed length of the text in
    /// `self`. See `gtk_text_set_max_length()`.
    /// 
    /// This is equivalent to getting `self`'s `GtkEntryBuffer` and
    /// calling `gtk_entry_buffer_get_max_length()` on it.
    @inlinable func getMaxLength() -> Int {
        let rv = Int(gtk_text_get_max_length(text_ptr))
        return rv
    }

    /// Gets the value set by `gtk_text_set_overwrite_mode()`.
    @inlinable func getOverwriteMode() -> Bool {
        let rv = ((gtk_text_get_overwrite_mode(text_ptr)) != 0)
        return rv
    }

    /// Retrieves the text that will be displayed when `self` is empty and unfocused
    @inlinable func getPlaceholderText() -> String! {
        let rv = gtk_text_get_placeholder_text(text_ptr).map({ String(cString: $0) })
        return rv
    }

    /// Returns whether the `GtkText` will grow and shrink
    /// with the content.
    @inlinable func getPropagateTextWidth() -> Bool {
        let rv = ((gtk_text_get_propagate_text_width(text_ptr)) != 0)
        return rv
    }

    /// Gets the tabstops that were set on the self using `gtk_text_set_tabs()`, if
    /// any.
    @inlinable func getTabs() -> Pango.TabArrayRef! {
        let rv = Pango.TabArrayRef(gtk_text_get_tabs(text_ptr))
        return rv
    }

    /// Retrieves the current length of the text in
    /// `self`.
    /// 
    /// This is equivalent to getting `self`'s `GtkEntryBuffer` and
    /// calling `gtk_entry_buffer_get_length()` on it.
    @inlinable func getTextLength() -> guint16 {
        let rv = gtk_text_get_text_length(text_ptr)
        return rv
    }

    /// Returns whether the `GtkText` will truncate multi-line text
    /// that is pasted into the widget
    @inlinable func getTruncateMultiline() -> Bool {
        let rv = ((gtk_text_get_truncate_multiline(text_ptr)) != 0)
        return rv
    }

    /// Retrieves whether the text in `self` is visible.
    /// See `gtk_text_set_visibility()`.
    @inlinable func getVisibility() -> Bool {
        let rv = ((gtk_text_get_visibility(text_ptr)) != 0)
        return rv
    }

    /// Causes `self` to have keyboard focus.
    /// 
    /// It behaves like `gtk_widget_grab_focus()`,
    /// except that it doesn't select the contents of `self`.
    /// You only want to call this on some special entries
    /// which the user usually doesn't want to replace all text in,
    /// such as search-as-you-type entries.
    @inlinable func grabFocusWithoutSelecting() -> Bool {
        let rv = ((gtk_text_grab_focus_without_selecting(text_ptr)) != 0)
        return rv
    }

    /// If `activates` is `true`, pressing Enter in the `self` will activate the default
    /// widget for the window containing the self. This usually means that
    /// the dialog box containing the self will be closed, since the default
    /// widget is usually one of the dialog buttons.
    @inlinable func setActivatesDefault(activates: Bool) {
        gtk_text_set_activates_default(text_ptr, gboolean((activates) ? 1 : 0))
    
    }

    /// Sets a `PangoAttrList`; the attributes in the list are applied to the
    /// text.
    @inlinable func setAttributes(attrs: Pango.AttrListRef? = nil) {
        gtk_text_set_attributes(text_ptr, attrs?.attr_list_ptr)
    
    }
    /// Sets a `PangoAttrList`; the attributes in the list are applied to the
    /// text.
    @inlinable func setAttributes<AttrListT: Pango.AttrListProtocol>(attrs: AttrListT?) {
        gtk_text_set_attributes(text_ptr, attrs?.attr_list_ptr)
    
    }

    /// Set the `GtkEntryBuffer` object which holds the text for
    /// this widget.
    @inlinable func set<EntryBufferT: EntryBufferProtocol>(buffer: EntryBufferT) {
        gtk_text_set_buffer(text_ptr, buffer.entry_buffer_ptr)
    
    }

    /// Sets whether Emoji completion is enabled. If it is,
    /// typing ':', followed by a recognized keyword, will pop
    /// up a window with suggested Emojis matching the keyword.
    @inlinable func set(enableEmojiCompletion: Bool) {
        gtk_text_set_enable_emoji_completion(text_ptr, gboolean((enableEmojiCompletion) ? 1 : 0))
    
    }

    /// Sets a menu model to add when constructing
    /// the context menu for `self`.
    @inlinable func setExtraMenu(model: GIO.MenuModelRef? = nil) {
        gtk_text_set_extra_menu(text_ptr, model?.menu_model_ptr)
    
    }
    /// Sets a menu model to add when constructing
    /// the context menu for `self`.
    @inlinable func setExtraMenu<MenuModelT: GIO.MenuModelProtocol>(model: MenuModelT?) {
        gtk_text_set_extra_menu(text_ptr, model?.menu_model_ptr)
    
    }

    /// Sets the `GtkText:input`-hints property, which
    /// allows input methods to fine-tune their behaviour.
    @inlinable func setInput(hints: InputHints) {
        gtk_text_set_input_hints(text_ptr, hints.value)
    
    }

    /// Sets the `GtkText:input`-purpose property which
    /// can be used by on-screen keyboards and other input
    /// methods to adjust their behaviour.
    @inlinable func setInput(purpose: GtkInputPurpose) {
        gtk_text_set_input_purpose(text_ptr, purpose)
    
    }

    /// Sets the character to use in place of the actual text when
    /// `gtk_text_set_visibility()` has been called to set text visibility
    /// to `false`. i.e. this is the character used in “password mode” to
    /// show the user how many characters have been typed.
    /// 
    /// By default, GTK picks the best invisible char available in the
    /// current font. If you set the invisible char to 0, then the user
    /// will get no feedback at all; there will be no text on the screen
    /// as they type.
    @inlinable func setInvisibleChar(ch: gunichar) {
        gtk_text_set_invisible_char(text_ptr, ch)
    
    }

    /// Sets the maximum allowed length of the contents of the widget.
    /// 
    /// If the current contents are longer than the given length, then
    /// they will be truncated to fit.
    /// 
    /// This is equivalent to getting `self`'s `GtkEntryBuffer` and
    /// calling `gtk_entry_buffer_set_max_length()` on it.
    /// ]|
    @inlinable func setMax(length: Int) {
        gtk_text_set_max_length(text_ptr, gint(length))
    
    }

    /// Sets whether the text is overwritten when typing in the `GtkText`.
    @inlinable func setOverwriteMode(overwrite: Bool) {
        gtk_text_set_overwrite_mode(text_ptr, gboolean((overwrite) ? 1 : 0))
    
    }

    /// Sets text to be displayed in `self` when it is empty.
    /// 
    /// This can be used to give a visual hint of the expected
    /// contents of the self.
    @inlinable func setPlaceholder(text: UnsafePointer<CChar>? = nil) {
        gtk_text_set_placeholder_text(text_ptr, text)
    
    }

    /// Sets whether the GtkText should grow and shrink with the content.
    @inlinable func set(propagateTextWidth: Bool) {
        gtk_text_set_propagate_text_width(text_ptr, gboolean((propagateTextWidth) ? 1 : 0))
    
    }

    /// Sets a `PangoTabArray`; the tabstops in the array are applied to the self
    /// text.
    @inlinable func set(tabs: Pango.TabArrayRef? = nil) {
        gtk_text_set_tabs(text_ptr, tabs?.tab_array_ptr)
    
    }
    /// Sets a `PangoTabArray`; the tabstops in the array are applied to the self
    /// text.
    @inlinable func set<TabArrayT: Pango.TabArrayProtocol>(tabs: TabArrayT?) {
        gtk_text_set_tabs(text_ptr, tabs?.tab_array_ptr)
    
    }

    /// Sets whether the GtkText should truncate multi-line text
    /// that is pasted into the widget.
    @inlinable func set(truncateMultiline: Bool) {
        gtk_text_set_truncate_multiline(text_ptr, gboolean((truncateMultiline) ? 1 : 0))
    
    }

    /// Sets whether the contents of the self are visible or not.
    /// When visibility is set to `false`, characters are displayed
    /// as the invisible char, and will also appear that way when
    /// the text in the self widget is copied to the clipboard.
    /// 
    /// By default, GTK picks the best invisible character available
    /// in the current font, but it can be changed with
    /// `gtk_text_set_invisible_char()`.
    /// 
    /// Note that you probably want to set `GtkText:input`-purpose
    /// to `GTK_INPUT_PURPOSE_PASSWORD` or `GTK_INPUT_PURPOSE_PIN` to
    /// inform input methods about the purpose of this self,
    /// in addition to setting visibility to `false`.
    @inlinable func setVisibility(visible: Bool) {
        gtk_text_set_visibility(text_ptr, gboolean((visible) ? 1 : 0))
    
    }

    /// Unsets the invisible char previously set with
    /// `gtk_text_set_invisible_char()`. So that the
    /// default invisible char is used again.
    @inlinable func unsetInvisibleChar() {
        gtk_text_unset_invisible_char(text_ptr)
    
    }
    /// Retrieves the value set by `gtk_text_set_activates_default()`.
    @inlinable var activatesDefault: Bool {
        /// Retrieves the value set by `gtk_text_set_activates_default()`.
        get {
            let rv = ((gtk_text_get_activates_default(text_ptr)) != 0)
            return rv
        }
        /// If `activates` is `true`, pressing Enter in the `self` will activate the default
        /// widget for the window containing the self. This usually means that
        /// the dialog box containing the self will be closed, since the default
        /// widget is usually one of the dialog buttons.
        nonmutating set {
            gtk_text_set_activates_default(text_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// A list of Pango attributes to apply to the text of the self.
    /// 
    /// This is mainly useful to change the size or weight of the text.
    /// 
    /// The `PangoAttribute`'s `start_index` and `end_index` must refer to the
    /// `GtkEntryBuffer` text, i.e. without the preedit string.
    @inlinable var attributes: Pango.AttrListRef! {
        /// Gets the attribute list that was set on the self using
        /// `gtk_text_set_attributes()`, if any.
        get {
            let rv = Pango.AttrListRef(gtk_text_get_attributes(text_ptr))
            return rv
        }
        /// Sets a `PangoAttrList`; the attributes in the list are applied to the
        /// text.
        nonmutating set {
            gtk_text_set_attributes(text_ptr, UnsafeMutablePointer<PangoAttrList>(newValue?.attr_list_ptr))
        }
    }

    @inlinable var buffer: EntryBufferRef! {
        /// Get the `GtkEntryBuffer` object which holds the text for
        /// this self.
        get {
            let rv = EntryBufferRef(gconstpointer: gconstpointer(gtk_text_get_buffer(text_ptr)))
            return rv
        }
        /// Set the `GtkEntryBuffer` object which holds the text for
        /// this widget.
        nonmutating set {
            gtk_text_set_buffer(text_ptr, UnsafeMutablePointer<GtkEntryBuffer>(newValue?.entry_buffer_ptr))
        }
    }

    /// Returns whether Emoji completion is enabled for this
    /// GtkText widget.
    @inlinable var enableEmojiCompletion: Bool {
        /// Returns whether Emoji completion is enabled for this
        /// GtkText widget.
        get {
            let rv = ((gtk_text_get_enable_emoji_completion(text_ptr)) != 0)
            return rv
        }
        /// Sets whether Emoji completion is enabled. If it is,
        /// typing ':', followed by a recognized keyword, will pop
        /// up a window with suggested Emojis matching the keyword.
        nonmutating set {
            gtk_text_set_enable_emoji_completion(text_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Gets the menu model set with `gtk_text_set_extra_menu()`.
    @inlinable var extraMenu: GIO.MenuModelRef! {
        /// Gets the menu model set with `gtk_text_set_extra_menu()`.
        get {
            let rv = GIO.MenuModelRef(gtk_text_get_extra_menu(text_ptr))
            return rv
        }
        /// Sets a menu model to add when constructing
        /// the context menu for `self`.
        nonmutating set {
            gtk_text_set_extra_menu(text_ptr, UnsafeMutablePointer<GMenuModel>(newValue?.menu_model_ptr))
        }
    }

    /// Gets the value of the `GtkText:input`-hints property.
    @inlinable var inputHints: InputHints {
        /// Gets the value of the `GtkText:input`-hints property.
        get {
            let rv = InputHints(gtk_text_get_input_hints(text_ptr))
            return rv
        }
        /// Sets the `GtkText:input`-hints property, which
        /// allows input methods to fine-tune their behaviour.
        nonmutating set {
            gtk_text_set_input_hints(text_ptr, newValue.value)
        }
    }

    /// Gets the value of the `GtkText:input`-purpose property.
    @inlinable var inputPurpose: GtkInputPurpose {
        /// Gets the value of the `GtkText:input`-purpose property.
        get {
            let rv = gtk_text_get_input_purpose(text_ptr)
            return rv
        }
        /// Sets the `GtkText:input`-purpose property which
        /// can be used by on-screen keyboards and other input
        /// methods to adjust their behaviour.
        nonmutating set {
            gtk_text_set_input_purpose(text_ptr, newValue)
        }
    }

    /// Retrieves the character displayed in place of the real characters
    /// for entries with visibility set to false. Note that GTK does not
    /// compute this value unless it needs it, so the value returned by
    /// this function is not very useful unless it has been explicitly
    /// set with `gtk_text_set_invisible_char()`
    @inlinable var invisibleChar: gunichar {
        /// Retrieves the character displayed in place of the real characters
        /// for entries with visibility set to false. Note that GTK does not
        /// compute this value unless it needs it, so the value returned by
        /// this function is not very useful unless it has been explicitly
        /// set with `gtk_text_set_invisible_char()`
        get {
            let rv = gtk_text_get_invisible_char(text_ptr)
            return rv
        }
        /// Sets the character to use in place of the actual text when
        /// `gtk_text_set_visibility()` has been called to set text visibility
        /// to `false`. i.e. this is the character used in “password mode” to
        /// show the user how many characters have been typed.
        /// 
        /// By default, GTK picks the best invisible char available in the
        /// current font. If you set the invisible char to 0, then the user
        /// will get no feedback at all; there will be no text on the screen
        /// as they type.
        nonmutating set {
            gtk_text_set_invisible_char(text_ptr, newValue)
        }
    }

    /// Retrieves the maximum allowed length of the text in
    /// `self`. See `gtk_text_set_max_length()`.
    /// 
    /// This is equivalent to getting `self`'s `GtkEntryBuffer` and
    /// calling `gtk_entry_buffer_get_max_length()` on it.
    @inlinable var maxLength: Int {
        /// Retrieves the maximum allowed length of the text in
        /// `self`. See `gtk_text_set_max_length()`.
        /// 
        /// This is equivalent to getting `self`'s `GtkEntryBuffer` and
        /// calling `gtk_entry_buffer_get_max_length()` on it.
        get {
            let rv = Int(gtk_text_get_max_length(text_ptr))
            return rv
        }
        /// Sets the maximum allowed length of the contents of the widget.
        /// 
        /// If the current contents are longer than the given length, then
        /// they will be truncated to fit.
        /// 
        /// This is equivalent to getting `self`'s `GtkEntryBuffer` and
        /// calling `gtk_entry_buffer_set_max_length()` on it.
        /// ]|
        nonmutating set {
            gtk_text_set_max_length(text_ptr, gint(newValue))
        }
    }

    /// Gets the value set by `gtk_text_set_overwrite_mode()`.
    @inlinable var overwriteMode: Bool {
        /// Gets the value set by `gtk_text_set_overwrite_mode()`.
        get {
            let rv = ((gtk_text_get_overwrite_mode(text_ptr)) != 0)
            return rv
        }
        /// Sets whether the text is overwritten when typing in the `GtkText`.
        nonmutating set {
            gtk_text_set_overwrite_mode(text_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Retrieves the text that will be displayed when `self` is empty and unfocused
    @inlinable var placeholderText: String! {
        /// Retrieves the text that will be displayed when `self` is empty and unfocused
        get {
            let rv = gtk_text_get_placeholder_text(text_ptr).map({ String(cString: $0) })
            return rv
        }
        /// Sets text to be displayed in `self` when it is empty.
        /// 
        /// This can be used to give a visual hint of the expected
        /// contents of the self.
        nonmutating set {
            gtk_text_set_placeholder_text(text_ptr, newValue)
        }
    }

    /// Returns whether the `GtkText` will grow and shrink
    /// with the content.
    @inlinable var propagateTextWidth: Bool {
        /// Returns whether the `GtkText` will grow and shrink
        /// with the content.
        get {
            let rv = ((gtk_text_get_propagate_text_width(text_ptr)) != 0)
            return rv
        }
        /// Sets whether the GtkText should grow and shrink with the content.
        nonmutating set {
            gtk_text_set_propagate_text_width(text_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// A list of tabstops to apply to the text of the self.
    @inlinable var tabs: Pango.TabArrayRef! {
        /// Gets the tabstops that were set on the self using `gtk_text_set_tabs()`, if
        /// any.
        get {
            let rv = Pango.TabArrayRef(gtk_text_get_tabs(text_ptr))
            return rv
        }
        /// Sets a `PangoTabArray`; the tabstops in the array are applied to the self
        /// text.
        nonmutating set {
            gtk_text_set_tabs(text_ptr, UnsafeMutablePointer<PangoTabArray>(newValue?.tab_array_ptr))
        }
    }

    /// Retrieves the current length of the text in
    /// `self`.
    /// 
    /// This is equivalent to getting `self`'s `GtkEntryBuffer` and
    /// calling `gtk_entry_buffer_get_length()` on it.
    @inlinable var textLength: guint16 {
        /// Retrieves the current length of the text in
        /// `self`.
        /// 
        /// This is equivalent to getting `self`'s `GtkEntryBuffer` and
        /// calling `gtk_entry_buffer_get_length()` on it.
        get {
            let rv = gtk_text_get_text_length(text_ptr)
            return rv
        }
    }

    /// Returns whether the `GtkText` will truncate multi-line text
    /// that is pasted into the widget
    @inlinable var truncateMultiline: Bool {
        /// Returns whether the `GtkText` will truncate multi-line text
        /// that is pasted into the widget
        get {
            let rv = ((gtk_text_get_truncate_multiline(text_ptr)) != 0)
            return rv
        }
        /// Sets whether the GtkText should truncate multi-line text
        /// that is pasted into the widget.
        nonmutating set {
            gtk_text_set_truncate_multiline(text_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    @inlinable var visibility: Bool {
        /// Retrieves whether the text in `self` is visible.
        /// See `gtk_text_set_visibility()`.
        get {
            let rv = ((gtk_text_get_visibility(text_ptr)) != 0)
            return rv
        }
        /// Sets whether the contents of the self are visible or not.
        /// When visibility is set to `false`, characters are displayed
        /// as the invisible char, and will also appear that way when
        /// the text in the self widget is copied to the clipboard.
        /// 
        /// By default, GTK picks the best invisible character available
        /// in the current font, but it can be changed with
        /// `gtk_text_set_invisible_char()`.
        /// 
        /// Note that you probably want to set `GtkText:input`-purpose
        /// to `GTK_INPUT_PURPOSE_PASSWORD` or `GTK_INPUT_PURPOSE_PIN` to
        /// inform input methods about the purpose of this self,
        /// in addition to setting visibility to `false`.
        nonmutating set {
            gtk_text_set_visibility(text_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    // var parentInstance is unavailable because parent_instance is private

}



